---
layout: post
title: Computer Architecture
date: 2019-03-14 10:34:32
categories: 
 - [LinuxC] 
 - [Operate System]
tags: [OS]
---

# Computer Architecture

+ Von Neumann 体系结构主要由CPU(processor) + Memory ( data + fetch ) 
+ 数据的存储，访问和管理

## 操作系统

1. 程序运行的过程: 执行指令
   + 内存中fetch（取址）-- decode（解码） -- excuse（执行）具体的操作
   + 冯诺依曼计算机模型
2. 操作系统作用：
   + 程序运行需要内存调度, 设备交互;
   + OS 作用: 确保系统易于使用且高效运行；
3. OS 如何实现程序的高效运行：
   + **虚拟化**: 将物理资源(CPU, 内存, 磁盘)转换为更通用, 更强大的虚拟形式;
   + 标准库API: 用户与OS交互的接口, 告诉操作系统执行哪些功能;
   + 资源管理器: OS充当的角色, 合理高效的分配资源
   + 虚拟化CPU: 决定执行哪个程序；
   + 虚拟化内存：数据结构的保存；
4. **虚拟化**
   + 虚拟化CPU
     + 硬件资源 + OS : 虚拟化实现多个CPU, 可移执行多个进程;
     + 多进程的调度: OS有一定的**机制 + 策略**
   + 虚拟化内存
     + 程序的执行过程: 指令 和 数据都是保存在内存中的;
     + OS将内存映射的足够: 程序执行的整个过程;
5. **并发**
   + 在同一个内存空间中：运行的多个函数；
   + 每次都有多个线程处于活动状态；
6. **持久性**
   + 通过文件系统，对数据进行持久的保存
7. 操作系统设计的目标
   + 建立抽象：方便系统的调用；
   + 高效性能：减少开销
   + 提供保护：在应用程序之间，以及OS和应用程序之间提供保护
     + 使用的方法：隔离

## 内存和地址

1. 地址
   + CPU通过address找到存储单元，每个存储单元只能存一个byte，将数据放入存储单元中。
2. 内存
   + 内存的大小：却绝育CPU的地址空间；
   + 32位：0x0000 0000 - 0xffff ffff 
3. 找存储位置，进行读 / 写操作。

## CPU

+ CPU总是周而复始地做同一件事 : 从内存取指令,然后解释执行它,然后再取下一条指令,再解释执行

### CPU 包含功能单元

1. Register ：

   + 是CPU内部的高速存储器，像内存一样可以存取数据，速度更快。

2. 程序计数器

   + 保存CPU取指令的地址，CPU读到地址后，按照地址去内存中取指令；
   + 取完本次指令后，指向内存中的下一条指令
   + 是CPU的特殊寄存器

3. 指令解码器

4. 算数逻辑单元 ALU

5. 地址和数据总线

   + 32位处理器有32条地址线和32条数据线
   + 可以表示一个32位的数

   {% asset_img AddressBus.png %}

## 设备

+ CPU除了访问内存外，还要访问很多Device

### 总线

1. 总线：正因为地址线和数据线上可以挂多个设备和内存芯片所以才叫“总线”,但不同的设备和内存应该占不同的地址范围。
2. 加载：操作系统在执行程序时，从硬盘拷贝到内存，这样CPU才可以取指令执行。
3. 进程：程序加载到内存后，成为操作系统调度执行的一个任务。
4. 中断：为了提供设备发送主动请求。
5. 中断处理的步骤：先判断哪个设备引发的中断，然后调用该设备驱动程序提供中断处理函数。
6. Linux内核源代码：绝大部分是设备驱动程序。
7. 设备驱动程序：是操作系统内核里的一组函数,主要是通过对设备寄存器的读写实现对设备的初始化、读、写等操作，有些设备还要提供一个中断处理函数供ISR调用。

| CPU访问的类别              | Memory                        | Device                           |
| -------------------------- | ----------------------------- | -------------------------------- |
| 访问方式                   | 按地址进行读写                | 按地址进行读写                   |
| 访问操作                   | a按地址找到存储单元，进行读写 | 给设备发一个命令，数据不一定保存 |
| 集成在处理器的芯片访问方式 |                               | 内存映射I/O，端口I/O             |
| 数据                       | 只保存数据                    | 产生新的数据                     |
| 请求                       | 被动等待读和写                | 主动发送请求                     |

## Memory Management Unit

### 虚拟内存管理 VIrtual Memory Management

1. 操作系统需要用VMM ：需要MMU的支持。
2. 物理地址：处理器没有MMU，CPU执行单元发送的**内存地址**将直接传到芯片引脚，被内存芯片（物理内存）接受。
3. 虚拟地址：CPU发送的**内存地址**被MMU捕获，从CPU到MMU的地址。

### 物理地址和虚拟地址

1. 32位的CPU：指CPU的寄存器是32位，数据总线是32位，虚拟地址空间是32位。
2. 物理地址的范围：取决于处理器芯片上的芯片引脚有多少条地址线，
3. 虚拟地址映射带物理地址：MMU进行管理分配，具体细节就不聊了。

### MMU 内存保护机制

1. MMU除了做地址转换（虚拟--物理）之外，还提供内存保护机制。
2. 内存保护机制：操作系统设置的访问权限。
   + 操作系统将虚拟地址空间划分为：用户空间和内核空间。
   + 中断：从用户空间切换到内核空间，处理异常。（用户空间的切换，必须有中断发起）

## Memory Hierachy

1. 计算机的存储器分为若干等级，按照离CPU的远近依次是：

   {% asset_img memory.png %}

2. 寄存器，Cache，内存中的数据都是掉电易丢失；

3. 寄存器访问：由程序指令直接控制之外；其他的存储器都不是由指令直接控制的。