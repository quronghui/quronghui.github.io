---
layout: post
title: hash_ADT
date: 2019-05-19 09:52:03
categories: 
- [data_struct_algorithm]
tags: hash
---

# Hash ADT

## Introduction

1. 散列表

   + 以常数平均时间执行插入、删除、和查找的技术；

2. 散列表的ADT

   + 包含有关键字的具有固定大小的数组

3. 散列

   + 将关键字，通过散列函数映射到，0-tablesize 的表中存储

   1）散列函数的选择；

   2）分配到同一值的冲突解决；

   3)  关键字：字符类型的不同，决定了散列函数

## 散列函数

1. 散列函数的选择

   + key mod tablesize ：余数是几，放在相应的表中存储；
   + tablesize：取素数，减少（key mod tablesize）为同一个值的概率
   + 所以会造成冲突

2. 分离链接法---解决冲突

   + 构造链表数组：解决冲突

   + 1) 分配一个存储空间：存储 0 - tablesize；

     2） 每一个 tablisize:分配一个数组，存储相同的值的关键字；

     3) 每个数组：分配一个头指针 header

     */

   + 保证素数：减少占同一个值的情况

     + 表头：如果链表不涉及删除，那么可以去掉表头

## 开放定址法

1. 分离链接法
   + 每个新单元插入：需要指针；malloc分配存储单元
2. 开放定址法
   + 创建一个大的数组，对数据进行散列存储；
   + 冲突：按照函数F 进行探测，查找空单元

### 线性探测法

1. 探测函数：

   F(i) = i;	// 一步步的往前探测，直到出现空单元

2. 探测因子

   + 介于0-1之间；
   + 计算插入一个函数时：成功探测和不成功探测，需要的次数

   {% asset_img test.png %}

3. 出现问题：

   + 一次聚集：占据的单元会形成一块区域

### 平均探测法

1. 探测函数：

   F(i) = i^2 ;	// 消除一次聚集的问题

2. tablesize 为素数

   + 一旦表的填充过半，如果tablesize是素数，中能找到一个空的单元

3. 问题：

   + 消除一次聚集，产生二次聚集

### 双散列

1. 探测函数：
   + F(I) = i * hash(x)
   + hash(x) = R -  X mod R

## 再散列

1. 当分配的 0-tablesize 空间产生冲突时：
   + 选择创建一个 2 * tablesize 空间；
   + 将原先的关键字，迁移到新的空间

|       | 散列表                           | 二叉树         |
| ----- | -------------------------------- | -------------- |
| find  | 不能迅速找到一定范围内的所有项   | 快速找到       |
| other | 不需要存储有序的信息，           | 存储有序的信息 |
|       | 对图论是有效的；在线拼写检验程序 |                |

