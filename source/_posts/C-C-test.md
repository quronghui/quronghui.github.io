---
layout: post
title: C_C++_test
date: 2019-05-27 14:31:31
categories: 
- [牛客网]
tags: C/C++
---

# C/C++ test

## Question

1. 数组和指针间的相互表示？
   + 用指针表示某一个数组元素
2. 常量的表示
   + e 后面是指数，不能有小数：e0.4 

## 关键字

1. 全部都是C / C++关键字

   + 关键字小写；
   + C/C++ 没有太大区别

   {% asset_img static.png %}

## 类型转换

1. 假定x和y为double型，则表达式x=2，y=x+3/2的值是
   + 3/2=1
   + 3.0/2.0=1.500000 
   + y = (double) 3/2;  --> 1.5

2. 取余数

   + 0 % 2 余数和商都是 0；

3. printf

   ```
   以下程序段的输出结果是（ ）。
   int a=1234；
   printf("%2d\n",a);
   ```

   + %d前面的数字表示打印格式的位数。
   + 如果输出的内容位数**不足**将会在左边补足空格
   + 如果输出的内容位数**超过%d前面的数字**会将内容**全部输出**，%d前面的数字相当于无效

## typedef and #define

1. 代码：判断哪个不是指针

   ```
   #define INT_PTR int*
   typedef int* int_ptr;
   INT_PTR a,b;
   int_ptr c,d; 
   ```

   + **typedef** 给已有类型声明一个**别名**，故**c和d都是int_ptr类型也即都是int \*类型**；
   + **#define宏定义**，在预编译时直接进行**简单替换**，即原式变为：**int\* a,b; 这相当于是int \*a, int b;** 

2. define 宏定义时，加括号

   + define 后，应该是一个整体；

   ```
   #define  FUN(A,B)  A+B		FUN(2,3)*4 = 2+3*4;
   #define  FUN(A,B)  (A+B)	FUN(2,3)*4 = (2+3)*4;
   ```

3. ```
   int``* p1, p2; ``// p1是指向int的指针，p2是int
   int *p1, *p2; // p1和p2都是指向int的指针
   ```

4. #define
   + #define只是在预处理阶段将a替换为相应数值，具体替换的值只与define在文件中的位置有关；
   + #define 将值替换后给最近的函数使用； 

## 基本概念

1. 一个 C 语言程序是由：函数组成

   + 不是程序组成

2. 创建对象，是否需要初始化

   + 需要初始化
     + 静态对象：需要初始化；
     + 局部变量：需要初始化；
   + 不需要初始化
     + 全局变量，不初始化时为0；

3. 循环

   ```
   do { 
   ... 
   }while();	/ 加；号 /
   ```

4. 关于 return 语句

   + 在主函数和其他函数中均可出现
   + 可以在同一个函数中出现多次

   ```
   # if else;	/* 一个函数中可以出现多次，一次运行只能有一个return进行返回 */
   ```

5. 字符常量

   + 用单引号

6. 关于“深拷贝”

   + 会拷贝动态分配的成员对象

7. 32 位 的long and int  一样，占4个字节；

8. C语言中最简单的数据类型包括

   + ```
     整型、实型、字符型
     ```

9. 不能作为重载函数的调用的依据是：

10. 基类型相同的两个指针变量之间，不能进行的运算是

    {% asset_img pointer.png %}

## 数组

1. 数组a[3] [ 4 ] 不正确引用 

   ```
   a[3] [ 4 ]  /* 0-(N-1)：访问不到a[3][4],超出界限 */
   ```
   
2. 数组定义时候：

   + 列必须确定，行可以不确定

3. 数组越界问题

   ```
   a[2] = {'0', '1', '2'};	/* 数组越界了 */
   ```

4. 数组打印

   ```
     printf("%d\n", s);	/* %d 只打印首地址 */
   ```

5. 数组的赋值：

   + 在数组定义的时候进行赋值；
   + 在被调用函数中，不需要考虑形参数组的大小;

6. 形参和实参

   + 实参和与其对应的形参各占用独立的存储单元
   + 形参在编译时是不会分配存储容间，在调用时才在栈里分配

7. 输入输出语句

   + 输入和输出并不是C++语言中的正式组成成分｡
   + C和C++本身都没有为输入和输出提供专门的语句结构｡
   + 输入输出不是由C++本身定义的,而是在编译系统提供的I/O库中定义的｡ 
   + 用C程序实现的算法可以没有输入但必须要有输出

## 函数

1. sizeof and strlen

   ```
   $ sizeof();	/* 结尾包含字符 '\0' */
   $ strlen();	/* 结尾不包含 */
   ```

   + sizeof（str）:str中间有 \0 时，算作一个字符；
   + strlen（str）: 遇到 \0时，便停止计算大小

   ```
   void strarray()
   {
       char x[] = "abcde";
       char y[] = {'a', 'b', 'c', 'd','e'};
       printf("sizeofx[] = %ld\n", sizeof(x)); /* 包含末尾的\0 */
       printf("strlenx[] = %ld\n", strlen(x));
       printf("sizeofy[] = %ld\n", sizeof(y)); /* 字符长度 */
       printf("strleny[] = %ld\n", strlen(y)); /* 包含所有字符 */
       char *p = x;
       printf("p = %ld\n", sizeof(p)); /* 指针类型占得字节数 */
   
       printf("strlen = %ld\n", strlen("std\n007\1\\"));
       
       char a[] = "a\0b\054de";    /* 是一个8进制数 */
       printf("strlen = %ld\n", sizeof(a));
   
   }
   sizeofx[] = 6
   strlenx[] = 5
   sizeofy[] = 5
   strleny[] = 10
   p = 8
   strlen = 9
   strlen = 8
   ```

2. malloc

   + malloc函数进行内存分配是在什么阶段: 执行阶段

3. #include 

   ```
   #include <>		/* 从标准库文件目录下搜索，对于标准库文件搜索效率快。*/
   #include ""		/* 从用户工作目录下开始搜索，对于自定义文件搜索比较快，然后搜索整个磁盘。 */
   ```


## 结构体

1. 32位系统中，结构体中的对齐

   ```
   struct A		
   {
    int a;  char b;  short c;	/* 4, 1, 2 byte  内存对齐：4，2，2*/
   };
   struct B
   {
    char b;  int a;  short c;	/* 1, 4, 2 byte */
   };
   ```

   + 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。

## Token 划分

1. 自加运算符 ++
   + ++运算符的操作数必须是左值；a++;
   + a++ 之后便是表达式，不是左值了，因此在使用 a++ ++ 就是错误

## 位运算

1. 按位与、或、异或、取反

   {% asset_img bit.png %}

## C++

1. 基类的公有成员是其私有派生类的（ 私有  ）成员

2. C++ 不能重载的是

   ```
   $ '.*' ; '::'	/* 不能重载的是 */
   $ '*' ; operator  delete	/* 可以重载 */
   ```

   