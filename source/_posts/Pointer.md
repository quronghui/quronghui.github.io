---
layout: post
title: Pointer
date: 2019-03-22 14:42:36
categories: 
 - [LinuxC]
 - [Pointer]
tags: pointer
---

# Pointer (指针)



## 指针的基本操作

### 理解指针

1. 堆栈和队列

   + 堆栈有栈顶指针，队列有头指针和尾指针
   + 这种指针本质：是一个整数，是数组的索引

2. 指针概念

   + 把一个变量所在的内存单元的**地址**
   + 保存在另外一个内存单元 
   + 此**内存单元** 称为指针

   ```
   int i;
   int *pi = &i;	/*全局变量的赋值：右边必须是常量表达式*/
   char c;
   char *pc = &c;	/*32位的虚拟机，他们的内存单元都是4 byte*/
   ```

### 根据指针知找到变量

1. {% asset_img pointer.png %}

### 指针的关系

1. - &运算符的操作数必须是左值,因为只有左值（变量）才表示一个内存单元,才会有地址,
   - 表达式E可以做左值（变量），*&E = E
   - E是指针类型，&*E = E

   ```
   int *p;		/*定义指针类型p*/
   p = &i;		/*此时p保存的是i的地址*/
   int j = *p;	/*此时 *p = *&i; 也就是i的值*/
   ```

   

2. 指针间的赋值

   ```
   int *ptri;
   ptri = pi;		/*是把变量pi所保存的地址值赋给变量ptri*/			
   ```

   + 保证ptri 和 pi是同一种类型，否则需要强制转化
   + 指针很容易指向错误的地址，访问这样的地址可能导致段错误

### 空指针和野指针

+ 定义局部类型的指针变量，却没有赋值 -- 野指针(Unbound Pointer)（局部变量定义却不赋值）

+ 避免野指针，定义指针变量因该赋值，货值初始化NULL

  ```
  int *p = NULL;
  #define NULL ((void *)0)	/*将地址0转换为指针类型*/
  /*任何对地址0的访问都会立刻产生段错误*/
  ```

### void * 类型

1. void *指针与其它类型的指针之间可以隐式转换,而不必用类型转换运算符。
2. 只能定义void *指针，而不能定义void 型的变量。
3. 因为void *指针和别的指针一样都占4个字节，void型的变量就不清楚了
4. void *指针不能直接Dereference,而必须先转换成别的类型的指针再做Dereference。

### 指针类型的参数和返回值

```
int *swap(int *px, int *py)		/*指针类型的形参*/
{
	...
    return px;		/*如果需要指针类型的返回值，需要定义指针类型的函数*/
}
```



## 指针和数组

1. 关系

   + 地址之间的关系：
     + int 型元素占4个字节，pa++使pa指向的地址加4，不是加1
   + 指针与变量之间的关系
     + 指针保存变量的地址

2. 指针和数组的关系

   + 右值：在赋值符号“ = ”，右边的常量表达式，相当于要存储的值

   + 数组名做右值使用时,自动转换成指向数组首元素的指针。

   + 字符串字面值还有一点和数组名类似,做右值使用时自动转换成指向首元素的指针。

     ```
     a[2] 能取到数组的第三个元素，相当于 *（a+2）
     *(pa+2) --> pa[2];	//做右值的时候自动转化为指针
     ```

3. 指针指向数组 a[0] 的首地址

   ```
   int a[10];
   int *pa = &a[0];		/*后缀运算符优先级高于单目运算符*/
   pa++;
   ```

   + 由于数组a做右值使用时和 &a[0]是一样的
   + 表达式pa[-1] 是合法的,它和a[0] 表示同一个元素。

   ```
   int *pa = &a[0]; 
   等价于 ：int *pa = a;
   ```

4. 指针的比较运算

   + 只有指向同一数组的指针，作比较才有意义
   + 指针的比较比的是地址

5. 指针的相减运算

   + 相减：表示两个指针间，相差的元素个数

     {% asset_img array.png %}

     ```
     pa - a = ?
     pa - 1 = a; pa - a = 1 
     ```

6. 函数的参数是数组时，等价于参数是指针的形式

   ```
   void func(int a[10])
   等价于 ： void func(int *a)
   ```

## 指针与const限定符

+ const : 将不允许修改的内存单元保护起来；
+ 看 const 离哪个比较近，则保护的便是它

### 指向const int 型的指针

1. 代码方式

   ```
   const int *a;
   or int const *a;
   ```

2. 代表含义

   + a 是一个指向const int 型的指针；
   + a 指向的内存单元是不能修改的。（a 代表地址的内存单元）
   + （*a）++ 不允许 （值）；a++允许（地址）
   + 只能读指针a 指向的元素

### 指向int 型的 const 指针

1. 代码方式：

   ```
   int * const a;
   ```

2. 代表含义

   + *a是可以改写的,内容的值可以修改
   + a不允许改写，地址不能修改

### 指向const int 型的 const 指针

1. 代码方式：

   ```
   const int * const a;
   or int const * const a;
   ```

2. 代表含义

   + 因此*a 和a都不允许改写。

### 结论

1. 指向非const 变量的指针或者非const 变量的地址可以传给指向const 变量的指针,编译器可以做隐式类型转换,例如:

   ```
   char c = 'a';
   const char *pc = &c;	// c 的值是不会改变的
   ```

2. const 使用

   {% asset_img const.png %}

3. 字符串字面值通常分配在.rodata段

   + .rodata：不允许改写，但编译器不会报错，在运行时会出现段错误。

## 指针与结构体

1. 定义结构体类型

   + typedef：相当于一个命名，将struct unit 命名为了unit
   + 好处：在定义struct unit 类型的变量时：可以只写unit

   ```
   struct unit{			-->		typedef struct{
       char c;				-->			char c;
       int num;			-->			int num;
   };						-->		}unit;
   struct unit u;			-->		unit u;
   struct unit *p = &u;	-->		unit *p = &u
   ```

2. 指针访问结构体元素

   ```
   way1 ： (*p).c ，(*p).num;
   way2 :  p->c , p->num
   ```

## 指向指针的指针与指针数组

### 指向指针变量的指针

1. 指针可以指向基本类型，也可以指向复合类型，因此也可以指向另外的指针变量

2. 代码类型

   ```
   int i;
   int *pi = &i;	// pi 保存的是 i 的地址
   int **ppi = &pi;	// *(*ppi) = &pi: (*ppi)取 pi的值; *(*ppi) 取 i的值
   ```

### 指针数组

1. 指针数组的定义

   ```
   int a[10]; 		-->		int *a[10];
   int *pa = &a;	-->		int **pa = &a[0];	//指向指针数组的首元素
   ```

   + &a[0] 表示数组a的首元素的首地址；而&a 表示数组a 的首地址；
   + 显然这两个地址的数值相同，但这两个表达式的类型是两种不同的指针类型,前者的类型是int *,而后者的类型是int ( * )[10]
   + 则pa[0] 和a[0]取的是同一个元素;
   + 唯一比原来复杂的地方在于这个元素是一个int * 指针，不是基本类型

### main的标准原型

+ [main code]

1. main的原型

   ```
   int main(int argc, char *argv[]);
   ```

   + argc : 命令行参数的个数
   + 而argv 是一个指向指针的指针,为什么不是指针数组呢?
     + 函数原型中的[ ]表示指针而不表示数组，等价于char **argv
   + 那为什么要写成char *argv[]而不写成char  **argv 呢？
     + argv 不是指向单个指针,而是指向一个指针数组的首元素。
     + 数组中每个元素都是char *指针,指向一个命令行参数字符串。

2. main 原型的代码结构

   {% asset_img argv.png %}

## 指向数组的指针与多维数组

### 指向数组的指针

1. 代码定义：

   ```
   int *a[10]						-->		int (*a)[10];	
   /*********************Equivalent to:**********************/
   typedef int *t;					-->		typedef int t[10];
   t a[10];						-->		t *a;
   // a是一个数组，元素的类型是int *型
   ```

   + 可以认为 后缀运算符 [ ]，优先级高于 单目运算符 *
     + int *a[10]：a和[]先结合，a表示数组，数组元素是10个 int *型 的数
     + int (*a)[10]：a和 * 先结合，a表示指针，指向含有10 个int 型的数组

2. 指针数组使用

   + 指针数组 和 指向数组的指针

     ```
     指针数组：			-->		指向数组的指针
     int *a[10]			-->		int a[10];
     							int (*pa)[10] = &a;
     ```

   + *pa：表示pa指向的数组a；

   + ```
     a[0] -->  (*pa)[0];		(*pa) --> pa[0];	数组做右值的时候，自动转化为首元素指针
     所以引入二维数组： (*pa)[0] == pa[0][0]
     ```

### 多维数组

+ 通过指向数组的指针，表示二维数组；
+ 实现数组的自增和赋值作用

1. 多维数组的引用

   ```
   int a[5][10];			-->		int a[10];
   int (*pa)[10] = &a[0]	-->		int (*pa)[10] = &a;
   //则pa[0] 和a[0]取的是同一个元素
   ```

2. 多维数组的优势

   + pa 比a用起来更灵活，数组名不支持赋值、自增等运算；
   + 而指针可以支持，pa++ 使 pa 跳过二维数组的一行(40个字节)，指向a[1] 的首地址。

## 函数类型和函数指针类型

### 定义

1. 指针变量：内存单元存放一个地址值；

2. 函数指针：存放的就是函数的入口地址(位于.text 段)

   ```
   void func(const char *p){		-->		void (*func)(const char *p){
       ...函数						-->			... 函数指针
   }								-->		}
   ```

3. 而函数类型和数组类型类似,做右值使用时，自动转换成函数指针类型，所以可以直接赋值

   ```
   void say_hello(const char *str){
       printf("hello %s\n", str)
   }
   int main(void){
       void (*func)(const char *) = say_hello;	--> void (*func)(const char *) = &say_hello;
       f("Guys");								--> (*f)("Guys") or say_hello("Guys")
       return 0;
   }
   ```

   + 函数调用运算符() 要求操作数是函数指针,所以f("Guys") 是最直接的写法;
   + 而say_hello("Guys")或(*f)("Guys")则是把函数类型自动转换成函数指针然后做函数调用。