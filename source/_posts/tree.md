---
layout: post
title: tree
date: 2019-05-17 15:24:33
categories:
- [tree]
tags:
---

# Tree

1.文件系统：三种访问结构；前中后序访问

2.算术表达式的计算：后缀表达式转化为中缀表达式

3.树的搜索：将最坏的时间上届限制到O(logN)，通过二叉树进行控制.

## 树的实现

+ 通过递归的方式实现树

### 树的元素 -- 节点

1. 节点的父子关系

   1）n(1) --> n(2)：n(1) 是n(2)的祖先；

   2）n(1) != n(2);  n(1) 是n(2)的真祖先；

   3）parent 、child、sibling、leaf、grandparents、grandchild

2. 节点数的长度length：从1递增到n的

   1)节点深度depth：从root到n(i)的唯一路径长；root(depth) = 0

   2)节点的高度height：从n(i)到树叶leaf的最长路径; leaf(height) = 0

   3)一棵树的深度 = 高度

3. 树的一种表达方式

   ```
   struct treenode{
   	ElementType element;
   	struct treenode firstchild;	//第一个儿子节点
   	struct treenode nextsibling;	//下一个兄弟节点
   };
   ```

   {% asset_img firstchild.png %}

### 树的遍历

1. 遍历的顺序

   针对于父节点先处理还是后处理：

   1）先序遍历：先父节点，在左儿子节点，最后右儿子。

   + 打印出目录结构

   2）后序遍历：先左儿子节点，然后右儿子，在父节点。

   + 打印出每个文件占的块block大小

2. 所谓的驱动程序：是将硬件设备和内核之间建立连接，调用的时候相当于驱动？

## 二叉树

+ 二叉树：是一棵树，每个节点的child，不能多于两个。

+ 平均深度的计算：

  1）平均二叉树：depth = O(节点数开根)

  2）二叉查找树：depth = O(logN)

### 二叉树实现

1. 二叉树的图形表示：圆圈加直线
2. 二叉树的每一次插入：
   + 调用malloc创建一个节点；
   + 调用free删除后被释放；
3.  Null 指针：
   + 每一棵N节点的二叉树，需要（N+1）个NULL指针
   + 每一个叶子节点：包含两个NULL指针

### 二叉树应用----表达式树

1. 编译器的设计领域，计算表达式的应用：

   + 中序遍历策略：中缀表达式；

   + 后序遍历策略：后缀表达式；

   + 前序遍历策略：前缀表达式；

2. 树定义：表达式

   + 操作数：叶子节点

   + 运算符：父节点

3. 构造表达式树：

   + 把后缀表达式 转化为中缀表达式，每一部分加上括号
   + 方法相反：操作数压栈，读操作数时弹出操作数；

   a.  用指针指向：每个操作数，以及每次运算得到的大操作数

   + 操作数的指针压栈，顺序是左child，右child；
   + 读到操作符时弹出操作数：每次弹出两个操作数；
     + 操作符做为父节点；
     + 先弹出的做为右child；后弹出的为左child
   + 将每次操作后得到的**大操作数**指针：压入栈中；
   + 最后有一个指针指向这个**树**：将指针压入栈中
   + 栈中只有一个指针

   {% asset_img expression.png %}

### 二叉树应用---- 查找树ADT

```
/* 
*   tree.c
*   二叉查找树：用关键字表示
*   1)find tree:查找到叶子节点，还没的话，返回NULL
*   2)find_min _max: 递归和非递归的方式进行实现；
*       非递归：考虑base基准情况
*   3) insert: 插入元素的关键字时：考虑tree是否为空；tree不为空时，元素是否已存在
*   4) delete_x: 遍历得到元素位置，还得考虑该位置包含两个child和一个child的情况。
*/
```

1. 二叉查找树：

   1）每个节点：指定一个关键字值；

   2）关键字互异；

   3) 关键字：左子树的 < 小于X节点 < 右子树的

   4）元素关键字的排列是按照某种顺序进行

2. 二叉树的创建

   + 空间创建的时候：以节点数N来进行创建的。
   + 平均深度是O(logN)，不用担心栈空间用尽

3. 二叉树的删除：

   + 当被删除节点：包含两个child节点时；
   + 用该节点右子树的最小数据代替该节点的数据，并**递归的删除**那个节点；

4. 懒惰删除：

   + 当元素x的出现频率>1时，当删除x一次，只是频率减一，树不发生变化