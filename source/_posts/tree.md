---
layout: post
title: tree
date: 2019-05-17 15:24:33
categories:
- [data_struct_algorithm]
tags: [tree]
---

# Tree

1.文件系统：三种访问结构；前中后序访问

2.算术表达式的计算：后缀表达式转化为中缀表达式

3.树的搜索：将最坏的时间上届限制到O(logN)，通过二叉树进行控制.

## 树的实现

+ 通过递归的方式实现树

### 树的元素 -- 节点

1. 节点的父子关系

   1）n(1) --> n(2)：n(1) 是n(2)的祖先；

   2）n(1) != n(2);  n(1) 是n(2)的真祖先；

   3）parent 、child、sibling、leaf、grandparents、grandchild

2. 节点数的长度length：从1递增到n的

   1)节点深度depth：从root到n(i)的唯一路径长；root(depth) = 0

   2)节点的高度height：从n(i)到树叶leaf的最长路径; leaf(height) = 0

   3)一棵树的深度 = 高度

3. 树的一种表达方式

   ```
   struct treenode{
   	ElementType element;
   	struct treenode firstchild;	//第一个儿子节点
   	struct treenode nextsibling;	//下一个兄弟节点
   };
   ```

   {% asset_img firstchild.png %}

### 树的遍历

1. 遍历的顺序

   针对于父节点先处理还是后处理：

   1）先序遍历：先父节点，在左儿子节点，最后右儿子。

   + 打印出目录结构

   2）后序遍历：先左儿子节点，然后右儿子，在父节点。

   + 打印出每个文件占的块block大小

2. 所谓的驱动程序：是将硬件设备和内核之间建立连接，调用的时候相当于驱动？

## 二叉树

+ 二叉树：是一棵树，每个节点的child，不能多于两个。

+ 平均深度的计算：

  1）平均二叉树：depth = O(节点数开根)

  2）二叉查找树：depth = O(logN)

### 二叉树实现

1. 二叉树的图形表示：圆圈加直线
2. 二叉树的每一次插入：
   + 调用malloc创建一个节点；
   + 调用free删除后被释放；
3.  Null 指针：
   + 每一棵N节点的二叉树，需要（N+1）个NULL指针
   + 每一个叶子节点：包含两个NULL指针

### 二叉树应用----表达式树

1. 编译器的设计领域，计算表达式的应用：

   + 中序遍历策略：中缀表达式；

   + 后序遍历策略：后缀表达式；

   + 前序遍历策略：前缀表达式；

2. 树定义：表达式

   + 操作数：叶子节点

   + 运算符：父节点

3. 构造表达式树：

   + 把后缀表达式 转化为中缀表达式，每一部分加上括号
   + 方法相反：操作数压栈，读操作数时弹出操作数；

   a.  用指针指向：每个操作数，以及每次运算得到的大操作数

   + 操作数的指针压栈，顺序是左child，右child；
   + 读到操作符时弹出操作数：每次弹出两个操作数；
     + 操作符做为父节点；
     + 先弹出的做为右child；后弹出的为左child
   + 将每次操作后得到的**大操作数**指针：压入栈中；
   + 最后有一个指针指向这个**树**：将指针压入栈中
   + 栈中只有一个指针

   {% asset_img expression.png %}

### 二叉树应用---- 查找树ADT

```
/* 
*   tree.c
*   二叉查找树：用关键字表示
*   1)find tree:查找到叶子节点，还没的话，返回NULL
*   2)find_min _max: 递归和非递归的方式进行实现；
*       非递归：考虑base基准情况
*   3) insert: 插入元素的关键字时：考虑tree是否为空；tree不为空时，元素是否已存在
*   4) delete_x: 遍历得到元素位置，还得考虑该位置包含两个child和一个child的情况。
*/
```

1. 二叉查找树：

   1）每个节点：指定一个关键字值；

   2）关键字互异；

   3) 关键字：左子树的 < 小于X节点 < 右子树的

   4）元素关键字的排列是按照某种顺序进行

2. 二叉树的创建

   + 空间创建的时候：以节点数N来进行创建的。
   + 平均深度是O(logN)，不用担心栈空间用尽

3. 二叉树的删除：

   + 当被删除节点：包含两个child节点时；
   + 用该节点右子树的最小数据代替该节点的数据，并**递归的删除**那个节点；

4. 懒惰删除：

   + 当元素x的出现频率>1时，当删除x一次，只是频率减一，树不发生变化

## AVL 树

1. AVL树：是带有平衡条件的二叉查找树
   + 平衡条件：一棵AVL树是其**每个节点**的左子树和右子树的高度最多差1的二叉查找树
2. AVL 特性破坏：插入新的节点后，破坏了原来的AVL树特性
   + 插入新的节点，破坏了AVL的深度，插入的节点会变大，导致不在同一层
   + 旋转：重新平衡插入后树的深度

### 新的节点插入树的方式

1. 四中插入方式：

   {% asset_img insert_node.png %}

2. 单旋转

   + 元素插入是：左左插入和右右插入

3. 双旋转：

   + 元素插入是：左右插入和右左插入

### 旋转

1. 单旋转发生的操作：

   + 插入节点n的：父节点p往上升一级，n的祖父节点g往下降一级；

   + p的另外一个孩子，高度不变，换到相反的一边

   + 形成新的AVL树；

2. 插入节点n和父节点p，祖父节点g 进行比较：

   1）n < p < g : 破坏AVL平衡的话，单旋转便能达到新的平衡；

   2）p < n < g : 破坏AVL平衡的话，双旋转才行；

   3）原先节点p 的另外一个孩子，调整到另外一边

   4）插入多个数据的时候：单双旋转都需要进行；

   5）旋转除了保证AVL高度平衡外；还需要满足二叉树关键字大小的特性

3. 双旋转发生的操作

   + 插入节点n的：父节点p往上升二级，到达n的祖祖父节点gg 的位置，往下降一级；
   + p节点的其他孩子：在左边child的就分配到左边（做另外节点的右child）；

## 伸展树

1. 伸展树的思想：
   + 当一个节点被访问后，节点就要经过一系列AVL树的旋转到达根节点。
   + 不需要考虑存储的花费
2. 一棵伸展树每次操作的摊还代价是：O(log N)
   + 进行M次操作的时间就是 O(M logN )

### 展开：

+ 类似于前面介绍的旋转的想法，旋转的实施上有了选择

1. 情形一：之字形 zig-zag
   + AVL那样的双旋转
2. 情形二：一字形 zig-zig

{% asset_img one_tree.png %}

## 树的遍历

1. 总的运行时间是 O（logN）

   + 每个节点进行以此判断：NULL;
   + 执行函数是：printelement；
   + 运行时间是O(N)

2. 便利的应用

   + 中序遍历：进行关键字的排序

   + 后序遍历：计算出树的高度

   + 先序遍历：计算出树的深度

## B-树

1. 阶为M的B-树具备下列的结构

   {% asset_img b_tree.png %}

   + 儿子数 和 每个叶子节点包含的关键字数目 （M/2 -- M）
   + 所有的关键字包含在叶子节点上；其他的节点包含关键字的判断信息

2. 3 阶 B-树

   + 2-3 B树

   {% asset_img 2_3.png %}

3. M=3阶 B树 插入新的关键字

   + 如何进行调整
   + 不停的分裂出节点：节点包含的关键字在 （M/2 -- M）之间
   + 同一层调整不成功的话：增加树的深度（保证叶子节点在同一深度）

   {% asset_img change_b.png %}



## Difference

| tree       | 作用                                                         | 时间复杂度 |
| ---------- | ------------------------------------------------------------ | ---------- |
| 表达式树   | 分析树--编译器中<br />分析树不是二叉树：表达式树的扩充       |            |
| 查找树     | 递归实现查找                                                 |            |
| AVL树      | 要求每个节点的左右子树：height 差 < 1<br />插入关键字后：进行新的平衡--通过旋转 | O(logN)    |
| 伸展树     | 节点的深度：不做限制<br />节点就要经过一系列AVL树的旋转到达根节点。 | O(M logN)  |
| B-树       | 平衡M-路树，很好的匹配磁盘<br />平衡的条件：（除根节点）非叶子节点的儿子数；<br />                 叶子节点的关键字数 -- (M/2 -- M) |            |
|            |                                                              |            |
| 平衡树方案 | AVL 和 B-树；<br />没有二叉树的省时                          |            |

