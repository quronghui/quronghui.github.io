---
layout: post
title: graph
date: 2019-05-24 17:21:39
categories: 
- [data_struct_algorithm]
tags:
---

# Graph Alogrithm

## Dedine graph

1. 图Graph = [ 顶点（vertex），边（edge） ]

   1）每一条边：点对（v,w）属于V，或者弧（arc）

   2）点对有序：图是有向;

   3）无向图的边：还具有第三种成分，权（weight）

2. 考虑有向图和无向图中的边的区别

   1）（u, v）和（v, u）;

   2) 在无向图中，他们是相同的边，不是圈；

   3）再有向图中，他们是不同的边，是圈

3. 连通图：每一个顶点到其他顶点都存在一条路径；

   1）强连通图：有方向的；

   2）弱连通图：没有方向；

   3）完全图：每一对顶点间都存在一条边的图；

4. 邻接矩阵：一个二维数组表示每一条边；

   1）每条边（u, v）：A[u][v] = 1，相邻;

   2）有v个顶点，空间需求则是O( V^2 );

5. 图的标准表示：邻接表，通过散列表进行完成；

   1）将每个顶点进行内部编号：1 - V;

   2) 将有相邻边的内部编号和顶点名字存入指针数组中；

   3）具有相同顶点指向关系的顶点存在同一个指针数组中

   3）最终要输出顶点名字而不是内部编号

## 拓扑结构

1. 拓扑排序：是有向的无圈图的顶点组成；

   1）有向边（v, w）：v要在w之前弄完；

   2）邻接表：找出任意一个没有入边的顶点，存的是V顶点的出边；

2. 出队前的入度表：某个顶点，被其他顶点指向；则入度加1；

   1）指向：分为直接指向；间接指向（v1 --> v4）有路径完成指向

   2）入队：将所有入度为0的顶点放入一个初始为空的队列中；

   4）出队：每出队一个元素，删除该顶点

## 最短路径算法

1. 赋权路径长：权重值的和；

   无全路径长：从u -> v 的边数

   负值圈：边的权重是一个负值；

   1）负值圈的出现：最短路径就不确定；

   2）在没有负值圈时，从s到s的最短路劲为0

### 无权最短路径

 1. 方法

    + 1）某个顶点s作为输入参数，找出s到其他顶点的最短路径；
    + 2）最短路径：边数和最小；找相邻的顶点，边为1

	2.  广度优先搜索：

     1）按照顶点s到其他顶点的距离，进行分层处理；

     2）**每个顶点追踪三个信息**：

     3)  距离d： s到其他顶点的距离一开始为无穷，不可到达； d=0的点是选中的点；

     4）p(v)：簿记变量 -- 显示实际的路径；

     5）know：对应顶点被处理后置为1；

### Dijkstra 算法

1. 解决单源最短路径问题的方法；

   + 边有权重；
   + 有向图；

2. 此时d 的更新：权重之和；

   1）每个顶点否会被申明，也就是出队；

   2）此时表中的d路径是否更新：d保留的是最短路径；

   3）更新的顶点：是被申明顶点直接指向的点

## 网络流问题

1. s称为发点，t称为收点

   1）除了s点和t点外，其他的顶点v ：总的进入流 = 总的输出流；

   2）根据上面的点：更新图中的值

   3）算法结束时的最大的流量：s 到 t 可以通过的最大流量

2. G: 图

   G(f)：流图：算法任意阶段包含的流信息；

   G(r):   残余图，每条边还能再添加多少流

3. 要以路径上最小的流进行调整：

   G（f）:保存的是此次各边上流的信息；

   G（r）: 用G - G(f) 后的流的信息；

   1）更新残留图G(r)的信息，直到t由s出发是不能到达的，算法中止

## 最小生成树

1. 最小生成树：

   + 无向图中进行;

   + 最小生成树存在：当且仅当G是连通的

2. 最小生成树：构成的是树，不是图

   1）无向的图；

   2）包含所有节点；

   3）顶点只要被包含为节点就算成功，只考虑更新每个节点的最小值，

### prim算法

1. 计算最小生成树的方法
   + 把每一个节点当成root，往上加；
   + 每一步添加一条边和一个顶点到树上；

### kruskal 算法

1. 连续按照边的权重，由小到大开始选边；并且当选的边不产生圈时，确定这条边；
2. 算法处理的是一个森林；
   + Union/Find 的merge方法进行树的合并

## 深度优先搜索的应用

1. 深度优先搜索：先序遍历的推广；

   + 访问到该点，标记该点被访问过，并且对尚未标记的所有领接顶点递归调用深度优先搜索；
   + 使用邻接表，保证每一条边被访问一次；

2. 背向图

   实线：递归调用有效；

   虚线（背向图）：顶点被访问过，无效

   + 边（v, w）：如果w被访问过，那么Num(w)便是有值的，此时称为背向边

3. 双连通性

   + 任意顶点删除后，图还是连通的；
   + 割点：该顶点删除后，图将不在连通；

4. Num / Low

   Num():访问到该顶点时的编号；

   Low():  背向值指向的顶点编号

5. 欧拉回路

   + 附加条件：

     1）每条边只能走一次；

     2）笔不能离开纸张；

     3）还要回到起点，终点和起点在同一个位置；

   + 欧拉回路：

     1）当图是连通的，并且每个顶点的度（边的条数）是偶数才能存在；

     2）边为偶数：入度+出度

   + 解决这个问题：

     1）找出有尚未访问的边的路径上的第一个节点p；

     2) p作为root进行另外一次优先搜索，得到一个圈，每个点的度为偶数，将此时的回路拼接到原来的回路上；

     3）循环到所有边都遍历位置（一个顶点会出多次，多条边）

   + 欧拉回路实现：

     1）增加数据结构：保留路径作为一个链表，便面重复扫面；

     2）邻接表：有一个指针指向后一个元素