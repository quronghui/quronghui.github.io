---
layout: post
title: Sword_offer
date: 2019-06-03 09:52:19
categories: 
- [offer]
tags: [sword offer]
---

# Sword_offer

+ [code](<https://github.com/quronghui/DataStructAndAlogrithmCode>)

+ 题目分析，判断条件，边界检测

## 总体规划 

+ 开始时间：2019.6.12号
+ 看的书籍：LinuxC ，数据结构和算法C描述，剑指offer
+ 参加招聘公司：编程问题很严重

| 开始时间： | 结束时间  | 做的事情                                               |
| ---------- | --------- | ------------------------------------------------------ |
| 2019.6.12  | 2019.6.30 | 1. 剑指offer的代码编程<br />题目思考模式<br />代码框架 |
|            |           | 2. C编程语言的基础知识 LinuxC，再过一遍                |
|            |           | 3. 软件设计模式                                        |



## 广泛阅读

1. [UML设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html)
   + [时序图](<https://www.jianshu.com/p/51318fefdcaa>)
   + 
2. 

## 技术面试 ( 6月份 完成 )

1. 基础知识
   + 编程语言：多翻阅几次C 的相关知识；
     + LinuxC
     + C Primer
   + 数据结构：熟练掌握链表，树，队列，栈，哈希表；
     + 链表的插入和删除
     + 二叉树的遍历
   + 算法：查找和排序算法
     + 二分查找；
     + 归并排序；
     + 快速排序；
2. 题目的分析方法
3. 代码结构的布局
4. 代码的检验

## 数据结构

1. 熟悉数据结构之间的特点，才知道如何选择

   

   | 数据结构类型 | 类型         | 特点                             |
   | ------------ | ------------ | -------------------------------- |
   | 数组和字符串 | 最基本       | 连续内存分别存储数字和字符       |
   | 链表和树     | 出现频率最高 | 操作大量指针，留意代码鲁棒性     |
   | 栈           | 算法采用方式 | 与递归紧密相关                   |
   | 队列         | 算法采用方式 | 与广度优先遍历算法相关           |
   | 哈希表       |              | 解决问题：第一次只出现一次的字符 |

2. 解决的问题

   

   | 数据结构类型 | 创建                     | 解决问题               |
   | ------------ | ------------------------ | ---------------------- |
   | 哈希表       | 数组实现，下标实现键值对 | 第一次只出现一次的字符 |
   |              |                          |                        |
   |              |                          |                        |
   |              |                          |                        |
   |              |                          |                        |

### 数组特征



### 字符串

1. feature

   + 末尾有一个'\0'，内存覆盖要有警惕；

2. 解决问题

   + a. 字符串中空格的替换
   + b. 两个数组，将B数组插入A数组

   | 字符串的情况                                     | 方法                     | 时间 | 空间 |
   | ------------------------------------------------ | ------------------------ | ---- | ---- |
   | 数组未有递增的规律；                             | 复制到新的空间           | O(N) | O(N) |
   | 不允许使用新的空间<br />原数组保证足够的空间大小 | 从后往前进行查找替换空格 | O(N) | O(1) |

### 链表

​	

## 编程中的知识点

### 数组

1. bool 类型

   ```
   #include <stdbool.h>	//C中包含头文件
   ```

2. while 和for 循环

   + for : 准确知道循环次数；
   + while：准确知道循环结束条件

3. 数组的长度

   ```
   length = sizeof(array) / sizeof(int); /* 分32位和64位的系统，判断数组中一个元素占4个字节 */
   ```

4. 二维数组的表示

   + 通过一位数组的方式，表示二维数组

   ```
   matrix[row*cols + col] == number) 
   ```

5. 题目强调不能修改数组中的元素

   ```
   const int *number;
   ```

6. 数组越界情况

   + array [ N ] ：元素访问从 array[0] -- array[ N-1 ]
   + array [N] : 访问不到

### 字符串

1. 字符串 赋值给数组

   + 字符串结尾影藏 '\0';
   + 字符串赋值给数组：数组要分配内存空间存储
   + 字符串赋值给指针：指针指向字符串地址，不分配内存空间

2. 网络编程中，URL参数含有 #，空格，则不能正常访问

   + 将特殊字符进行替换
   + 替换规则 ： % + ASCII(十六进制表示)

   {% asset_img URL.png %}

3. 字符串赋值数组

   + *使用变量定义长度时，不可在定义时同时进行初始化赋值，需要在之后进行赋值

   ```
   const int length = 100; 
   char string[length] ;   
   strcpy(string, "hello world");
   ```


### 链表

1. 链表的存储空间是不连续的，需要插入新的节点的时候

   ```
   #include <stdlib.h>
   $	malloc
   ```

2. 单链表插入时，根节点的访问

   + 采用指针指向头结点指针，这样修改的时候就只是修改phead的地址

   ```
   void addToSomewhere(List **pHead, int value)	/* 指向指针的指针 */
   // 访问函数
   List *pHead;
   addToSomewhere( &pHead, value );
   ```

   + 先找出前驱节点，然后再进行插入节点

     ```
     	/* 找出插入value的 前驱节点, 先找出前驱位置 */
         while(pNode != NULL && pNode->mValue < value){
             previous = pNode;
             pNode = pNode->pNext;
         }
         
     **  pNew->pNext = pNode;     /* 先将后面的节点放在新节点后 */
         if(previous == NULL)      /* 头结点为空,要进行判断 */
             *pHead = pNew;      
         else{
             previous->pNext = pNew;
         }  
     ```

3. 双链表的插入：学会画图理解指针

   ```
   
   ```
*   题目：双链表 节点的插入和删除
   *   1) 双链表的插入有四种情况：
   *       a.插入到链表中间；b.插入到起始位置；  
   *       c.插入到末尾节点；d.插入到空链表中;   
   *   2)Parameter:
           *phead; 头指正；
           *fwd: 前向指针
           *bwd: 后向指针   
           *preview 插入节点的前驱节点；
           *pNode : 插入节点的后一个节点；
       3)双链表 需要 根节点, 保存两个指针
           a. root->pwd：指向最后一个节点； 第一个节点的 fwd = null; 这样才能从头后者末尾开始访问
           b. fwd 指向第一个节点； 
           c. pwd 指向最后一个节点；
       4) 链表通过画图，得到控制条件
           a.  先遍历找出插入点的位置： 
           a.  previous != pHead
           b.  pNode != Null 
   ```
   
   
   ```