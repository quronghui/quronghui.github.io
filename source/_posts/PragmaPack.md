---
layout: post
title: Pragma Pack()
date: 2019-08-02 21:00:20
categories: [Operate System]
tags:  
---

# Pragma Pack(n)

## 32位/64位的系统中, 各自的sizeof()是多少

1. 32位的寻址空间是2^32, 即32个bit，也就是4个字节; 64bit同理

2. **基本类型**没有变化: 包括int、char、short、double等，在32bit和64bit中没哟区别;

   + 64位相对于32位的提升，一个要素是在于地址的变化.

   + 在C++中，sizeof(空类或空结构体) = 1，在C语言中，sizeof(空结构体) = 0。

3. 地址空间的比较

   + 函数指针 void (*fun) : 4个 / 8个

   + **long double**  10/12  10/16  有效位10字节。32位为了对齐实际分配12字节；64位分配16字节

     

   ---------------------
   | 数据类型      | 同等类型: 给出占的bit | 32位 byte | 64位 byte | 备注                                                     |
   | ------------- | --------------------- | --------- | --------- | -------------------------------------------------------- |
   | char          | __int8_t              | 1         | 1         |                                                          |
   | unsigned char | __uint8_t             | 1         | 1         |                                                          |
   | bool          |                       | 1         | 1         |                                                          |
   | short int     | __int16_t             | 2         | 2         | unsigned short =  2bute                                  |
   | int           | __int32_t             | 4         | 4         |                                                          |
   | unsigned int  | __uint32_t            | 4         | 4         |                                                          |
   | float         |                       | 4         | 4         |                                                          |
   | double        |                       | 8         | 8         |                                                          |
   | **long**      |                       | 4         | 8         |                                                          |
   | **long int**  | **__int64_t**         | 8         | 8         | **同等类型**: 基本的数据类型, char , int ; 没哟double    |
   | long long     |                       | 8         | 8         |                                                          |
   | **指针**      |                       | 4         | 8         | (1)所有的指针类型; (2)函数指针                           |
   |               |                       |           |           |                                                          |
   |               |                       |           |           |                                                          |
   | long double   |                       | 10/12     | 10/16     | 有效位10字节。32位为了对齐实际分配12字节；64位分配16字节 |

## 数据类型间的混合运算, 最后的输出?

1. Char型与int型数据进行运算，就是把字符的ASCII码与整型数据进行运算
2. 若int型与float或double型数据进行运算，先将int型和float型转换为double型，然后进行运算，结果为double型

## 内存地址对齐 pragma pack(n)用法详解?

1. 什么是对齐?

   - 内存空间都是按照**byte**划分的;
   - **对齐**: 按照一定的**规则**在**地址空间**上排列, 而不是顺序的一个接一个的排放
     - 例如: 访问**特定变量**的时候经常在**特定的内存地址**访问
   
2. **为什么要对齐: ** 

   + 提高CPU访问数据的效率问题：CPU访问按照**字**进行访问；

     + ```
       int a;
       (1) 不按字节对齐；0x02-0x05;  需要访问两次，并将其组合；
       (2) 按照字节对其：0x00-0x03;	只需要访问一次；
       ```

   + 内存对齐基本上是透明的, 由编译器完成,  为了**性能和平台移植**等因素，编译器对数据结构进行了内存对齐。

###  pragma pack(n) 对齐规则

1. pragma 的理解?

   - #pragma的实现是与具体平台相关的。
   - 可以简单将其理解为该预处理指令是**开发者和编译器交互**的一个工具

2. #pragma pack(n)内存对齐规则?

   - pragma pack(n)中**n的值**

     ```
     vc6 中的编译选项有: Zp [1 / 2 / 4 / 8 / 16]
     (1 ) n==1:  地址空间的排列是顺序的, 不用补空位;
     (2)  #pragma pack()表示更改当前对齐系数为默认值: n==8
     ```

   - **地址空间对齐规则**：先内部对齐，在外部对齐；

     ```
     min (sizeof(mumber) , n);		// 取sizeof(mumber) 值, 和 n的整数倍 的最小值
     ```

     - (1)n==1, 不存在内存对其, 按照顺序存储就行;

     - (2) n > 1: 需要内存对齐;

       - **sizeof(mumber)** 值的计算 : 计算每一个成员的**起始地址**

       ```
       (1) 第一个成员member的其实地址空间为 0x00;
       (2) 下一个member起始地址位置:   地址空间的起始位置  %  sizeof(mumber) == 0; 
       (3) 不为0的话, 补空字节;
       (4) 按照这种规则计算出struct 的全部字节数;
       ```

       - **n的整数倍**

         sizeof(struct) 是n的整数倍, 不足则补空字节;

     - (3)**补足后才是最终的字节数**;

3. 对齐规则的文字总结

   + 对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍；
   + 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍；
   + 如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型。

4. 三个例子

   - #pragma pack( 4 )

   ```
   # pragma pack( 4 )
   struct A {
   	int a;   			  // a的起始地址 [ 0x00 % sizeof(int) ] ==  [0x00%4 ] =0;   a偏移地址为0x00~0x03;
   	char b;           // 由于紧跟a之后的地址，即0x04满足0x04%1=0，所以b存放在0x04地址空间
   	short c;          // 由于紧跟b之后的地址0x05%2 != 0，而0x06%2=0，因此c的存放起始地址为0x06，存放在0x06~0x07空间。
                     // 在b和c之间的0x05地址 则补空字节。
   };
   min( sizeof(A) , 4k) = min ( 8, 4k ) = 8;
   ```

   - #pragma pack( 4 ) : 只是**调整起始成员**

   ```
   struct B {
   	char b;      // 起始地址为0x00，由于满足0x00%1=0，所以b存放在0x00地址空间
   	int a;          // a的自身对齐值为4，由于紧跟b之后的地址0x01%4不是0，而0x04%4=0，因此c的起始地址	0x04，存								放在0x04~0x07空间。//  在b和a之间的0x01~0x03地址则补3个空字节。                 
   	short c;      // c的自身对齐值为2，由于紧跟a之后的地址0x08%2=0，因此c的存放起始地址为0x08, 0x08~0x09
   };
   min( sizeof(A), 4k ) = min( 10, 4k )  = 12;	// 此时不满足 n的整数倍, 需要补0 
   ```

   - #pragma pack(1)

   ```
   #pragma pack(1)
    
   struct fun{
   	int i;					// 0x00 - 0x03
   	double d;		// 0x04 - 0x011;		// 顺序存储, 这里不进行补齐
   	char c;				// 0x12
   };
   min( sizeof(fun), 1 ) = (13, 1) =13
   ```


### 结构体和联合体的内存对齐

1. 联合体的定义:

   + **内存占用**: 使几个不同类型的变量**共占**一段内存 (相互覆盖 )
     + 每次存放一种:  共同体每次只能存放一种
     + 相互覆盖: 共同体变量中起作用的成员是**最后一次**存放的成员，在存入新的成员后原有的成员失去了作用！
   + **联合体长度**: 编译程序自动地产生一个变量，其长度为联合中**最大的变量长度**。
   + 用途: 

2. 结构体

   1. 结构体的定义: 
      + 把不同类型的数据**组合**成一个整体;
   2. 内存占用:
      + 结构体变量所占内存长度是各成员占的内存长度的**总和**;
      + 需要进行内存对齐;

3. 联合体和结构体共同使用:

   ```
   union myun
   {
        struct { int x; int y; int z; }u;
        int k;
   }a;
   int main()
   {
        a.u.x =4;
        a.u.y =5;
        a.u.z =6;
        a.k = 0;
        printf("%d %d %d\n",a.u.x,a.u.y,a.u.z);
        return 0;
   }
   // 输出结果: 0, 5, 6
   ```

   + union类型是共享内存:  myun这个结构就包含**u这个结构体**
   + 在内存中:  就是*x*的位置放置*4*，*y*的位置放置*5*，*z*的位置放置*6*
     + 现在对*k*赋值:  对*k*的赋值因为是*union*，要共享内存，所以从*union*的**首地址**开始放置
     + 首地址开始的位置其实是*x*的位置: 这样原来内存中*x*的位置就被*k*所赋的值代替了，就变为*0*了

4. [大疆的题目: 结构体和联合体的内存字节对齐计算?](https://github.com/quronghui/DataStructAndAlogrithmCode/blob/master/CompanyWrite/1_Dji/sizeofStructUnion.c)

### 结构体和联合体相互定义

```
// (1)struct 和 union结构体，计算sizeof占的空间大小
// 联合体定义变量时，首地址的对齐：取该联合体的最大值的一个元素；

#include <iostream>
using namespace std;

#pragma pack(4)

// 联合体所占的地址空间大小；
typedef union size MAX;
union size{
    u_int32_t   array[5];   // sizeof()= 4*5 =  20
    u_int8_t p;             // sizeof()= 1
};

// 结合结构体
// 联合体定义变量时，首地址的对齐：取该联合体的最大值的一个元素；
struct space{
    u_int32_t value;        // 0x00-0x03
    u_int8_t j;             // 0x04 (中间补空字节)
    MAX i;                  // 0x08-0x27
};

int main()
{
    int union_size = sizeof(union size);
    int struct_size = sizeof(struct space);
    cout << "union_size  " <<union_size << endl;
    cout << "struct_size  " <<struct_size << endl;
    return 0;
}

```

