---
layout: post
title: linux用户和内核
date: 2019-08-02 21:18:12
categories: [Operate System]
tags: linux
---

#  linux用户和内核

+ 在Linux机器上，CPU要么处于受信任的内核模式，要么处于受限制的用户模式

| 区别         | 用户模式                                           | 内核模式                                                |
| ------------ | -------------------------------------------------- | ------------------------------------------------------- |
| linux系统下  | CPU要么处于受限的用户模式                          | CPU要么处于受信任的内核模式                             |
| 进程         | 用户进程                                           | 内核进程                                                |
| 访问所有空间 | 系统调用向设备驱动程序或其他内核模式的代码发出请求 | 无限制地访问<br />所有处理器指令集以及全部内存和I/O空间 |
| 地址空间     | **允许发生缺页**                                   | 内核模式的代码则不允许                                  |



## linux用户和内核之间的关系

1. Linux的**用户态与内核态 **定义?
   - Intel的X86架构的CPU提供了**0到3四个特权级**: Linux操作系统中则主要采用了**0(内核)**和**3(用户)**两个特权级
   - 进程寻址空间0~4G , 用户态只能访问0~3G，只有进入**内核态**才能访问3G~4G  
   
2. 用户态和内核态区别？
   
   + 用户态用printf, 内核态用printk
   + 用户态每个应用程序空间是虚拟的，相对独立的；内核态中却不是独立的，内存是被**共享**的。
   
3. Linux的**用户态与内核态 **如何切换的?

   - **系统调用**:
     - 用户态的进程通过系统调用申请使用操作系统提供的**系统调用服务例程**来处理任务
     - **机制:** 操作系统为用户特别开发的一个中断机制来实现的，即软中断
   - **内存产生异常时**
     - 如缺页异常
   - **外设产生中断**
     - 比如硬盘读写操作的完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。   

4. 传统的方法无法用于实现用户态和内核态通信的原因？

   {% asset_img tradition_ways.png %}

## Linux的用户态与内核态的通信方式？

1. 使用API接口

   

   | API接口                              | 含义                                                         |
   | ------------------------------------ | ------------------------------------------------------------ |
   | get_user(x，ptr)                     | 在**内核**中被调用：获取用户空间指定地址的数值并保存到内核变量x中 |
   | put_user(x，ptr)                     | 在**内核**中被调用：将内核空间的变量x的数值保存到到用户空间指定地址处。 |
   | Copy_from_user()<br />copy_to_user() | 主要应用于**设备驱动**读写函数中，通过系统调用触发           |

   

2. 使用内核的系统调用?

   - Linux下内核空间与用户空间进行通信的方式主要有syscall（system call）、/proc、ioctl和netlink

   - syscall（system call）
     - Linux内核中设置了一组用于**实现各种系统功能**的子程序
     - 用户可以通过调用**系统调用接口（SCI）**, 访问linux内核的数据和函数
     
   - /proc 
     - 是虚拟文件系统，是**Linux内核信息的抽象文件接口**, 大量内核中的信息以及可调参数都被作为常规**文件映射**到一个**目录树中**
     - **echo或cat**这样的文件操作命令对系统信息进行查取
     
   - netlink：用户态应用使用标准的**socket API**就可以使用 netlink 提供的强大功能；

     + 使用自定义一种协议完成数据交换，不需要添加一个文件等。2.可以支持多点传送。3.支持内核先发起会话。4.异步通信，支持缓存机制

     + 内核空间对netlink的使用：主要是create函数

       ```
       netlink_kernel_create();	//内核创建；
       ```

   - ioctl：函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数**控制设备的I/O通道**。

3. 使用mmap系统调用

   + 将内核空间的地址**映射**到用户空间

4. 信号：从内核空间向进程发送信号。

   + 这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应进程。

## 内核空间的划分？

1. 虚拟地址

   + 即逻辑地址，是指由程序产生的与**段**相关的**偏移地址**部分

2. 物理地址 (physical address): 放在寻址总线上的地址。

   +  物理地址一般与CPU有关系，是给CPU指令使用的
   + 总线地址主要是给设备使用的，是设备中的一些内存资源

3. 高端内存

   + 地址空间大于1G的内存区域

   {% asset_img memory.png %}