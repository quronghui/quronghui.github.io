---
layout: post
title: uC/OS-III
date: 2019-08-19 18:18:12
categories: [Operate System]
tags: uC-OS-III
---

# 嵌入式实时操作系统

## 实时系统 和 实时内核

1. 实时系统的概念?
   + 系统要求: 对**任务** *处理结果*的**正确性** 和 *处理过程*的**实时性** 都有严格要求的系统.
   + 硬实时和软实时系统的区别: 
     + 对处理过程超时及超时带来的后果的**容忍度**;
     + 硬实时: 不允许处理过程超时
2. 前后台系统的分类
   + 前台结构(**中断级**): **中断服务程序**(ISR)用于处理系统的**异步事件**;
   + 后台结构(**任务级**): **应用程序**是一个**无限的循环**, 循环中调用相应的函数完成相应的操作;
   + 任务的响应延迟: 应用程序**循环**到该任务时, 花费的时间;  
3. RTOS(real-time- Operating system) 系统和内核的区别?
   + 实时系统: 内核 + 高层系统服务(文件系统, 协议栈)

### 实时内核(uC/OS-III)

1. uC/OS-III 定义?
   + 定义: 是一个可裁剪, 可固化, 可剥夺的**多任务内核**, 管理的任务数目不受限制;
   + 本质: 实时内核(用于管理的软件代码)
2. **实时内核(uC/OS-III )的作用**?
   + 作用: 负责**管理**这些任务的调度, 使得**CPU**在多个任务之间进行**切换**;
     + 任何时刻, 单个CPU只能执行一个任务;
   + 多任务: 系统功能被分成多个任务, 每个任务(线程)完成一个功能;
   + 可剥夺型内核: 
     + 在任何时刻都可以发生**任务调度**, 任务调度使得CPU总是运行处于**就绪状态**并且**最高优先级**的任务;
   + 多任务数目受限 : 受限于RAM的大小;
3. uC/OS-III 的特性
   + 极短的关中断时间: 通过锁定内核调度的方式, 不是通过关中断方式保护**临界段**, 使得关闭中断时间降到最低;
   + **确定性**: 中断响应时间确定;
   + 出错检验:  err = OS_ERR_NONE
   + 防止死锁: 通过超时检测机制;
   + 时钟节拍处理: 通过时钟节拍进行处理;
   + 中断服务程序: 函数内部不能有**阻塞**(等待), 中断处理的时间总是很短;
4. 本书命名规则
   + 以"OS_"开头
   + 调试工具: uC/Probe

### uC/OS-III 软硬件结构

1. 硬件结构

   + PCU + 定时器 + 中断控制器

   + 通用异步收发器(UART) + ADC + 以太网控制器;

2. 软件结构

   + 应用程序 + 相关代码 ...

## uC/OS-III 代码描述

### 应用程序

1. 应用程序完成过程?

   + 用户调用uC/OS-III提供的一系列**函数**(任务)完成相应的功能;
   + 函数作用: 管理信号量/消息队列/互斥信号量;

2. 每个任务(线程)?

   + 在RTOS中, 任务也称之为线程;
   + 每个任务多有属于自己的**栈**;

3. 单任务的应用程序执行过程? 

   + 1)**启动关中断**:  启动代码引导CPU, 从main()函数开始执行; 

   + 关闭中断: 保证系统启动期间**中断关闭**

     ```
     BSP_IntDisAll();		// 关闭所有中断
     ```

   + 2)**初始化内核**,创建任务: 初始化内部变量和数据结构, 创建2-5个任务(至少两个)

     ```
     OS_Init(&err);	//   先初始化, 才能使用
     ```

     + 空闲任务: OS_IdleTask()
       + 在其他任务不就绪时, 就运行空闲任务, 为了保证CPU处于运行状态;
     + 时钟节拍任务: 
       + 负责时间管理;

   + 3) 创建任务

     ```
     OS_TaskCreate();	// 创建任务, 先创建在使用
     ```

     + 为每个任务分配: TCB + 堆栈 + 优先级 + 其他参数;
     + 只能内核进行访问, 应用程序不能访问;

   + 4) 执行任务

     ```
     OS_Stat();	
     ```

   + 最后: 

     ```
     应用程序中的每一个任务都必须调用一个可以引发任务**等待某事件**的函数;
     ```

4. 多任务应用程序创建执行过程?

   + 存在临界区共享问题;

### 临界区代码保护

1. 临界区代码的保护方式?

   + **关中断: ** ISR 和任务 都能访问的代码;

   + **调度器上锁** : 仅任务能访问的代码;
   + 参数配置起效果

   ```
   os_cfg.h
   	OS_CFG_ISR_POST_DEFERRED_EN == 0 ;	// 使用关中断方式
   	OS_CFG_ISR_POST_DEFERRED_EN == 1 ;	// 使用调度器上锁的方式
   ```

2. 测量中断关闭时间

   + 设置寄存器

     ```
     CPU_CFG_INT_DIS_MESA_EN == 1;		// 打开后,才能测量中断时间
     ```

   + 测量两个时间: 总的关闭中断时间 和 每个任务中断关闭时间;

   + 计算: 从中断关闭时开始计时, 到重新打开中断;

   + 单位: 与系统时间戳CPU_TS的单位一致

3. 测量调度器上锁时间, 类似

   + 设置寄存器

   ```
   CPU_CFG_SCHED_LOCK_TIME_MESA_EN == 1;		// 打开后,才能测量调度器锁定时间
   ```

## 任务的介绍

1. 多任务等待单个内核对象?

   + 四个内核对象

2. 多任务同时等待多个内核对象?

   + 只允许多信号量 和 多个消息队列; 不允许同时等待事件标志组和互斥型信号量;

     ```
     OSPendMulti()	// 一旦有对象被发送, 那么OSPendMulti立即返回;
     ```

### 任务管理

1. 任务的概念描述?

   + 定义: 是一个线程, 也就是一个简单的程序;
   + 分类: 运行至完成型; 无限循环型;

2. 任务和C函数的区别?

   + 任务执行过程: 是顺序的无限循环;
   + **任务执行完后: 不允许返回;**
   + 任务和c函数: 通过使用参数传递, 实现函数的可重入性;

3. **任务管理的概念**?

   + 多任务的调度, 和CPU使用权的切换

4. 任务**优先级**的分配?

   + 优先级的值 = 任务索引下标
   + 优先级: [0, N-1]
     + 0 : 优先级最高, 留给ISR
     + [1, N-1] : 分配给不同的任务
   + 允许: 多任务拥有统一由县级

5. 每个任务分配的**堆栈空间**?

   + 分配但不释放:
     + 动态分配堆栈空间, 但是不允许释放, 否则会存在空间碎片;
   + 堆栈溢出检测:
     + OS_TCB中的成员 .StkLimitPtr 指针: 指向分配空间的位置;
     + 栈空间的阈值:  无限接近MyTaskStk[0]
   + 栈空间分配的大小
     + 计算值 * 安全系数(1.5/2)

6. **任务的5种状态?**

   + **休眠态**
     + 代码已经写入代码空间, 但是uC/OS-III 不知道它的存在;
     + 任务删除: 并不是删除代码, 而是使其无法获得CPU使用权
   + 就绪态
     + 任务**准备运行**时, 就会进入这个状态;
     + 就绪表: 用于对任务优先级进行排序;
   + 运行态
     + 优先级最高的任务进入;
     + 单核CPU: 任何时刻只有一个任务进入该状态;
   + 等待态
     + 当一个任务所等待的事件没有发生时, 进入等待
     + 等待时: 不消耗CPU事件, 会调用下一个优先级的任务进行执行;
   + 中断服务态
     + 允许CPU中断时, 当前任务会被挂起, CPU开始执行ISR

7. 处于uC/OS-III 内部任务的8种状态?

   + 就绪: 任务实现其功能的唯一途径;
   + 延时: 任务可以让自己延时等待一段时间
   + 等待: 任务等待某个事件的发生, 不发生就一直等待;
   + 带超时检测的等待: 等待超时时才能运行
   + 被挂起: 运行中的任务被挂起, 在恢复前是不能获得CPU的使用权的
     + 恢复: 其他任务来恢复该任务的运行状态
   + 等待且被挂起: 在等待状态被挂起
     + 恢复: 当等待的事件发生, 并且挂起状态取消, 任务才能运行
   + 带超时检测的等待且被挂起:

8. **系统内部(的五个任务)?**

   + **空闲任务**(必须创建)

     ```
     OS_IdleTask() , os_core.c;		// 当其他任务都处于未就绪状态时, 空闲任务运行
     ```

     + 空闲任务运行时, 两个计数器不断递增
       + OSIdleTaskCtr: 表示空闲任务的活跃度
       + OSStatTaskCtr: 统计程序运行是CPU的利用情况
     + 优先级最低: 为(n-1)

   + **时钟节拍任务**(必须创建)

     ```
     OS_TickTask(), os_tick.c;		// 实时操作系统的时钟源
     ```

     + 用于跟踪任务延时和任务等待超时;
     + 硬件定时器: 10-1000Hz

   + 统计任务

     ```
     OS_StatTask(), os_stat.c;	// 可以再系统运行时, 统计CPU的利用率
     ```

   + 定时器任务

     ```
     OS_TmrTask(), os_tmr.c
     ```

     + 定时器是一个递减的计数器, 当计数器减为0时, 就会做一个操作
     + 操作: 回调函数

   + 中断服务管理任务

     ```
     OS_InitQTask(), os_int.c
     ```

     + 禁止或者打开中断, 给调度器上锁或者解锁;
     + 优先级最高, 为0;
     + 不允许存在阻塞;

9. CPU实际利用率计算?
   $$
   CPU = 100 - (100 * OSStatTaskCtr )/OSStatTaskCtrMax
   $$

   + 当OSStatTaskCtr计数到最大值时

     ```
     OSStatTaskCtr = [0, 10 000 000];
     实际的最大值: 7500 000;
     ```

   + 应用程序的运行会花费 : CPU = 25% 的时间;

### 任务就绪表

1. 任务就绪表由两部分组成:

   + 就绪任务优先级位映射表

     ```
     OSPrioTbl[  ];   // priority , 用于标记哪个优先级下有任务就绪
     ```

   + 就绪任务列表

     ```
     OSRdyList[  ];	// 记录每一个优先级下所有就绪的任务
     ```

2. 查找就绪任务

   + 优先级 == 索引号
   + 顺序查找就绪任务优先级位映射表, 直到遇到第一个非零位
   + 至少会找到一个就绪任务而结束;  -- 空闲任务列表

### 任务调度

1. 任务调度的概念:

   + 负责确定下一个要执行的任务; 
   + 可剥夺型:
     +  当一个事件发生(每个任务都会等待事件发生);  **也就是任务将信号量释放或者发布消息时;**
     + 并且使得更高优先级的任务就绪时, CPU的控制权就会被剥夺, 转交给更高优先级的任务

2. 同一优先级的任务执行

   + 采用时间片轮转的方式执行;
   + 时间片的长度 = n * 时钟节拍

3. **uC/OS-III 存在两个调度器**

   + 任务级调度: 

     ```
   	 OSSched()  -- > OSCtxSw()		// 任务调度函数入口 -- > 任务切换功能函数
     ```
   
   + ISR中断服务程序调度:
   
     ```
      OSIntExit() -- > OSIntCtxSw()	// ISR调度函数入口 -- > 中断任务切换功能函数;
     ```

### 任务切换

1. 任务切换

   + 过程: **保存**当前任务现场(CPU相关寄存器)到当前任务的堆栈中, **恢复**新的优先级最高的任务现场;
   + 时间: 取决于多少寄存器需要保护和恢复;

2. 虚构CPU的15个寄存器 + 状态寄存器

   + R0-R13 : 正常的寄存器
   + R14: 任务级堆栈指针(TSP) ; R14' : 中断堆栈指针(ISP)
     + SP指针指向最后一个入栈的寄存器R13(栈顶)
     + TSP 和 ISP 存在于不同的内存区域;
   + R15: 程序计数器(PC)
     + PC和SR 先进入堆栈中
   + SR:  状态寄存器

3. 具体的切换过程

   + **保存:** 每个任务都有一套堆栈寄存器, 任务运行在cpu的堆栈寄存器中, 当任务切换时, 将cpu的寄存器值保存在当前任务的堆栈中
   + **恢复: ** 在返回时, 同时恢复CP和SR
   + 两个切换函数, 对应任务级和ISR级

   {% asset_img osctxsw.png %}

4. 注意: OSIntCtxSw()

   + 仅需要执行任务切换的后半部分工作, 因为uC/OS-III 进入终端服务程序时, CPU寄存器已经得到保存

### 中断管理

+ 多个中断发生时, 应该怎么处理;

1. 实时多任务内核的重要指标: 中断关闭总时间

   + 定义: 内核在运行临界区代码前**关闭中断**, 在临界区代码完成后**重新打开中断**;
   + 这段时间: 中断关闭的总时间

2. 中断中其他时间定义 

   + **时钟(系统)节拍**: 只有器存在, 才能测量时间; 
   + 中断延迟时间: 最大中断关闭时间;
   + 中断响应时间: 中断被识别 -- > ISR中断代码开始运行的时间;
   + 中断恢复时间: ISR代码运行完毕 -- > 下一个任务代码开始运行的时间;
   + 任务等待时间: 从中断发生 -- > 任务代码重新开始执行的时间;

3. 中断控制器的作用?

   + 作用: 处理多个中断请求, 为其**设置**优先级, **记录**哪些中断还未处理, 并将最高优先级的中断ISR的**地址传递**给CPU;
   + 优先级定义:
     +  16个中断优先级[15,0], 优先级最高是15
     + 中断优先级 > 任务优先级

4. 中断服务程序ISR?

   + 所有中断源共用同一个ISR:
     + 缺点: 必须对一个中断请求源处理**全部完成**, 才可能处理新发生的**更高中断级**别请求;
     + 造成所有中断延迟时间最长;
   + 每个中断源拥有单独的ISR;
     + 根据中断向量表, 直接跳转到对应的ISR
     + 允许 : 中断嵌套;

5. 直接发布和延时发布?

   + 针对: 从**中断中**发布消息或者信号; (每个任务都会等待一个事件发生)

   + 选择: 取决于中断响应时间, 任务响应时间的要求;

   + 直接发布:

     + 采用关中断的方式, 保护临界区代码, 防止ISR访问临界区代码;

       {% asset_img ISR_direct.png %}

   + 延时发布:

     + 采用给调度器上锁的方式, 保护临界区代码;
     + 增加: 中断队列

   ### 任务挂起表

   1. 任务挂起表的作用?
      + 当一个任务等待**内核对象的发生时**, 将该任务放在挂起表(等待表)中;
      + 内核对象: 信号量 / 互斥信号量 / 事件标志组 / 消息队列
      + 任务挂起表: 跟踪正在等待内核对象的任务;
   2. 任务挂起表组成
      + 由OS_PEND_LIST类型的结构体组成, 并且进一步封装到另外一个数据类型OS_PEND_OBJ;
   3. 任务如何链接任务挂起表?
      + 表中的任务: 不直接链接到任务挂起表; 通过一个中间数据结构OS_PEND_DATA进行链接;
      + 将等待内核对象的任务放入挂起表的同时, 将该数据结构放到该任务的栈空间中;

## uC/OS-III 的管理

### 时间管理

1. uC/OS-III提供一种延时服务?

   + 任务可以将自己挂起, 延时一段指定时间, 当指定时间结束后在运行;

2. 延时的时间长度指定方式

   + 时钟(系统)节拍
   + 小时/分/秒/毫秒

3. 时间接口函数

   {% asset_img OS_tiem.jpg %}

### 定时器管理

1. 定时器的本质?

   + 定时器是一个**递减计数器**;
   + 当其值递减到零时, 自定义的**回调函数**就会立即被调用;
   + 回调函数 : 在**定时器任务**内完成, 此时调度器是上锁的, 回调函数不允许任何阻塞调用;

2. 定时器创建?

   + 定时器需要先创建后使用

     ```
     OSTmrCreate();		// 创建定时器并指定其运行模式
     ```

   + 创建以后: 启动(重启) , 停止 任意次数;

     ```
     OSTmrStart();	// 启动或者重启定时器
     ```

3. 定时器运行的第三种模式?

   + 单次运行模式

     + dly(节拍数) > 0; period(周期) == 0;
     + 计数器从dly开始, 递减到0时, 就调用回调函数,之后就不在进行定时
     + 除非使用OSTmrStart(), 启动或者重启定时器

   + 周期定时器(无初始延时)

     + dly(节拍数)==  0; period(周期) > 0;
     + 计数器递减到0时, 重新设置初值为period, 重新计数

   + 周期定时器(有初始延时)

     + dly(节拍数) > 0; period(周期) > 0;
     + 第一个周期有dly设置, 后面的周期由period设置;

     {% asset_img time_dly.jpg %}

4. 定时器的状态?

   {% asset_img tiem_state.jpg %}

### 共享资源的管理

1. 共享资源好处和弊端?
   + 共享内存能让任务之间的**信息交互**变得简单;
   + 但造成了任务对数据的**独占性**造成了影响;
2. 共享资源的种类?
   + 不同任务处于同一寻址空间时, 就会造成数据共享问题;
   + 种类: 变量(static and 全局), 数据结构体, RAM中的表格, I/O设备中的寄存器;
3. 最常用的独占资源和创建临界区的方法?
   + 关中断;
   + 禁止任务调度;
   + 使用信号量
   + 使用互斥型信号量;

#### 总结

1. 任务等待某事件发生的方式?
   + 等待资源的任务: 执行等待, 或者挂起操作;
   + 超时等待
     + time > 0: 只愿意在一段时间内等待时间; 事件不发生, 任务进入就绪状态等待运行, 并且任务返回等待超时错误
     + time = 0: 任务一直处于等待事件的状态;
   + 阻塞/非阻塞
     + **阻塞:  等同于 -- 任务会一直等待事件的发生; **
       + 调度器就会介入, CPU会执行另外一个优先级高的就绪任务;
     + 非阻塞: 任务在就绪状态, 事件未发生, 则返回错误;
2. 解决死锁问题?
   + 任务先得到全部资源, 在做下一步工作
   + 任务用相同的顺序盛情多个资源;(不用全部获取)
   + 在调用请求信号量的函数时, 设置超时时间;

#### 关中断/开中断

1. 使用条件?
   + 共享资源访问的速度很快, 小于中断关闭的时间;
   + 关闭所有的中断(接收不到其他的中断请求)
2. 弊端
   + 影响系统的中断延迟时间; 

#### 给调度器上锁

1. 使用条件?
   + 任务不需要和ISR共享资源;
   + 原因: 虽然给调度器上锁, 但是此时中断一旦发生, 即便在**临界区**内, 该任务也会被挂起, 执行ISR程序; 但是虽然造成更高优先级任务就绪, 但是此时处于上锁状态; 中断返回后, 仍然执行挂起任务;
2. 调度器上锁时: 禁止用户使用阻塞型调用;

#### 信号量 (多用于同步)

1. 信号量使用的条件?

   + 只有任务级才能使用, ISR不能使用;
   + 先创建才能使用;
   + 引入信号量: 不会增加系统的中断延迟;

2. 信号量分类

   + 二值信号量: 1/0
   + 计数型信号量: 初始化一个信号量的值

3. 信号量导致一个问题 --  任务级反转?

   + H的优先级最高, 等待L发布一个事件: 但是此时最低优先级L占用共享资源;
   + 同时中等优先级的M等待的事件发生: 此时剥夺L的CPU使用权, 运行完后返回给L;
   + 最后, L运行完后, 释放信号给H, 此时H运行;
   + 结果: 最高优先级H, 最后才运行;

   {% asset_img TASK_reserve.jpg %}

#### 互斥型信号量(MUTEX)

1. MUTEX使用的条件?
   + 只有任务级才能使用, ISR不能使用;
   + 对共享资源的访问, 有**截止时间限制**的任务;
   + 解决: 任务反转的问题;
2. MUTEX如何解决 任务反转的问题?
   + 优先级集成的方式;
   + 一旦出现高优先的任务H访问共享资源, 占有该资源的任务优先级将被提升到与H一样的优先级;
   + 完成访问后, 会恢复到原先优先级

## 任务同步

1. 任务同步的概念?
   + 任务 : 与中断服务程序(ISR) 或者 其他任务进行同步;
   + 同步概念: 当ISR执行时, 可以通过给任务发信号, 告诉该任务等待的事件发生; ISR完成后退出, 调度程序根据信号和优先级完成调度;
   + 任务不能同步ISR; (ISR 不能阻塞,且时间要短)
2. 任务同步方式?
   + ISR和任务可以通过三种方式: 向一个或多个任务发信号
   + 信号量 / 任务信号量 / 事件标志组;
3. 信号量和任务信号量 区别?
   + 信号量: 需要声明一个外部信号量对象;
   + 信号任务量: 
     + 创建任务时自动创建, 适用于给单个任务发信号;
     + 信号任务量服务函数的速度 > 信号量的服务函数;

### 信号量

1. 信号量的API?

   + 先创建才能使用;

   {% asset_img SIGNAL.png %}

2. 单向同步:

   + 例子: I/O操作
   + 任务 -- > 同步任务 ;  ISR -- > 同步任务

   {% asset_img 单向同步.png %}

3. 信用记录

   + 信号量可以被发布多次;
   + 当任务优先级位于就绪状态是, 该任务会被连续执行多次, 执行次数与发布次数相同;

4. 多个任务等待同一个信号量

   + 广播: 使得等待同一信号的任务, 否处于就绪状态, 执行优先级最高的任务;

### 任务信号量

1. 任务信号量的使用条件?

   + 任务信号量: 内嵌信号量, 创建任务时, 自动被创建;
   + **明确知道**该给哪个任务发信号;

2. 任务信号量的API

   {% asset_img TASK_SEM.png %}

   + OS_TaskSemPost() : 将目地任务控制块的地址作为其参数;

3. 双向同步

   + 双向同步, 只能用于任务之间, 不能用于ISR之间

   {% asset_img 双向任务.png %}

### 事件标志组

1. 事件标志组的使用条件?

   + 当任务需要与多个事件同时发生同步时, 使用事件标志组 ;
   + 同步机制: 或同步, 与同步;

2. 使用事件标志时?

   + 所有满足等待条件的任务都会进入就绪状态; (类似于广播)
   + 只有任务: 才能创建和删除flag;
   + 任务和ISR: 都能发布标志

3. 事件标志组API接口?

   {% asset_img flag.png %}

## 消息传递

1.  消息传递的作用?
   + 当一个任务或者ISR: 和另外一个任务**交流消息**时,;
   + 信息传递称之为: 任务间通信;
   + 任务在等待消息时: 不占用CPU处理时间;
2. 任务间信息传递的方式?
   + 全局变量: 任务 与 ISR之间通信只能使用
     + 全局变量的值: 需要进行查询才能得到
   + 发布消息: 
     + 使用消息队列间接发布;
     + 直接发布给任务

### 消息的发布

1. 消息的本质: 指向消息(数据)的指针;
2. 消息包含几个部分:
   + 指向数据的指针, 表明数据长度的变量, 记录消息发布时刻的时间戳;
   + 消息发布: 使用引用传递, 不是值传递;(不发生值的拷贝)
3. 消息必须保持**可见性**?
   + 可见性: 消息变量必须在接收消息任务代码范围内有效;
   + 指针传递消息, 必须保持数据不能被改变;
4. 消息的创建
   + 消息通过OS_MSG结构体发布, uC/OS-III 维护着一个OS_MSG消息缓冲池;
   + 发布消息时: 通过uC/OS-III从空闲的OS_MSG消息缓冲池中获取可用的OS_MSG;

### 消息队列的种类?

1. 外部消息队列:
   + 需要进行创建才能使用
   + 适用于: 多任务都需要等待一个消息队列中的消息时, 分配一个OS_Q对象;
2. 任务内建消息队列
   + 用户明确: 消息目的接受任务
   + 适用于: 单任务等待消息

### 消息发布的例子

1. 双向同步
   + 需要使用*两个***消息队列**(外部/内建)进行同步;
   + 每个消息队列只能容忍一则消息
2. 流量控制
   + 生产者和消费者模型: 只有生产者产生数据, 消费者才能消费数据;
   + 流量控制: 数据大小进行控制;
3. 客户端与服务端消息传递

## 存储管理

1. 存储空间的动态分配?

   + 使用malloc() 和 free() 动态分配和释放存储空间
   + 缺陷: 产生存储碎片, 函数执行时间无法确定;

2. uC/OS-III 提供一种替代函数的方法?

   + 将连续的大块存储空间进行**分区**管理;
   + 每个分区中包含整数个大小相同的**存储快**;
   + 只使用malloc() 进行分配, 不释放空间;

3. 应用程序申请的空间: 得到不同分区中, 不同大小的存储快;

   ```
   OSMem???()
   ```

## uC/OS-III 的移植

