---
layout: post
title: priority_queue
date: 2019-05-19 17:19:29
categories: 
- [data_struct_algorithm]
tags: priority_queue
---

# priority queue

## Introduction

1. 优先队列：
   + 具有队列的性质，进行insert  and delete;
   + 此时的delete 要删除最小值（某些元素具有优先级）
   + 如何让队列实现优先级

2. 优先队列的一些实现方式

   + 链表实现优先队列：

     1）插入是无序：insert -- O(1); delete -- O(N)，进行遍历

     2）插入是有序：insert -- O(N); delete -- O（1）

   + 二叉树实现

     1）平均时间 O(log N);

     2) 删除最小值：的时间不是平均时间

   + 上面两种方式的运行时间太长

## 二叉堆

+ 当**堆（heap）**不加任何修饰词使用时，就是值得该数据结构

### 二叉堆的性质

1. 堆：是完全二叉树

   + **性质** 任意节点的关键字小于所有后裔的关键字

   1）底层：元素依次从左到右填入；

   2）高为h 的完全二叉树节点数：2^h --- (2^(h+1) -1)

   3) 完全二叉树的高是logN

   4) 完全二叉树：用数组，不用指针

   5) 0位置的数组不存储数据

2. 堆序性质

   + 任意节点的关键字小于它所有后裔的关键字；

### 堆的操作

1. insert: 

   1）完全二叉树的插入：从左边依次插入，所以不用考虑顺序；

   2）上滤策略：插入 i 节点后，破坏了堆序性质：将其父节点的关键字交换到 i位置；原来i节点的关键字放到父节点 （i/2）的位置；

   3）插入的关键字最小的话，i将是1；我们在数组的0位置放置一条哑信息（放一个很小的值 = 小于等于堆中的任意值）

   4）这样插入和移动的时间高达 O(logN)

2. delete_min

   1）堆序性质：最小值应该是根节点的值；

   2）下滤策略：

   	+ 删除根节点的值后，一步步的从根节点的儿子节点选出相对较小的关键字，放入root中；
   + 将最后的元素，上升到被提到根节点的位置;
   + 平衡树，满足堆序性质

3. Other

   + decreaseKey
     + 降低位置P处关键字的值
     + 破坏序的平衡：采用上滤策略
   + increaseKey
     + 增加位置P处关键字的值
     + 破坏序的平衡：采用下滤策略
   + 构建堆：
     + 将N个节点以任意顺序放入树中，保持结构特性；
     + 在调整成一棵有堆序的树

4. 如果对一棵乱序的树，进行堆序化

   + 最大的虚线条数：计算堆中所有节点的高度和，等于N的最大上限 O(N)

     1）任意节点的高度 = 它到叶子节点的最大路径值；

     2）理想二叉树：节点数 = 2 ^ (height +1)   --  1

     3）理想二叉树：节点高度和 = 2 ^ (height +1)   --  (height +1)

   + 我们此时算的最大虚线条数：要调整的次数

     + 通过理想二叉树 ，计算出最大上限

## 堆的应用

1. 问题描述对于N个元素，读出第k个最小值：

   + 1）N个元素得有序；

   + 2）find 第k个最小值；

2.  algorithm  1A 

   + 1) double for cycle；

   + 2）排序时间：O(N^2)

3. algorithm 2A 

   + 1) 先取k个元素组成一个排序数组array_order；

   + 2）每次去一个元素和array_order进行比较插入；

   + 3)中位数的时间界限 = ：O(N^2)

4. algorithm 6A  -- 堆排序（不用指针）

   1) 构造堆最坏情况：O(N);

   2) 每次的delete_min：O(log N);

   3) k 次删除，总时间：O(N + k logN)

   4) K = N/2; 运行时间：O(N * log N)

   找出中位数的时间界限 = (N logN)

## d-堆

1. d-堆：是二叉堆，只是所有节点都由d个儿子

## 左式堆

### 左式堆性质

1. 合并merge：需要把一个数组拷贝到另外一个数组中，需要花费O(N)时间；

   + 合并操作需要的数据结构：需要使用指针
   + 左式堆：需要用到指针

2. 左式堆性质

   1）左式堆：也是二叉树，左式堆不是理想平衡的。

   2）节点X的零路径长Npl：从X到一个没有两个儿子的节点的最短路径长。

   3）**任意节点X，左儿子的Npl >= 右儿子的Npl**，不满足便需要调节

3. 1)树偏向左增加深度，存在有节点形成的长路径构成的树，更有益于合并操作。

   2）节点个数：右路劲上有r节点，左式树至少有（2^r  - 1）个

### 左式堆的操作

1. 左式堆：实现堆之间的合并

   1）左式堆和二叉堆的insert不兼容的；

   2）二叉堆没有指针，插入后没有返回值

## 斜堆

1. 斜堆：具有堆序的二叉树，只是不存在树的结构限制；

2. 斜堆 merge：

   + 不需要附接空间保存路劲长度
   + 也不需要测试确定何时交换儿子

   + 没有Npl零路径的限制

## 二项队列

### 定义

1. 二项队列：

   + 不是一棵堆序树，而是堆序树的集合，称为森林

2. 二项队列的实现

   + k 是二项队列的高度，包含的堆序树集合 = { B(0), B(1),……B(k-1) }

   + **性质** : 每一个高度至多存在一颗二项树，超过就需要merge
   + **实现方式：**B(k)高度的二项树构成：将B(k-1)的树全部附接到B(k-1)的根节点；

### 二项队列的操作

1. insert 插入一个节点后
   + 没有打破 **性质**，则保留为B(0)的堆序树；
   + 打破了**性质**，进行合并
2. delete_min
   + 按照堆序树：进行递归删除

## Difference

| priority queue | 性质                                                         | 操作                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 二叉堆         | 1) 完全二叉树的性质：<br />2) child 依次从左到右填满<br />3) 通过数组存储，存储为树的形式； | 1) insert: 进行堆序的平衡<br />2）delete_min: 删除根节点，下滤策略平衡 |
| d-堆           | 本质是二叉堆，<br />只是所有节点都由d个儿子                  | 同上                                                         |
| 左式堆         | 1)用于堆的合并merge；<br />2）任意节点X，左儿子的Npl >= 右儿子的Npl<br />3）需要指针进行 | 1）merge：根据性质----确定何时交换儿子                       |
| 斜堆           | 1）用于堆的合并merge；<br />2）去除左式堆 Npl 的限制         |                                                              |
| 二项队列       | 1）用于堆树的merge，森林；<br />2）任意高度至多包含一棵二项树； | 1）merge：B(k)树的形成--- <br />将大的B(k-1)的树，依附在小的B(k-1)的root上 |