---
layout: post
title: Sort_ways
date: 2019-05-22 08:40:47
categories: 
- [data_struct_algorithm]
tags: sort
---

# Sort ways

+ 数据结构：考虑数据的存储方式，数据的快速查找和取出

## 排序前提

1. 假设：

   1）数组中元素类型为整数；

   2）内部排序：整个排序工作在主存中完成

   3）外部排序：在磁盘上完成排序

2. 算法：

   1）每个算法都将接受一个含有元素的数组和一个包含元素个数的整数。

## 内部排序

{% asset_img sort_summary.png %}

+ [代码链接](https://github.com/quronghui/DataStructAndAlogrithmCode/blob/master/SwordOffer/10_find_and_sort/sort.c)

### 冒泡排序

```
/* 冒泡排序 */
void	BubbleSort(int *array, int length)
{
	for(int i = 0; i < length-1 ; i++){
        for(int j = i+1; j <length ; j++){
            if( array[i] > array[j] ){    
                int tmp = array[i];
                array[i]    =   array[j];
                array[j]  =   tmp;                
            }
        }
    }
}
```

### 插入排序

1. 算法：

   + 每次取后一个元素，和前面已排好序的数组进行比较；

   1）每次都是取后一个元素p，和前面的数组进行比较，如果比p大，那么就往后移一位，替换覆盖；

   2）前面的数组都是排好序的；

   3）以前的想法：每一个元素：和所有的元素比较，先找出最小值

2. 插入排序的运行时间
   + 反序输入：O(N^2)
   + 正序输入：O(N) -- 元素不需要排序，将元素输入到数组需要花时间
   
3. 插入函数的接口

   ```
   /* insert_sort   */
   void InsertSort(int *array, int length)
   {
       // 从第二个元素才需要插入排序
       for ( int i = 1; i < length; i++){
           int tmp = array[i];                      // 设置哨兵元素
           int j =i;                                           // 前面已经排好序的( i - 1 )个元素
           for(; j > 0 && array[j-1] > tmp;  j--)  
               array[ j ] = array[j-1];                                    // 前面的大于 tmp, 则移动覆盖
           array[ j ] = tmp;                                          // 最后一个位置处理
       }
   }
   ```

### 逆序对的性质

1. 逆序性质
   + 当 i < j,  a[ i ] > a[ j ] ：这边是一个逆序对（  a[ i ] ， a[ j ] ）
   +  I = 是数组中的逆序对数；
   + 排序好的数组是没有逆序的，所以插入排序运行时间 O(I + N);
   + 交换相邻的两个元素，相当于交换逆序对。
2. 插入排序
   + 互异数：假设没有重复的数；
   + 在插入排序的时候，每次比较交换删除的不止一个逆序对

### 希尔排序

1. 算法：

   + 比较相距一定间隔的元素来工作，各趟比较所用的距离h(k)，随算法的进行而减小，直到只比较相邻元素的最后一趟排序为止

2. shell缩小增量序列

   + 1）用 a[i] 数组和 a[ i + h(k) ]进行比较；

     2）初始值：h(k) = N/2 ; 

     3）递减：h(k) = h(k) / 2
   
3. 希尔比较的方式

   {% asset_img shell_sort.jpg %}

4. 增量的选择

   + 使用 shell 的希尔增量最坏情况 O(N^2)，类似插入排序
   + 使用 hibbard 的希尔增量最坏情况 O(N ^ (3/2))
   + sedgewick 增量排序：其他的几种增量形式，降低运行时间；
   
5. 希尔排序的接口

   
   
   

### [堆排序](https://github.com/quronghui/DataStructAndAlogrithmCode/blob/master/SwordOffer/10_find_and_sort/sort.c)

1. 算法：

   + 通过优先队列方式：进行delete_min，得到排序数组；
   + 优先队列花费时间O(N * log N)，只是需要附加数组

   {% asset_img heap_sort.png %}

2. delete_min 实现

   + 每次将最后的单元的值放到堆顶, 位置用来存放刚刚删除的元素; 得到从小到大的排序数组

     1）delete_min 删除最后的元素后，整个堆以递减的顺序得到数组--max 堆；

     2）现实中构建的堆：和二叉堆的性质相反之处 -- （任一节点的关键字大于其儿子节点的关键字）；

     3）delete_min：得到从小到大的排序数组

   + 和**二叉堆**不同的是：0位置包含元素

3. 堆排序的复杂度分析

   + 本质: 利用完全二叉树的深度特性, 构建堆结构比较复杂;
   + 时间消耗: 初始建立堆和在重建堆时的反复筛选上;
   + 两种类型的堆: 最大堆和最小堆;



### [归并排序](https://github.com/quronghui/DataStructAndAlogrithmCode/blob/master/SwordOffer/10_find_and_sort/sort.c)

1. 算法

   + 本质: 是一颗倒着的完全二叉树, 涉及到完全二叉树的结构, 效率一般都不低;

   + 方法: 合并两个已经排序的表，将两个表插入到第三个表中完成排序

   + N 为元素的总数：

     1）将N分为前 / 后半部分数据各自递归排序；

     2）将排好序的两部分进行合并，两个指针分别指向A,B；每次比较后插入一个元素；直到最后一次比较，插入两个数据

     3）得到一个排序数组

   {% asset_img mergingsort.png %}

2. 归并排序

   + 运行时间：O(N * log N)
   + 归并排序：递归排序

### [快速排序](https://github.com/quronghui/DataStructAndAlogrithmCode/blob/master/SwordOffer/10_find_and_sort/quick_sort.c)

1. 快速排序
   + 当枢纽元位于中间，平均时间 = O(N log N);
   + 当枢纽元选择为最小元素，最坏的情况 = O(N^2);
   + 类似于归并排序，快速排序也是归并排序；
2. 快排算法
   + 假设：元素互异
   + 在数组中选择枢纽元 v；
   + 将数组**分割**为三部分，a [left] = { x  <  v }；a[center] = {v} ; a[right] = { x  >  v }；
   + 三部分各自排序后，组合在一起

3. 枢纽元选择：

   + 三数中值分割法 ：选择中间
   + v = [ ( left + right) / 2 ]

4. 分割策略：

   1）将枢纽元与最后元素交换，使得枢纽元离开要被分割的数据段；

   2）i从第一个元素开始；j从倒数第二个元素开始；相对于枢纽元，i和j的元素才交换

   3）将所有小元素移到左边，大元素移到右边；

   4）当i 和j交错时，停止移动，此时 i指向一个大元素，j指向一个小元素；

   5）将枢纽元和i的元素交换

   6）分割策略注意：当i和j遇到和枢纽p相同时，i和j停止移动

### 排序的下界 -- 决策树

1. 决策树：用于证明下届的抽象概念；

   + 决策树：一颗二叉树；

2. 决策树表示：

   + 只是用比较进行排序的算法，都可以通过决策树表示；

   + 决策树：只有输入数据非常少的情况下决策树才是可行的。

     + 画出 a, b, c三个元素的比较情况
     + 每次是两个元素的比较，进行分支

     {% asset_img Decision.png %}

3. 决策树的性质

   + 1）深度为k的决策树（二叉树），最多有(2^k)个树叶；

     2）反之，具有L片树叶的深度至少是log L

   + 比较次数 = 决策树的深度；

   + 只使用元素间比较的任何排序算法，需要进行

   {% asset_img de_tree.png %}

### 桶式排序

1. 桶式排序提供了一个前提：
   + 输入数据都需要小于一个M的整数

## 外部排序

1. **外部排序的限制**

   + 内部排序算法：将数据装入内存，这样数据的访问便可以**不按顺序进行**；
   + 外部排序：数据的输入输出是在物理设备上，**只能按照顺序访问**；

2. 外部排序的模型：

   + 外部排序比内部排序对设备依赖性更高；
   + 建立的模型：在磁带上进行；
     + 访问某个元素时，需要把磁带转动到正确位置

3. 算法：

   + 使用归并排序的merge例程；
   + 四个磁带空间：不停地将两个磁带中的数据（顺串）作为输入，另外两个磁带空间作为输出；直到所有的顺串合并为一个长的顺串；
   + **顺串：将每组排过序的记录叫做顺串**；

4. merge算法进过的次数

   + 这个算法是两路merge：两个输入，两个输出

   + 算法需要 [ log( N/M )]趟工作，每次合并2^n个数据；

     1）N：总得自己数；

     2）M：内存的大小；

     3）N/M：数据被分成多少个顺串；

5. 多路合并merge

   + 两路合并：只需要比较两个元素的最小值；

   + k路合并：

     + 每次需要比较k个元素的最小值；

     + 1）优先队列的方法，delete_min

     + 2) 算法需要 [ log(k) [ N/M ] ]趟工作，每次以2^n进行合并；

     + 3）十盘磁带：k = 5；一半作为输入，一半作为输出；

   + k路合并，需要2k盘磁带

6. 多相合并

   + k 路合并，需要（k+1）盘磁带
     + 为了减小磁带数量
   + 顺串最初的分配有很大的关系，决定后续多少趟的进行；
     + 顺串不均分在k个磁带上，第（k+1）个磁带用于输出数据

7. 替换选择

   + 目的：考虑顺串的构造

   + 替换选择

     + 1）首先读入M个记录放在队列上，然后delete_min将最小值输出到磁带上；

       2）读入下一个记录是和 最小值比较，大于--放入优先对列；(二叉堆的构建)

       3）优先队列少一个元素，将小于每次delete_min的元素，存入优先队列的死区，直到顺串完成构建；

       4）这个元素用于下一个顺串；（堆排序的做法：最小值取出后放在最后一个位置）

       5）持续上述做法，直到优先队列大小为0，完成顺串构建

## 总结

1. 内部排序算法的选择：
   + 插入排序；希尔排序；快速排序；
   + 通过数据的输入量的大小决定
2. 外部排序算法：
   + 合并 merge 是中心思想