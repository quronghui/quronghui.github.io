---
layout: post
title: Sort_ways
date: 2019-05-22 08:40:47
categories: 
- [data_struct_algorithm]
tags: sort
---

# Sort ways

+ 数据结构：考虑数据的存储方式，数据的快速查找和取出

## 排序前提

1. 假设：

   1）数组中元素类型为整数；

   2）内部排序：整个排序工作在主存中完成

   3）外部排序：在磁盘上完成排序

2. 算法：

   1）每个算法都将接受一个含有元素的数组和一个包含元素个数的整数。

## 内部排序

### 插入排序

1. 算法：

   + 每次取后一个元素，和前面已排好序的数组进行比较；

   1）每次都是取后一个元素p，和前面的数组进行比较，如果比p大，那么就往后移一位，替换覆盖；

   2）前面的数组都是排好序的；

   3）以前的想法：每一个元素：和所有的元素比较，先找出最小值

2. 插入排序的运行时间
   + 反序输入：O(N^2)
   + 正序输入：O(N) -- 元素不需要排序，将元素输入到数组需要花时间

### 逆序

1. 逆序性质
   + 当 i < j,  a[ i ] > a[ j ] ：这边是一个逆序对（  a[ i ] ， a[ j ] ）
   +  I = 是数组中的逆序对数；
   + 排序好的数组是没有逆序的，所以插入排序运行时间 O(I + N);
   + 交换相邻的两个元素，相当于交换逆序对。
2. 插入排序
   + 互异数：假设没有重复的数；
   + 在插入排序的时候，每次比较交换删除的不止一个逆序对

### 希尔排序

1. 算法：

   + 比较相距一定间隔的元素来工作，各趟比较所用的距离h(k)，随算法的进行而减小，直到只比较相邻元素的最后一趟排序为止

2. shell缩小增量序列

   + 1）用 a[i] 数组和 a[ i + h(k) ]进行比较；

     2）初始值：h(k) = N/2 ; 

     3）递减：h(k) = h(k) / 2
   
3. 希尔比较的方式

   {% asset_img shell_sort.jpg %}

4. 增量的选择

   + 使用 shell 的希尔增量最坏情况 O(N^2)，类似插入排序
   + 使用 hibbard 的希尔增量最坏情况 O(N ^ (3/2))
   + sedgewick 增量排序：其他的几种增量形式，降低运行时间；

### 堆排序

1. 算法：

   + 通过优先队列方式：进行delete_min，得到排序数组；
   + 优先队列花费时间O(N * log N)，只是需要附加数组

2. delete_min 实现

   + 每次将最后的单元，存放刚刚删除的元素，得到从小到大的排序数组

     1）delete_min 删除最后的元素后，整个堆以递减的顺序得到数组--max 堆；

     2）现实中构建的堆：和二叉堆的性质相反之处 -- （任一节点的关键字大于其儿子节点的关键字）；

     3）delete_min：得到从小到大的排序数组

   + 和二叉堆不同的是：0位置包含元素

### 归并排序

1. 算法

   + 合并两个已经排序的表，将两个表插入到第三个表中完成排序

   + N 为元素的总数：

     1）将N分为前 / 后半部分数据各自递归排序；

     2）将排好序的两部分进行合并，两个指针分别指向A,B；每次比较后插入一个元素；直到最后一次比较，插入两个数据

     3）得到一个排序数组

2. 归并排序

   + 运行时间：O(N * log N)
   + 归并排序：递归排序

### 快速排序

1. 快速排序
   + 当枢纽元位于中间，平均时间 = O(N log N);
   + 当枢纽元选择为最小元素，最坏的情况 = O(N^2);
   + 类似于归并排序，快速排序也是归并排序；
2. 快排算法
   + 假设：元素互异
   + 在数组中选择枢纽元 v；
   + 将数组**分割**为三部分，a [left] = { x  <  v }；a[center] = {v} ; a[right] = { x  >  v }；
   + 三部分各自排序后，组合在一起

3. 枢纽元选择：

   + 三数中值分割法 ：选择中间
   + v = [ ( left + right) / 2 ]

4. 分割策略：

   1）将枢纽元与最后元素交换，使得枢纽元离开要被分割的数据段；

   2）i从第一个元素开始；j从倒数第二个元素开始；相对于枢纽元，i和j的元素才交换

   3）将所有小元素移到左边，大元素移到右边；

   4）当i 和j交错时，停止移动，此时 i指向一个大元素，j指向一个小元素；

   5）将枢纽元和i的元素交换

   6）分割策略注意：当i和j遇到和枢纽p相同时，i和j停止移动

### 排序的下界 -- 决策树

1. 决策树：用于证明下届的抽象概念；

   + 决策树：一颗二叉树；

2. 决策树表示：

   + 只是用比较进行排序的算法，都可以通过决策树表示；

   + 决策树：只有输入数据非常少的情况下决策树才是可行的。

     + 画出 a, b, c三个元素的比较情况
     + 每次是两个元素的比较，进行分支

     {% asset_img Decision.png %}

3. 决策树的性质

   + 1）深度为k的决策树（二叉树），最多有(2^k)个树叶；

     2）反之，具有L片树叶的深度至少是log L

   + 比较次数 = 决策树的深度；

   + 只使用元素间比较的任何排序算法，需要进行

   {% asset_img de_tree.png %}

## 外部排序

### 