---
layout: post
title: red_and_black_tree
date: 2019-05-27 10:20:51
categories: 
- [data_struct_algorithm]
tags: red_and_black_tree
---

# red and black tree

## 摊还分析

1. 摊还时间界
   + 长时期运行中的这种数据结构的行为，就像是每次操作花费O(log N)时间一样；
   + 每次操作花费时间；

## 自顶向下伸展树

1. 伸展树的三种变换形式：

   + 单旋转：Y成为新的root；X成为Y的right_child;

   + 一字型：最左边的Z依次上升到root；X下降到右边；

   + 之字形：双旋转；Z成为=root；其他的左边的是leftchild;右边的是rightchild

   {% asset_img top_to_bottom.png %}

2. 自顶向下

   + 自底部向上：是一棵AVL树

     1) 单旋转；

     2）双旋转；dafa

   + 自顶向下的展开：生成三棵树

     1）L 左子树；<  中间的树；<  R右子树；

3. 自顶向下的算法：

   1）应用：简化之字形展开；

   2）一步步展开，旋转后分别存储为三棵树；

   3）进行整理合并；

## 红黑树

1. 红黑树是具有着色性质的二叉查找树：

   + 二叉查找树：

     左子树的所有关键字 < X-root  < 右子树的所有关键字 

   + 红黑树着色：

     1）黑色节点：一个圈表示；红色节点：两个圈表示；

     2）root：黑色；

     3）一个节点是红色，那么其子节点必须是黑色；

     4）从一个节点到一个NULL指针的每一条路径必须包含相同数目的黑色节点

2. 新元素的插入情况

   - 插入节点的parent 是黑色 --->	直接插入就完成；
   - 插入点的parent是红色，且parent 的兄弟是黑色：---> 自底向上插入
   - 插入点的parent是红色，且parent 的兄弟是红色：---> 自顶向下插入

### 自底向上插入

1. 插入的节点满足条件：

   1）二叉树的性质：left < X < right;

   2）红黑树的性质：颜色和黑节点路径；

2. 新节点的插入：

   1）新项作为树叶放到树种；

   2）插入操作进行：颜色的改变和树的旋转

3. 插入点的parent是红色：parent 的兄弟是黑色

   + 自底向上插入：先插入，在平衡

   + a.形式：一字链和之字链；

     b.平衡条件：单旋转和双旋转；

     c.颜色的改变：根节点由黑转红；

   {% asset_img top_to_bottom_tree.png %}

### 自顶向下插入

1. 插入点情况：插入点的parent是红色：parent 的兄弟是红色

   +  先平衡再插入

   + a. 执行一次颜色翻转：图；

     b. 单旋转（两个连续的红色节点）；

     c. 使得插入点的parent是黑色；

   + 先进行一系列的操作，将插入节点的parent变成黑色；直接插入节点就行。

   {% asset_img top_tree.png %}

### 自顶向下删除

1. 自顶向下的插入：

   1）先平衡，保证插入节点的父节点再插入的时候是黑色节点；

   2）不影响红黑树的性质三

2. 自顶向下的删除：

   1）先平衡，保证删除的树叶在删除期间是红色的；

   2）不影响红黑树的性质四