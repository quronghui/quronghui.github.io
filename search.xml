<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿里AI安全讲座]]></title>
    <url>%2F2019%2F03%2F22%2FWork%2F</url>
    <content type="text"><![CDATA[阿里AI安全讲座 工作和学习的建议 主讲人：张荣 个人的工作经历 第一阶段的工作：快速成长 跳出生活的舒适区，刚毕业对生活的节奏很新鲜，工资翻倍，小生活滋润 需要有鞭策，寻找新视野，更上工作的步伐，为后续的转行做准备 第二阶段的工作：拒绝吃老本行 跳出工作的舒适区，适应工作环境和工作节奏之后的状态 学习新的知识，寻找新的方向和平台 第三阶段的工作：止跌回升 找到大平台，资源； 为自己的方向而打拼 用计算机的思维去思考问题 第四阶段的工作：行业内寻找新方向 在行业中寻找新的方向 选择 行业～进入快速发展的行业 企业～进入前途远大的企业 业务～进入成长性的业务 老板～跟上有雄心壮志的老板 行业 科技发展的2个主线：能量和信息 5G : 基础设施，超高速传输，广覆盖 IoT：万物互联 感知 – 认知 企业 巨头：资源过剩，平台大，优秀的人多，不容易脱颖而出 二线：发展的机会欠缺，不利于成长 超新星：国家和政府扶持，目前最需要的 初创：不关注个人成长，只是让你完成任务 企业面试看中什么？ 校招和社招不同 校招～为未来投资，面向未来，技能总会过时 阿里校招的需求 基础品质 完整的项目经历，项目落地的经历 基础知识 技术文档：英语写作能力，口头交流能力 编程基础 学生到职场人 做决定和承担的能力 有自己的想法和idea 自我驱动和发展 公司需要的能力 从公司的规模来看： 完成 – 完善 – 对外推广 从公司的结构 网状：上下连接，生产实现，推销 Leader：不应该是团队的技术核心，应该是一个连接者，组建一个由长板构成的团队 面试和笔试 基础必须好： 数据结构题目的刷人，时间复杂度，空间复杂度是多少 编程问题：基础能力必须牢固 想面试阿里：用一个钉钉客户端，里面有阿里邮箱 AI 安全技术相关]]></content>
      <categories>
        <category>work</category>
        <category>AI cathedra</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pointer]]></title>
    <url>%2F2019%2F03%2F22%2FPointer%2F</url>
    <content type="text"><![CDATA[Pointer (指针)指针的基本操作理解指针 堆栈和队列 堆栈有栈顶指针，队列有头指针和尾指针 这种指针本质：是一个整数，是数组的索引 指针概念 把一个变量所在的内存单元的地址 保存在另外一个内存单元 此内存单元 称为指针 1234int i;int *pi = &amp;i; /*全局变量的赋值：右边必须是常量表达式*/char c;char *pc = &amp;c; /*32位的虚拟机，他们的内存单元都是4 byte*/ 根据指针知找到变量 指针的关系 &amp;运算符的操作数必须是左值,因为只有左值（变量）才表示一个内存单元,才会有地址, 表达式E可以做左值（变量），*&amp;E = E E是指针类型，&amp;*E = E 123int *p; /*定义指针类型p*/p = &amp;i; /*此时p保存的是i的地址*/int j = *p; /*此时 *p = *&amp;i; 也就是i的值*/ 指针间的赋值 12int *ptri;ptri = pi; /*是把变量pi所保存的地址值赋给变量ptri*/ /*保证ptri 和 pi是同一种类型，否则需要强制转化 指针很容易指向错误的地址，访问这样的地址可能导致段错误 空指针和野指针 定义局部类型的指针变量，却没有赋值 – 野指针(Unbound Pointer)（和局部变量定义却不赋值） 避免野指针，定义指针变量因该赋值，货值初始化NULL 123int *p = NULL;#define NULL ((void *)0) /*将地址0转换为指针类型*//*任何对地址0的访问都会立刻产生段错误*/ void * 类型 void *指针与其它类型的指针之间可以隐式转换,而不必用类型转换运算符。 只能定义void *指针，而不能定义void 型的变量。 因为void *指针和别的指针一样都占4个字节，void型的变量就不清楚了 指针和数组 指针指向数组 a[0] 的地址 123int a[10];int *pa = &amp;a[0]; /*后缀运算符优先级高于单目运算符*/pa++; 由于数组a做右值使用时和 &amp;a[0]是一样的 表达式pa[-1] 是合法的,它和a[0] 表示同一个元素。 12int *pa = &amp;a[0]; 等价于 ：int *pa = a; 指针的比较运算 只有指向同一数组的指针，作比较才有意义 指针的比较比的是地址 指针的相减运算 相减：表示两个指针间，相差的元素个数 12pa - a = ?pa - 1 = a; pa - a = 1 函数的参数是数组时，等价于参数是指针的形式 12void func(int a[10])等价于 ： void func(int *a) 指针与const限定符 const : 将不允许修改的内存单元保护起来； 指向const int 型的指针 代码方式 12const int *a;or int const *a; 代表含义 a 是一个指向const int 型的指针； a 指向的内存单元是不能修改的。（a 代表地址的内存单元） （*a）++ 不允许 （值）；a++允许（地址） 只能读指针a 指向的元素 指向int 型的 const 指针 代码方式： 1int * const a; 代表含义 *a是可以改写的,内容的值可以修改 a不允许改写，地址不能修改 指向const int 型的 const 指针 代码方式： 12const int * const a;or int const * const a; 代表含义 因此*a 和a都不允许改写。 结论 指向非const 变量的指针或者非const 变量的地址可以传给指向const 变量的指针,编译器可以做隐式类型转换,例如: 12char c = 'a';const char *pc = &amp;c; // c 的值是不会改变的 const 使用 字符串字面值通常分配在.rodata段 .rodata：不允许改写，但编译器不会报错，在运行时会出现段错误。 指针与结构体 定义结构体类型 123456struct unit&#123; char c; int num;&#125;;struct unit u;struct unit *p = &amp;u; 指针访问结构体元素 12way1 ： (*p).c ，(*p).num;way2 : p-&gt;c , p-&gt;num 指向指针的指针与指针数组指向指针变量的指针 指针可以指向基本类型，也可以指向复合类型，因此也可以指向另外的指针变量 代码类型 123int i;int *pi = &amp;i; // pi 保存的是 i 的地址int **ppi = &amp;pi; // *(*ppi) = &amp;pi: (*ppi)取 pi的值; *(*ppi) 取 i的值 指针数组 指针数组的定义 12int a[10]; --&gt; int *a[10];int *pa = &amp;a; --&gt; int **pa = &amp;a[0]; //指向指针数组的首元素 &amp;a[0] 表示数组a的首元素的首地址；而&amp;a 表示数组a 的首地址； 显然这两个地址的数值相同，,但这两个表达式的类型是两种不同的指针类型,前者的类型是int ,而后者的类型是int ( )[10] 则pa[0] 和a[0]取的是同一个元素; 唯一比原来复杂的地方在于这个元素是一个int * 指针，不是基本类型 main的标准原型 [main code] main的原型 1int main(int argc, char *argv[]); argc : 命令行参数的个数 而argv 是一个指向指针的指针,为什么不是指针数组呢? 函数原型中的[ ]表示指针而不表示数组，等价于char **argv 那为什么要写成char *argv[]而不写成char **argv 呢？ argv 不是指向单个指针,而是指向一个指针数组的首元素。 数组中每个元素都是char *指针,指向一个命令行参数字符串。 main 原型的代码结构 指向数组的指针与多维数组指向数组的指针 代码定义： 1234int *a[10] --&gt; int (*a)[10]; /*********************Equivalent to:**********************/typedef int *t; --&gt; typedef int t[10];t a[10]; --&gt; t *a; int a[10]：含有10个 int 的数 int (*a)[10]：含有10 个int 型的数 指针数组使用 12int a[10];int (*pa)[10] = &amp;a; *pa：表示pa指向的数组a； 12a[0] == (*pa)[0]; (*pa) --&gt; pa[0]所以引入二维数组： (*pa)[0] == pa[0][0] 多维数组 通过指向数组的指针，表示二维数组； 实现数组的自增和赋值作用 多维数组的引用 12int a[5][10]; --&gt; int a[10];int (*pa)[10] = &amp;a[0] --&gt; int (*pa)[10] = &amp;a; 多维数组的优势 pa 比a用起来更灵活，数组名不支持赋值、自增等运算； 而指针可以支持，pa++ 使 pa 跳过二维数组的一行(40个字节)，指向a[1] 的首地址。 函数类型和函数指针类型定义 指针变量：内存单元存放一个地址值； 函数指针：存放的就是函数的入口地址(位于.text 段)]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Pointer</category>
      </categories>
      <tags>
        <tag>pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile]]></title>
    <url>%2F2019%2F03%2F21%2FMakefiles%2F</url>
    <content type="text"><![CDATA[Makefile 基础 Link code – Makefiles Makefile 基本规则Makefile 例子 12345678main: main.o stack.o maze.o gcc main.o stack.o maze.o -o mainmain.o: main.c main.h stack.h maze.h gcc -c main.cstack.o: stack.c stack.h main.h gcc -c stack.cmaze.o: maze.c maze.h main.h gcc -c maze.c Makefile 由一组规则 rule组成 1234target ... : prerequisites ... command1 command2 ... 目标和条件之间的关系是：欲更新目标，必须首先更新它的所有条件; 所有条件中只要有一个条件被更新了，目标也必须随之被更新。 所谓“更新”就是执行一遍规则中的命令列表；命令列表中的每条命令必须以一个Tab开头；（注意不能是空格） 对于Makefile中的每个以Tab开头的命令,make 会创建一个Shell进程去执行它。 make 编译 make 会自动选择那些受影响的源文件重新编译，不受影响的源文件则不重新编译。 make clean123456clean: @echo "cleanning project" -rm main *.o @echo "clean completed".PHONY: clean /* 声明clean为一个伪目标 */ clean 目标不依赖于任何条件,并且执行它的命令列表不会生成 clean文件 rm and mkdir 命令前面加 “ - ” 即使这条命令出错，也会继续执行后面的命令 因为rm 要删除的文件可能不存在,mkdir 要创建的目录可能已存在 在命令前加 @ 加了命令在前面，不显示命令本身 而只显示它的结果; .PHONY: clean 声明clean为一个伪目标 为了将clean 当做特殊的名字使用 类似于clean的目标名字​ Makefile 隐含规则和模式规则​ 变量 符号 作用 “ := ” y := $(x) bar make 遇到变量定义的时候：立即展开 nullstring :=space := $(nullstring) # end of the line 为了定义变量的值为空格；注释前面是有空格 “ ?= ” foo ?= $(bar) 相当于 “ = ”，定义foo的值为$(bar) “ += ” 保持了“ := ”的特性 特殊变量 可以减少书写错误 特殊变量：替代makefile中的规则，简写 特殊变量的使用 “ $? “的使用 用于生成静态、共享库 123libsome.a: foo.o bar.o lose.o win.o ar r libsome.a $? ranlib libsome.a 变量的缺省值 自动处理头文件的依赖关系 省去了手动敲命令 命令12$ gcc -M main.c /* 找出所有的依赖头文件 */$ gcc -MM main.c /* 排除系统头文件 */ Make命令选项 Makefile 文件 从主目录到子目录中都存在 总的Makefile ： make -C 执行每个子目录下的Makefile 1234$ make -n /*只打印要执行的命令，而不是直接执行；检查makefile是否正确*/$ make -C testmake /* 切换到目录testmake下，编译 */$ make -C /*执行每个子目录下的Makefile*/$ make CFLAGS=-g /*在编译中增加调试选项*/]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pretreatment]]></title>
    <url>%2F2019%2F03%2F21%2FPretreatment%2F</url>
    <content type="text"><![CDATA[Pretreatment 预处理预处理步骤 经过以下步骤之后，把空白字符丢掉，把Token交给C编译器做语法解析, 换行符 Windows平台的文本文件用\r\n 做行分隔符,而Linux平台用\n做行分隔符； C编译器要能处理差别 把用 “ \ ” 字符续行的多行代码连成一行 把注释都替换为一个空格 Token 然后预处理器把逻辑代码行划分成Token和空白字符, 这时的Token称为预处理Token：包括标识符、整数常量、浮点数常量、字符常量、字符串、运算符和其它符号 宏定义 较大的项目都会用大量的宏定义来组织代码，宏定义很常用 函数式宏定义 变量式 1#define N 20 函数式 12#define MAX(a, b) ((a)&gt;(b)?(a):(b)) // 不加括号，展开后会报优先级错误k = MAX(i&amp;0x0f, j&amp;0x0f) 函数式宏定义 不建议使用 内联函数 关键词：inline 条件预处理提示Header Guard1234#ifndef HEADER_FILENAME //如果没有定义HEADER_FILENAME，则执行后面的语句#define HEADER_FILENAME/* body of header */#endif #ifdef 或 #if 可以嵌套使用,但预处理指示通常都顶头写不缩进,为了区分嵌套的层次 预处理过程 先处理defined运算符 12#if defined x 相当于 #ifdef x#if !defined x 相当于 #ifndef x 展开所有的宏定义 把没有定义的宏换成 0 把得到的表达式 ，像C表达式一样求职 其他预处理特性 _ FILE _ ：展开为当前源文件的文件名,是一个字符串, _ LINE _ ：展开为当前代码行的行号,是一个整数。 _ func _ : 特殊的标识符，打印所在函数的名字 assert.h 实现 #undef assert 确保取笑前面对assert的定义 然后分另种情况：]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Pretreatment</category>
      </categories>
      <tags>
        <tag>Pretreatment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Link lib]]></title>
    <url>%2F2019%2F03%2F19%2FLinklib%2F</url>
    <content type="text"><![CDATA[Link lib Code link – Link 多目标文件链接 编译查看命令 12$ gcc main.c -o main //编译可执行文件$ readelf -a main //查看到个函数的段定义 目的： 能查看到跟函数的段定义 Data Segment 后面的一些Segment，主要是调试信息 包含其他的 .c 文件 为什么编译器在处理函数，调用代码时需要有函数原型? 因为必须知道参数的类型和个数以及返回值的类型才知道生成什么样的指令。 定义和声明 凡是被多次声明的变量或函数： 必须有且只有一个声明是定义 如果有多个定义，或者一个定义都没有,链接器就无法完成链接。 变量和函数的声明不同 函数的声明：extern，可有可无 变量的声明：extern，必须要有 extern int top extern 和 static 包含其他的 .c 文件时 — 直接包含// #include “stack.cpp” ，错误的想法 123456#include &lt;stdio.h&gt;// #include "stack.cpp" // 有了函数的声明，就不需要加引用了extern void push(char);extern char pop(void);extern int is_empty(void); extern : 表示关键字具有 External Linkage 链接之后是同一个GLOBAL符号,代表同一个地址。 static ： 表示一个Internal Linkage的属性 有些模块不希望被外界访问到，声明为内部的 ### 头文件 .h 将变量和函数的声明放在一个 .h 的文件中 在每次调用函数的时候，只需要包含 . h 的头文件； 不需要在函数中对每一个函数进行声明 预处理关键词 1234#ifndef STACK_H /* 预处理的关键词 */#define STACK_H...#endif 直接包含 .c 文件 – – 错误的 为什么不在 main.c 中直接包含 stack.c 文件？？ 假如又有一个foo.c 也要使用stack.c这个模块。如果在foo.c 里面也包含头文件#include “stack.c” 就相当于push 、pop 、is_empty 这三个函数在main.c和foo.c 中都有定义，那么main.c和foo.c 就不能链接在一起了。 如果采用包含头文件的办法,那么这三个函数只在stack.c中定义了一次,最后可以把main.c、stack.c、foo.c 链接在一起。 头文件中的函数和变量声明一定不能是定义 如果头文件中出现变量或函数定义，这个头文件又被多个.c 文件包含,那么这些.c 文件就不能链接在一起了。 定义声明的详细规则 有相应的作用域和作用范围 静态库 将一组代码编译成一个库 链接器只会取出静态库中：有用的那部分代码。 代码结构 代码目录的区别：编译的时候需要指定目录 便以为目标文件 12$ gcc -c stack/stack.c stack/push.c stack/pop.c stack/is_empty.c// 生成 .o 文件 打包成静态库 库文件命名：libxxx; 静态库 ： .a为后缀 12$ ar rs libstack.a stack.o push.o pop.o is_empty.oar: creating libstack.a 链接主函数 main.c 和 libstack.a -L 选项告诉编译器去哪里找需要的库文件：-L . 表示在当前目录找 -lstack ：告诉编译器链接 libstack库 -Istack：告诉编译器寻找头文件 1$ gcc main.c -L. -lstack -Istack -o main 查看编译器会查询的目录 1$ gcc -print-search-dirs 共享库编译，链接，运行 编译 12$ gcc -c -fPIC stack/stack.c stack/push.c stack/pop.cstack/is_empty.c // -f 编译选项；PIC 是其中一种 生成共享库 使用了PIC：共享库的各段加载地址没有定死，可以加载到任意位置 12$ gcc -shared -o libstack.so stack.o push.o pop.o is_empty.o$ objdump -dS libstack.so //反汇编查看共享库 链接库 1$ gcc main.c -g -L. -lstack -Istack -o main 运行出错 12$ ./main // 运行的时候：找不到动态链接库 libstack.so??$ ldd main //ldd查看main函数依赖哪些共享库 添加动态库的路径 pwd : 得到 .so 的绝对路径 vi etc/ld.so.conf ：每个路径一行，添加 sudo ldconfig -v 共享库的命名 按照共享库的命名惯例,每个共享库有三个文件名:real name、soname和linker name。 指定库的名字 1$ gcc -shared -Wl,-soname,libstack.so.1 -o libstack.so.1.0 stack.o push.o pop.o is_empty.o 虚拟内存管理查看命令12345$ ps //查看当前终端下的进程// bash 进程的 id 是 3279$ cat /proc/3279/maps //查看它的虚拟空间地址// proc 是内核虚拟出来的文件系统// 当前系统中运行的每个进程在/proc 下都有一个子目录,目录名就是进程的id 进程地址空间 进程空间是独立的：每个进程都有各自的VA 和 PA 系统中可分配的内存总量 = 物理内存的大小 + 交换设备的大小]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linklib</category>
      </categories>
      <tags>
        <tag>Linklib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Assembler And C]]></title>
    <url>%2F2019%2F03%2F18%2FComplationAndC%2F</url>
    <content type="text"><![CDATA[Complation And CAssembler And C汇编代码生成C和汇编穿插显示12gcc -g main.c -o main -Wall // 生成可执行文件objdump -dS main // 把C代码和汇编代码穿插起来显示 只生成汇编1gcc -S main.c //只生成汇编代码main.s,而不生成二进制的目标文件。 汇编调试12345(gdb) disassemble //可以反汇编当前函数或者指定的函数(gdb) si //step 命令可以一行代码一行代码地单步调试,而这里用到的si命令可以一条指令一条指令地单步调试。(gdb) info registers //可以显示所有寄存器的当前值。(gdb) p $esp //打印esp寄存器的值,// 在上例中esp 寄存器的值是0xbff1c3f4,所以x/20 $esp 命令查看内存中从0xbff1c3f4地址开始的20个32位数。 数据的存储 在执行程序时,操作系统为进程分配一块栈空间来存储函数栈帧 esp 寄存器总是指向栈顶，ebp指向栈底 esp 随着压栈和出栈操作随时变化，ebp保持不变 有高地址想低地址增长 函数的参数和局部变量都是通过ebp 的值加上一个偏移量来访问的 程序入口 汇编程序入口函数：_start；C程序的入口是：main() 汇编函数编译 12$ as hello.s -o hello.o //翻译为汇编代码$ ld hello.o -o hello //ld进行链接库 C程序的编译 123$ gcc -S main.c //生成汇编代码$ gcc -c main.s //生成目标文件$ gcc main.o //生成可执行文件 C程序链接库的过程 链接和显示 12$ gcc -v main.c -o main //了解详细的编译过程$ objdump -d main //通过反汇编查看各目标文件所定义的符号 C链接的过程 变量的存储布局 查看命令 12$ gcc -g main.c -o main $ readelf -a main //查看符号表 global and local 关键字修饰变量 通过一些关键字修饰变量：const 、static、register const 修饰的变量 全局的变量 GLOBAL 变量只读，不可修改 const 变量在定义时必须初始化。因为只有初始化时才有机会给它一个值。 一旦定义之后就不能再改写了,也就是不能再赋值了。 static 修饰的变量 static 修饰的变量，LOCAL LOCAL 的符号只能在某一个目标文件中定义和使用,而不能定义在一个目标文件中却在另一个目标文件中使用。 作用域（Scope）些名词,因为我不是在写C标准。 作用域适合于所有的标识符，而不仅仅是变量。 作用域范围 从当前位置，到所在函数结束 命名空间 （Name Space） 对于重名标识符，内层作用域的标识符将覆盖外层作用域的标识符。 存储类型标识符（Storage Class Specifier） 结构体和联合体存储 栈：是从高地址向低地址增长的； 结构体成员：从低地址向高地址排列，这一点和数组类似。但有一点和数组不同,结构体的各成员并不是一个紧挨一个排列的,中间有空隙,称为填充。 C和内联汇编 内联汇编：为了提高Ｃ的执行效率。因为Ｃ的代码是由编译器进行翻译的。 内联方式 内联格式 1_asm_(assembler code) C中的内联汇编，需要和Ｃ的变量建立关联 12345__asm__(assembler template : output operands /* optional */ : input operands /* optional */ : list of clobbered registers /* optional */);]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Complation</category>
      </categories>
      <tags>
        <tag>complation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CC2540]]></title>
    <url>%2F2019%2F03%2F17%2FCC2540%2F</url>
    <content type="text"><![CDATA[CC2540核心板电路图阿莫电子 正常工作：CC2540工常工作的晶振是32M,休眠晶振是32.768K。 IT 官网 RESET 引脚：接了一个电阻 复位键：加了一个下拉电阻。（通过一个电阻减小电流对reset pin 造成的影响） CC2540 连接不上仿真器外部晶振不工作 原来CC2540为了降低功耗：设置了几种不同的工作模式，在没有程序运行的情况下，默认是关闭外部的晶振的，所以在新片子刚焊上时，晶振当然也就不起振了。 两端的匹配电容大小要合适，不然导致无法起振； 选择的电容的值越大单片机的耗电能力也就越强，而且易造成不起振的情况。减小晶振的电容值 PCB 焊接错误 参考蓝牙 底部是需要进行焊接的：之前焊接的时候都是有意避开底部，不上焊锡。 电压检查 Bias 引脚 错误原因排除 32 M 晶振的是适配电容用12 pF; PCB板子的底部应该是打孔 3*3 cc2540内部集成了上电的复位电路，我们没有，应该加上电复位Reset TI 建议在RESET 上连接RC 滤波电路，这样增加系统的可靠性，其实也可以直连RESET。 CC-debugger 板子的2脚反馈电压不正常，板子的供电不正常。– 排除 开发手册 参考教程]]></content>
      <categories>
        <category>cc2540</category>
        <category>Electronic</category>
      </categories>
      <tags>
        <tag>cc2540</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crystal Oscillator]]></title>
    <url>%2F2019%2F03%2F17%2FCrystalOscillator%2F</url>
    <content type="text"><![CDATA[Oscillator and Crystal有源晶振 oscillator（振荡器） 有源晶振是右石英晶体组成的。 石英晶片：可以当为振荡器使用，是基于它的压电效应：在晶片的两个极上加一电场，会使晶体产生机械变形； 四脚晶振 有源的四脚晶振：有个点标记的为1脚，按逆时针（管脚向下）分别为2、3、4 有源晶振通常的用法：一脚悬空，二脚接地，三脚接输出，四脚接电压。 配置电路 有源晶振不需要DSP的内部振荡器，信号质量好，比较稳定，而且连接方式相对简单。 电源滤波：通常使用一个电容和电感构成的PI型滤波网络， 三脚输出端：用一个小阻值的电阻过滤信号。 无源晶振 Crystal 仅由阻容元件组成 起振需求 无源晶振是有2个引脚的无极性元件，需要借助于时钟电路才能产生振荡信号，自身无法振荡起来。 两端的匹配电容大小要合适，不然导致无法起振。 晶振是否起振测量示波器测量 通电的情况下，测量双脚： 脚1和脚3是通电的，电流从脚1流入、脚3流出。 正接脚1，负接3； 以探头最好打到衰减档进行测试，探头测试晶振管脚有固定正确频率的正弦波信号输出即可。 通电的情况下，测量单脚： 用示波器连接任意一个引脚与地线， 观测到震荡波形且频率与晶振频率相符（频率不对的话是干扰信号）就说明已经起振。 原因分析焊接 晶振的温度范围 -50 – 85。 焊接时烙铁的温度200 度左右。 PCB 工艺问题 电容值不匹配，电容值大小和晶振起振相反。 降低电容值，看是否起振 选择的电容的值越大单片机的耗电能力也就越强。而且易造成不起振的情况。 晶振两脚之间有走线 晶振电路的走线过长]]></content>
      <categories>
        <category>Oscillator</category>
        <category>Electronic</category>
      </categories>
      <tags>
        <tag>Oscillator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[post]]></title>
    <url>%2F2019%2F03%2F17%2Fpost%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[x86Programe]]></title>
    <url>%2F2019%2F03%2F14%2Fx86Programe%2F</url>
    <content type="text"><![CDATA[x86 Programe 确实没怎么看懂 X86的寄存器 x86的通用寄存器有eax 、ebx 、ecx、edx 、edi 、esi 前面加 %eax 汇编语句的编译执行 文件命名：.s 代码解读 .globl name : 需用连接器 ld 知道的名字 edi / ebx / eax ELF 文件 ELF Header 目标文件布局]]></content>
      <categories>
        <category>LinuxC</category>
        <category>x86 Programe</category>
      </categories>
      <tags>
        <tag>LinuxC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CBIB Item]]></title>
    <url>%2F2019%2F03%2F14%2FAutoCADxbox%2F</url>
    <content type="text"><![CDATA[AutoCAD Xbox autocad 制作盒子给kinect KinectXobx xbox.pdf 尺寸图 类别尺寸 mm 长 宽 高 平板尺寸图 303 188 11 Xbox 284 39 62 Xbox 云台 82 20 73 类别尺寸 长 宽 高 俯视图外层 305 200 俯视图内部虚线 三轴传感器实现音乐的播放实现目的 实现简单的音乐简谱：从最简单低音，中音，高音 ，实现 do re mi fa so la xi 七个音符 ； 对音乐的简谱有一个了解; 电脑的beep，可以实现； 通过读取三轴传感器的数据，控制电脑播放某一个音节； 电脑读取：USB三轴传感器的数据； 数据进而控制简谱的播放：对应的关系。 先检测晃动的轻重：能够控制低音，中音，高音； 检测晃动的频率：能控制播放的节拍 电脑能够记录弹奏者 用户自己输入一遍音符 ：只保证正确，不需要匹配速率； 当播放用户的文件时 加速度传感器：控制用户播放音符的节奏 通过检测晃动的频率 用户输入音符：记录用户输入的轻重节奏 当播放用户的文件时 加速度传感器：控制音符的低音，中音，高音； 最后能够实现 制作一个指挥棒； 指挥棒能完成一首音乐演奏的指挥任务 平台搭建 先使用USB的三轴传感器，进行功能的实现； 后期ESP32 的蓝牙 + 三轴传感器；实现远程的控制]]></content>
      <categories>
        <category>CBIB Item</category>
      </categories>
      <tags>
        <tag>cbib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Architecture]]></title>
    <url>%2F2019%2F03%2F14%2FComputerArchitecture%2F</url>
    <content type="text"><![CDATA[Computer Architecture Von Neumann 体系结构主要由CPU(processor) + Memory ( data + fetch ) 数据的存储，访问和管理 内存和地址 地址 CPU通过address找到存储单元，每个存储单元只能存一个byte，将数据放入存储单元中。 内存 内存的大小：却绝育CPU的地址空间； 32位：0x0000 0000 - 0xffff ffff 找存储位置，进行读 / 写操作。 CPU CPU总是周而复始地做同一件事 : 从内存取指令,然后解释执行它,然后再取下一条指令,再解释执行 CPU 包含功能单元 Register ： 是CPU内部的高速存储器，像内存一样可以存取数据，速度更快。 程序计数器 保存CPU取指令的地址，CPU读到地址后，按照地址去内存中取指令； 取完本次指令后，指向内存中的下一条指令 是CPU的特殊寄存器 指令解码器 算数逻辑单元 ALU 地址和数据总线 32位处理器有32条地址线和32条数据线 可以表示一个32位的数 设备 CPU除了访问内存外，还要访问很多Device 总线 总线：正因为地址线和数据线上可以挂多个设备和内存芯片所以才叫“总线”,但不同的设备和内存应该占不同的地址范围。 加载：操作系统在执行程序时，从硬盘拷贝到内存，这样CPU才可以取指令执行。 进程：程序加载到内存后，成为操作系统调度执行的一个任务。 中断：为了提供设备发送主动请求。 中断处理的步骤：先判断哪个设备引发的中断，然后调用该设备驱动程序提供中断处理函数。 Linux内核源代码：绝大部分是设备驱动程序。 设备驱动程序：是操作系统内核里的一组函数,主要是通过对设备寄存器的读写实现对设备的初始化、读、写等操作，有些设备还要提供一个中断处理函数供ISR调用。 CPU访问的类别 Memory Device 访问方式 按地址进行读写 按地址进行读写 访问操作 a按地址找到存储单元，进行读写 给设备发一个命令，数据不一定保存 集成在处理器的芯片访问方式 内存映射I/O，端口I/O 数据 只保存数据 产生新的数据 请求 被动等待读和写 主动发送请求 Memory Management Unit虚拟内存管理 VIrtual Memory Management 操作系统需要用VMM ：需要MMU的支持。 物理地址：处理器没有MMU，CPU执行单元发送的内存地址将直接传到芯片引脚，被内存芯片（物理内存）接受。 虚拟地址：CPU发送的内存地址被MMU捕获，从CPU到MMU的地址。 物理地址和虚拟地址 32位的CPU：指CPU的寄存器是32位，数据总线是32位，虚拟地址空间是32位。 物理地址的范围：取决于处理器芯片上的芯片引脚有多少条地址线， 虚拟地址映射带物理地址：MMU进行管理分配，具体细节就不聊了。 MMU 内存保护机制 MMU除了做地址转换（虚拟–物理）之外，还提供内存保护机制。 内存保护机制：操作系统设置的访问权限。 操作系统将虚拟地址空间划分为：用户空间和内核空间。 中断：从用户空间切换到内核空间，处理异常。（用户空间的切换，必须有中断发起） Memory Hierachy 计算机的存储器分为若干等级，按照离CPU的远近依次是： 寄存器，Cache，内存中的数据都是掉电易丢失； 寄存器访问：由程序指令直接控制之外；其他的存储器都不是由指令直接控制的。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu for ESP32]]></title>
    <url>%2F2019%2F03%2F12%2FEsp32%2F</url>
    <content type="text"><![CDATA[ESP-IDF for ESP32前言 通过gcc交叉编译进行开发 Esp32，开发类似于ESP8266，乐鑫官方提供相应的开发教程。 ESP32的SDK的编程指南，ESP-IDF编程指南 开发环境搭建 在Ubuntu下搭建ESP32开发环境 编译依赖工具 ESP32 的编译开发主要依赖两大核心工具，一个是乐鑫官方提供的ESP32交叉编译工具链，另外一个是python2.7。 配置工程，开始编译 有一个Bug，每次都要重新指定，ESPIDF的实际路径 1export IDF_PATH=/home/quronghui/HustFiles/Esp32/sources/esp-idf Arduino IDE for ESP32环境搭建 arduino-esp32 主要是在Arduino IDE 中加载 Esp32 的core; PlatformIO for ESP32环境搭建 VS Code 中加载组件platform。 在Ubuntu下搭建ESP32开发环境 需要搭建以下ubunut下的python2环境 先配置一下，使用platform时便能直接使用 Platform 开发 使用ESP-IDF进行开发 例子的参考 espressif/esp-idf 开发平台比较 在Ubuntu下进行开发 类别 ESP-IDF for ESP32 Arduino IDE for ESP32 PlatformIO for ESP32 环境搭建 有明确的文档 github有说明 直接加载平台就行 编译 编写makefile，指定IDF_PATH 平台操作 平台操作 下载 命令行 平台操作 平台操作 开发难度 目前来说有点难（make指令） 加载库 加载库 开发界面 vs code 不友好 vs code 选择 platformio]]></content>
      <categories>
        <category>Esp32</category>
        <category>Ubuntu Vs Code</category>
      </categories>
      <tags>
        <tag>Esp32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu for Arduino]]></title>
    <url>%2F2019%2F03%2F12%2FArduinoInUbuntu%2F</url>
    <content type="text"><![CDATA[Ubuntu for Arduino 将嵌入式设备的开发从Windows，迁移到了Linux下 Ubuntu + Vs Code + PlatfromIO Port Permission denied 问题：下载程序到arduino时，端口权限报错。 12Auto-detected: /dev/ttyACM0*** [upload] could not open port /dev/ttyACM0: [Errno 13] Permission denied: '/dev/ttyACM0' 重启后权限消失 12给端口权限sudo chmod 666 /dev/ttyACM0 永久权限 12sudo gedit /etc/udev/rules.d/70-ttyacm.rules // 添加权限文件KERNEL=="ttyACM[0-9]*",MODE="0666" // 添加权限文件 串口显示问题 问题：串口一直不能输出 解决：代码错误 1Serial.print("hello\n"); // 不是 printf("")]]></content>
      <categories>
        <category>Arduino</category>
        <category>PlatformIO</category>
      </categories>
      <tags>
        <tag>arduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Operator]]></title>
    <url>%2F2019%2F03%2F12%2FLinuxCoperator%2F</url>
    <content type="text"><![CDATA[LinuxC Operator 主要是介绍位运算符，通过位运算对整数进行操作。 位运算按位与、或、异或、取反 要进行数据类型的转换：Data Type 123unsigned char c = 0xfc;unsigned int i = ~c;result : ffffff03 先进行类型的提升，在进行转换。 移位运算 移位运算符(Bitwise Shift)包括 左移 &lt;&lt; 和 右移 &gt;&gt; 无符号的移位 左移将一个整数的各二进制位全部左移若干位 有符号的移位 不建议使用，减少出错 正数的高位移入0 移位运算中：不同进制数 和 不同的类型之间的区别 不同的进制数：同一个数用不同的方式进行表示 不同的类型：存储一个数所能提供的空间（位） 同一个数在不同的类型转换中，会发生溢出现象 掩码 对一个整数的某些位进行操作 1define ： mask = 0x0000ff00; //(定义一个32的存储类型int)对一个数的8-15位进行操作 其他运算符复合赋值运算符 在赋值的同时做一次运算 对于有 Side Effect 的表达式，影响是不同的。 Sizeof and typedef sizeof 是一个特殊的运算符：sizeof 表达式和 sizeof(类型名) sizeof(表达式)： （表达式）不进行求值计算，将（表达式）类型所占的字节数，作为整个sizeof(表达式)的值 sizeof（表达式）的值 = 是size_t类型的 size_t 类型名 C明确规定：sizeof 的值是无符号整形 1typedef unsigned long size_t; // 为了不同平台，规定size_t的类型 typedef 用于给一个类型取名字 12typedef unsigned long size_t; // size_t是一个类型，代表unsigned long的类型unsigned long size_t; // size_t是一个变量，变量的类型是unsigned long 123typedef char array_t[10];array_t a;// 定义了一个 char类型的 a[10] Side Effect and Sequence Point 造成的后果：结果出现Undefined Side effect : 针对函数调用过程中，先后顺序不确定，造成结果的Undefined. Sequence Point：调用一个函数时,在所有准备工作做完之后、函数调用开始之前。 1foo( f(), g()); //调用函数f(),g()的Side Effect发生的顺序不一定；等所有的Side Effect调用完了，才调用foo() short-circuit : 简写 &amp;&amp; || 的逻辑表达式 12a &amp;&amp; b // &amp;&amp;：a为真才调用b，写成if(a) b; a || b // ||: a为假才调用b, 写成 if(!a) b; Sequence Point 哪些地方是一个Sequence Point（序列点） 一个完整的操作前后都可以称之为Sequence Point； 完整的声明；完整表达式的末尾； “ ； ” 像printf 、scanf 这种带转换说明的输入/输出库函数,在处理完每一个转换说明相关的输/输出操作时是一个Sequence Point。 定义规则 在两个Sequence Point之间,同一个变量的值只允许被改变一次。 如果在两个Sequence Point之间既要读一个变量的值又要改它的值,只有在读写顺序确定的情况下才可以这么写。 错误示例 12int a=0;a = (++a)+(++a)+(++a)+(++a); //对变量a有5次Side Effect 1a[i++] = i; // 变量i的读写顺序不能确定 运算符总结 运算符的规则：也就是优先级 Bug 查错的规则：优先级的先后顺序 算数 &gt; 移位 &gt; 关系 &gt; 相等性 &gt; 按位操作 &gt; 逻辑操作 &gt; 条件运算符 &gt; 赋值 &gt; 逗号]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>LinuxC Operator</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataType]]></title>
    <url>%2F2019%2F03%2F12%2FDataType%2F</url>
    <content type="text"><![CDATA[DataType整形 计算机的最小存储单位：Byte(不是bit) 1 Byte = 8 bits char 占一个 Byte 代码的可移植性 编译器规定 有无符号类型 C 规定的Implementation Defined C语言和平台和编译器密不可分的； ASCII 的取值范围是 0-127 这时候char存储一个ASCII，不必写明signed和unsigned 如果char表示8位的整数 为了可移植性就必须写明是signed还是unsigned 2’s Complement : 表示的是补码 Implementation-defined、Unspecified和Undefined implementation Unspecified C标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中； 这样即使用同一个编译器的不同版本来编译也可能得到不同的结果 因为编译器没有在文档中明确写它会怎么处理,那么不同版本的编译器就可以选择不同的处理方式。 Undefined C标准规定 除了char类型需要表明 signed 和 unsigned 其他整形不明确表明signed 和 unsigned，都表示有符号(-127-128)的数 容易造成访问越界的问题 整形数据需要表明有无符号 C规定用八进制和十六进制常量，代替二进制常量。 除了char是C明确规定占一个字节，其他的几个字节都是implementation 浮点型 float 型通常是32位，double型通常是64位。 浮点型的后缀和类型 double : 没有后缀 float : f / F 的后缀 long double : l / L的后缀 类型转换 C语法中最复杂的一部分 Integer Promotion char，short，Bit-field：提升为整形int表示，或者unsigned int 12unsigned char c1 = 255, c2 = 2;int n = c1 + c2; 最后结果是257，而unsigned char 范围是0-255; 是先把c1 和c2提升为int类型，然后相加得到的 Usual Arithmetic Conversion 两边运算的类型不同，低的类型往高的类型转换 赋值类型的转换 右边的类型转换为左边的类型，在进行赋值 编译器的类型转换处理 规则不用用来记的，而是用来排错误 数据转换最大的问题便是：造成越界或者溢出]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Data Type</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Number Of Computer]]></title>
    <url>%2F2019%2F03%2F12%2FNumberOfComputer%2F</url>
    <content type="text"><![CDATA[Number Of Computer进制间的转换 最高位和最低位 十进制转二进制 除二取余 余数倒着写便是 小数转换 十进制转换为二进制 乘二取整，顺序排列。 整数的加减运算 负数的加减运算 减法运算：取被减数的补码（取反加一） 采用补码做加减运算时总是忽略MSB的进位？、 判断溢出的办法是这样的:在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出,否则就说明产生了溢出。 带符号数和不带符号数 用8个bit既表示正数又表示负数,则能够表示的范围是-128~127, 8个bit全部表示正数,则能够表示的范围是0~255,前者称为有符号数(Signed Number), 后者称为无符号数。 浮点数 数的表示：模型的三部分 符号位 指数部分（表示2的多少次方） 尾数部分（只表示小数点后面的数字）–（需要将有效数字全部移到小数点后面） 尾数部分如何表示？ 尾数的规定 尾数必须以 0.1 开头]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Number of computer</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Stack And Queue]]></title>
    <url>%2F2019%2F03%2F07%2FLinuxCStackAndQueue%2F</url>
    <content type="text"><![CDATA[Code link, Stack and Queue LinuxC Stack And Queue数据结构 数据结构(Data Structure)：是数据的组织方式。 程序中用到的数据都不是孤立的，而是有相互联系的，根据访问数据的需求不同，同样的数据可以有多种不同的组织方式。 把同一类型的数据组织成数组，或者把描述同一对象的各成员组织成结构体。 数据的组织方式 包含：存储方式和访问方式 数组的各元素是一个挨一个存储的，并且每个元素的大小相同，因此数组可以提供按下标访问的方式。 结构体的各成员也是一个挨一个存储的，但是每个成员的大小不同，所以只能用.运算符加成员名来访问,而不能按下标访问。 数据的存储方式和访问方式，决定了解决问题可以采用什么样的算法。 设计相应的数据结构来支持这种算法 [算法+数据结构=程序] Algorithms + Data Structures = Programs. Niklaus Wirth. Link 堆栈概念 堆栈：是一组元素的集合，类似于数组 数组可以按照下标访问元素； 堆栈被限制为Push(入)，Pop(出) 只能访问栈顶元素而不能访问其他元素 所有元素类型相同 堆栈的存储：可以用数组实现 访问操作：通过函数接口提供 数组stack 是堆栈的存储空间 top 用作数组stack 的索引， 注意top总是指向栈顶元素的下一个元素, 可以把它称为指针(Pointer)。 算法设计 代码 Assert 测试 前提条件 ：注意top总是指向栈顶元素的下一个元素 putchar函数的作用是把一个字符打印到屏幕上,和printf的%c作用 队列 Queue概念 队列也是一组元素的集合，也提供两种基本操作: Enqueue(入队)将元素添加到队尾 Dequeue(出队)从队头取出元素并返回。 FIFO(First In First Out,先进先出) 队列的索引 变量head、tail 就像前两节用来表示栈顶的top一样 是queue数组的索引或者叫指针,分别指向队头和队尾。 每个点的predecessor成员也是一个指针,指向它的前趋在queue数组中的位置。 算法设计 1234* (1) 广度优先是一种步步为营的策略,每次都从各个方向探索一步,将前线推进一步,* (2) 队列中的元素总是由前线的点组成的* (3) 广度优先搜索还有一个特点是可以找到从起点到终点的最短路径* (4)而深度优先搜索找到的不一定是最短路径 堆栈 VS 队列 堆栈 栈操作的top指针在Push（入）时增大 Pop（出）时减小 栈空间是可以重复利用的 队列 队列的head、tail指针都在一直增大； 虽然前面的元素已经出队了,但它所占的存储空间却不能重复利用 为了解决队列的问题 引入环形队列 从head到tail之间是队列的有效元素,从tail到head之间是空的存储位置, head追上tail就表示队列空了；tail追上head就表示队列的存储空间满了。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Stack And Queue</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Assert]]></title>
    <url>%2F2019%2F03%2F07%2FLinuxCAssert%2F</url>
    <content type="text"><![CDATA[LinuxC AssertAssert Code Precondition : 代码的前提条件的测试； Maintenance：代码主要功能函数的测试； Postcondition：代码结果是否超过范围的测试 测试函数：简单的代码方式测试，主要是测试条件/结果是否为真 Shut Assert 测试代码只在开发和调试时有用，如果已经发布(Release)的软件还要运行这些测试代码就会严重影响性能了。 所以C语言规定,如果在包含assert.h 之前定义一个NDEBUG宏(表示NoDebug) 就可以禁用assert.h中的assert宏定义，代码中的assert就不起任何作用了: Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 折半查找* 项目1介绍：* (1)折半查找的前提是数组已经排序好；* （2）提供assert代码测试的思想*/#define NDEBUG /* 取消assert代码的相关测试 */#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#define LEN 8int a[LEN] = &#123;1, 3, 3, 3, 9, 5, 6, 7&#125;;int is_sorted()&#123; int i, sorted = 1; for (i = 1; i &lt; LEN; i++) sorted = sorted &amp;&amp; a[i-1] &lt;= a[i]; /* 保证序列是一个排序好的 */ return sorted;&#125;int mustbe(int start, int end, int number)&#123; int i; for (i = 0; i &lt; LEN; i++)&#123; if (i &gt;= start &amp;&amp; i &lt;= end) continue; if (a[i] == number) return 0; &#125; return 1;&#125;int binarysearch(int number)&#123; int mid, start = 0, end = LEN - 1; assert(is_sorted()); /* Precondition 前提条件测试 */ while(start &lt;= end)&#123; assert(mustbe(start, end, number)); /* Maintenance 主要函数测试 */ mid = (start + end) / 2; if(a[mid] &lt; number) start = mid + 1; else if (a[mid] &gt; number) end = mid - 1; else return mid; &#125; assert(mustbe(start, end, number)); /* Postcondition 测试最终的结果*/ return -1; &#125;int main(void)&#123; printf("where the element %d\n", binarysearch(3)); return 0;&#125;]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Assert</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Order And Finding]]></title>
    <url>%2F2019%2F03%2F06%2FOrderAndFind%2F</url>
    <content type="text"><![CDATA[LinuxC Order And Finding Order code [order files] 算法的概念 算法（algorithm） 将一组输入转化成一组输出的一系列计算步骤,其中每个步骤必须能在有限时间内完成。 用来解决一类计算问题的，而不是一个特定的问题 。 最有解和正确算法 对于某个问题求解最优算法很困难，但是某个不正确的算法可以再有限时间内终止，将误差控制在一定范围内； 这样的算法也是有意义的。 插入排序 理解循环结构体的算法 满足三条准则，便是 Loop Invariant 递归和循环 等价 和证明递归程序的思想一样 第一条便是递归的 Base Case 第二条便是递归的递推关系。 时间复杂度 分析算法的时间复杂度 最坏情况和平均情况的复杂度都是 O(n^2) 时间复杂度有小到大排序 归并排序 区别： 插入排序策略：每次添加一个到已排序的子序列中，时间复杂度是 O(n^2) 归并排序：将时间复杂度降到 O(nlgn)。 递归的思想看代码 递归：如果定义一个概念（函数），需要用到概念（函数）本身，则称之为递归 Gdb: 展开的方式看递归（这样很笨） – 单步加断点的方式调试程序的每步结果。 捉住 Base Case 和 递推关系来理解，不能展开来看，这样就很乱了。 时间复杂度计算 设计不同时间复杂度的算法 这个就是算法的初步体现 通过不同的数据结构，体现算法的效能 折半查找 折半查找提供了一种代码测试的思想 assert.h 函数进行测试]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Order</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Gdb]]></title>
    <url>%2F2019%2F03%2F04%2FLinuxCGdb%2F</url>
    <content type="text"><![CDATA[LinuxC Gdb Code link – Gdb的相关代码 Gdb调试方式 程序中除了一目了然的Bug之外都需要一定的调试手段来分析到底错在哪 根据程序执行时的出错现象假设错误原因,然后在代码中适当的位置插入printf , 强大的调试工具gdb,可以完全操控程序的运行。 调试思想 分析现象 –&gt; 假设错误原因 –&gt; 产生新的现象去验证假设 单步执行和跟踪函数调用开始调试 gdb -g 编译 123456/** -g选项的作用是在目标文件中加入源代码的信息,比如目标文件中第几条机器指令对应源代码的第几行；* 但并不是把整个源文件嵌入到目标文件中,所以在调试时目标文件时必须保证gdb也能找到源文件。*/$ gcc -g main.cpp -o main -Wall $ gdb main gdb 命令help 12$ (gdb)help // gdb提供一个类似shell下输入help,可以查看命令的类别:$ (gdb)help files // 可以进一步查看某一类别中有哪些命令,例如查看files类别下有哪些命令可以用 列出源码 123$(gdb) list 1 //从第一行开始列出源代码，一次只能10行$(gdb) 回车 // 重复上一条命令$(gdb) l add_range // list命令可以用 l 来表示，列出一个函数的源代码 gdb quit 退出Gdb 调试环境 单步调试 next 主函数的调试 1234$ gdb main$ (gdb) start //开始执行程序$ (gdb) next //控制主函数的语句，一条条的执行（enter--重复上次命令）// 错误不在main()函数，而在功能函数里面 step 功能函数的调试 1234$ (gdb) start //开始执行程序$ (gdb) step //进入函数中执行$ (gdb) bt(backtrace) //查看函数调用的栈针$ (gdb) i locals // 查看功能函数，局部变量的值； main函数传进来的参数； main函数的栈帧编号为1，功能函数add_range 的栈帧编号为0 123456789101112zhi/*查看 main函数当前的局部变量的值*/$ (gdb) f(frame) 1 //选择1号栈帧，然后在查看局部变量$ (gdb) i locals // 查看主函数，局部变量的值；/*在step,跟几步看看*/$ (gdb) step //除了主函数，还有其他功能函数的值$ (gdb) finish //finish 一直运行到当前函数返回为止,得出当前的结果$ (gdb) p result //查看数组result的值，相当于print/*修改变量值，看还有没有其他bug*/$ (gdb) set var sum=0 //修改变量的值$ (gdb) finish 调试命令{% asset_img GdbCommand.png 调试命令汇总 %} 总结 i locals 查看当前的局部变量，这个是最有用的。 查询功能函数的变量是否初始化。 通过条件语句来设置终端，这个挺好用的。 step 和 next 区别 step 用于调到功能函数； next 在调到功能函数的时候，单步执行 断点字符型和整形 字符型转化为整形： 整形＝字符型 － ‘０’的ASCII值 ASCII码值：’0’＝48; ‘\0’ = 0 断点加单步 单词断点流程 12345678$ gcc -g main.c -o main$ gbd main$ display sum //我们可以用display命令使得每次停下来的时候都显示当前sum值 //每输入一次print sum ; 打印一次当前的sum值，$ break 9 //break命令的参数也可以是函数名,(在第９行设置一个断点)$ continue //连续运行而非单步运行,程序到达断点会自动停下来,这样就可以停在下一次循环的开头。$ next //单步调试，深入内容 多个断点的设置 123456$ break 12 //设置另外一个断点$ i breakpoints //一次调试可以设置多个断点,用info命令可以查看已经设置的断点$ delete breakpoints 1 //删除编号为１的断点$ disable breakpoints 1 //通过禁用，而不用删除$ enable breakpoints 1 //enable 启用断点１ 条件断点 123$ break 9 if sum != 0 //在循环开头设置断点,但是仅当sum不等于0时才中断$ run //然后用run命令,重新从程序开头连续执行:$ continue //连续执行到断点的时候停止 调试Bug Bug: 数组的末位含有一个 ‘\0’字符，printf打印的时候遇到’\0’就停止打印。 观察点 调试代码Breakpoint.cpp的代码一；数组越界的问题 代码逻辑 1234$ watch input[5] //设置input[5]为观察点$ info watchpoints //查看当前设置的观察点$ x/7b input //打印数组input才存储器的内容 //打印的是字符对应的十六进制ASCII的值 段错误 文章一直在强调，“scanf”函数是一个十分凶险的函数； 用户输入的值是不确定的； 造成数组的越界；’\0’的越界 造成段错误: Segmentation fault 运行逻辑 12$ run //运行代码，当出现错误的时候会自动停止运行$ bt //查看那个函数调用产生的错误 反汇编C和汇编穿插显示12gcc -g main.c -o main -Wall // 生成可执行文件objdump -dS main // 把C代码和汇编代码穿插起来显示 只生成汇编1gcc -S main.c //只生成汇编代码main.s,而不生成二进制的目标文件。 汇编调试12345(gdb) disassemble //可以反汇编当前函数或者指定的函数(gdb) si //step 命令可以一行代码一行代码地单步调试,而这里用到的si命令可以一条指令一条指令地单步调试。(gdb) info registers //可以显示所有寄存器的当前值。(gdb) p $esp //打印esp寄存器的值,// 在上例中esp 寄存器的值是0xbff1c3f4,所以x/20 $esp 命令查看内存中从0xbff1c3f4地址开始的20个32位数。 总结 学C语言不可能不去了解底层计算机体系结构和操作系统的原理，不了解底层原理连一个scanf函数都没办法用好，更没有办法保证写出正确的程序。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Gdb</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Coding Style]]></title>
    <url>%2F2019%2F03%2F04%2FLinuxCCodingStyle%2F</url>
    <content type="text"><![CDATA[LinuxC Coding Style Linux kernel Coding Style Thus, programs must be written for people to read, and only incidentally for machines to execute. 缩进和空白 双目运算符的两侧插入一个空格分隔,单目运算符和操作数之间不加空格, 1i = i + 1、++i 、!(i &lt; 1)、-x、&amp;a[1] ... ‘, ‘ 号和 ‘;’ 号之后要加空格, 这是英文的书写习惯 1for (i = 1; i &lt; 10; i++) 、foo(arg1, arg2) ... switch 的语句块 注释 顶头源文件的注释 整个源文件的顶部注释。说明此模块的相关信息,例如文件名、作者和版本历史等,顶头写不缩进。例如内核源代码kernel/sched.c的开头: 相对独立的语句注释 用 / hello / 注释尽量少用 标识符命名 .小写 内核风格规定变量、函数和类型采用全小写 加下划线的方式命名, 1上面举例的函数名radix_tree_insert、类型名struct radix_tree_root 大写 常量(宏定义和枚举常量enum)采用全大写加下划线的方式命名。 1常量名RADIX_TREE_MAP_SHIFT 全局变量和全局函数命名 全局变量和全局函数的命名一定要详细,不惜多用几个单词多写几个下划线 因为它们在整个项目的许多源文件中都会用到,必须让使用者明确这个变量或函数是干什么用的。 函数 执行函数： 执行函数就是执行一个动作,函数名通常应包含动词,例 如get_current、radix_tree_insert。 分割函数 多个.c的文件 功能函数 C语言中的功能函数包含动词 字母加下划线的方式进行。void insertion_sort() Indent Tools Indent Tools 将代码格式化为某种风格 12indent -kr -i8 main.c /* -kr 表示K&amp;R 的风格；-i8 表示TAB键缩进8个空格的长度 */cat main.c]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Array]]></title>
    <url>%2F2019%2F03%2F04%2FLinuxCArray%2F</url>
    <content type="text"><![CDATA[LinuxC ArrayCode link – Array 的相关代码 数组的基本操作 数组的定义和赋值 Bug 数组不可以相互赋值。 12int a[10], b[10];a = b; //这种赋值是错误的 也不能用数组类型作为函数的参数或者返回值，用的是指针传参。 数组应用 随机数的概念: 计算机执行每一条指令的结果都是确定的,没有一条指令产生的是随机数,调用C标准库。 得到的随机数其实是伪随机(Pseudorandom)数,是用数学公式算出来的确定的数,只不过这些数看起来很随机,并且从统计意义上也很接近均匀分布(Uniform Distribution)的随机数。 123$ int x = rand() % upper_bound; // upper_bound 表示生成的随机数的最大上边界// 以后定义随机数的上边界最大值是多少 编译器的工作原理 先是预处理 Preprocess; 然后才是 编译。编译的作用：翻译高级语言为可执行的二进制语言。 1gcc -E main.c 预处理 CPP C preprocessor 像 #include 和 #define 以#号开头的与法院诉称为预处理指示 C 标准库允许我们指定初值 1srand(time(NULL)); //srand 函数指定一个seed,调用当前系统时间距离1970年1月1日00:00:00的秒钟数，然后传给srand. 字符串 字符串可以看作一个数组,它的元素是字符型的。 字符串的打印和数组的打印不同。 字符串的最后一位，必须包含一个 ‘\0’ 这里的’ ‘\0’ 是ASCII码的八进制表示. 12char str[] = "hello,world.\n";printf("string: %s \n", str); Bug printf会从数组str 的开头一直打印到’\0’字符为止(‘\0’本身不打印)。 这其实是一个危险的信号:如果数组str 中没有’\0’,那么printf就会打印出界,后果和前面讲的数组访问越界一样诡异:有时候打印出乱码,有时候看起来没错误,有时候引起程序崩溃。 多维数组 多维数组 类似于结构体的嵌套； 一个数组的元素可以是另外一个数组 多维字符数组 通过下标访问字符串组成的数组可以代替一堆case分支判断,这样就可以把每个case 里重复的代码(printf 调用)提取出来,从而又一次达到了“提取公因式”的效果。 这种方法称为数据驱动的编程(Data-driven Programming): 写代码最重要的是选择正确的数据结构来组织信息,设计控制流程和算法尚在其次,只要数据结构选择得正确,其它代码自然而然就变得容易理解和维护了]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vsiual Studio]]></title>
    <url>%2F2019%2F03%2F01%2FVisiualStudio%2F</url>
    <content type="text"><![CDATA[Visual Studio 2017 for User快捷键的使用多行注释12注释多行：先按 Ctrl - K 组合键，再按 Ctrl - C 组合键取消注释多行：先按 Ctrl - K 组合键，再按 Ctrl - U 组合键]]></content>
      <categories>
        <category>Visiual Studio</category>
      </categories>
      <tags>
        <tag>Vs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QtAndVs]]></title>
    <url>%2F2019%2F03%2F01%2FQtAndVs%2F</url>
    <content type="text"><![CDATA[Qt and Visiual Studio 通过创建Qt GUI 的程序，实现按键的点击和事件的响应。 安装Qt并且关联Vs Vs 创建Qt 工程 创建例程 Qt Gui 文件的类型介绍。 （1）是Qt设计师文件，双击可以打开Qt可视化设计 （2）Qt界面的代码文件，Qt设计师设计的界面以代码的形式存储在这里，比如Button的位置，大小，名字。 （3）Widget类的头文件，定义一些字段和函数声明，包括最重要的slots（槽）函数的声明，以及界面ui句柄，以便通过“ui.***”的方式访问到界面的各个控件，比如访问界面的Label控件里的文字可以这样：ui.label-&gt;text();就是字面意思，很容易理解。 （4）资源文件，相当于AndroidStudio里面的rcs文件夹，里面存放需要用到的.ico图标或者图片。 （5）主函数文件，程序的入口，不必解释，其实一般不会在这个里面修改什么。 （6）Widget类完成的主要文件，在widget.h里面定义之后的字段以及函数声明，以及槽的实现，都是在这里，Qt的逻辑功能设计主要是修改这个文件。 添加事件发现的函数 – 槽函数 发生事件的方式（Click()） 槽函数：接收函数 他们之间的连接 1234567891011Widget::Widget(QWidget *parent) : QWidget(parent)&#123; ui.setupUi(this); connect(ui.checkBox,SIGNAL(clicked()),this,SLOT(on_checkBox_clicked())); connect(ui.checkBox_2, SIGNAL(clicked()), this, SLOT(on_checkBox_2_clicked())); connect(ui.pushButton, SIGNAL(clicked()), this, SLOT(on_pushButton_clicked()));&#125;// ui.checkBox : ui控件// SIGNAL(clicked()) : 发生事件的方式（Click()）// SLOT(on_checkBox_clicked()))：槽函数，响应事件的方式 Qt Gui 窗口大小 Qt Gui窗口大小的设置方式 1this-&gt;setWindowState(Qt::WindowMaximized); Vs and Qt 实现语音功能 Qt to speech 问题 无法打开QtTextToSpeech文件 在VC++ 中添加目录 1C:\Qt\Qt5.12.1\5.12.1\msvc2017_64\include\QtTextToSpeech 出现LNK2019 首先添加Qt的依赖库 和 lib文件目录 然后根据错误定位到QVoice，添加相关的头文件 不允许定义静态数据成员 dllimport 12代码使用：Qt 官方代码Qt使用导出类报错：error C2491: “QTextToSpeech::staticMetaObject”: 不允许 dllimport 静态数据成员 的定义:]]></content>
      <categories>
        <category>Qt Ui</category>
        <category>Visiual Studio</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect Sdk SkeletonStream]]></title>
    <url>%2F2019%2F03%2F01%2FKinectSdkSkeletonStream%2F</url>
    <content type="text"><![CDATA[Kinect Sdk SkeletonStream 网上的知识点 骨骼追踪技术通过处理景深数据来建立人体各个关节的坐标,骨骼追踪能够确定人体的各个部分。 骨骼追踪产生X,Y,Z的三维数据，从而确定这些骨骼点的坐标。 Gain Skeleton Data 骨骼数据来自：SkeletonStream KinectSensor对象有一个名为SkeletonFrameReady事件。 当SkeletonStream中有新的骨骼数据产生时就会触发该事件。 SkeletonStream产生的每一帧数据Frame，都是一个骨骼对象集合。 Kinect SDK在SkeletonStream对象 Kinect能够追踪到的骨骼数量是一个常量。 定义了一个能够追踪到的骨骼个数常量FrameSkeletonArrayLength，使用这个常量可以方便的对数组进行初始化。 SkeletonFrameReady事件的响应方法 每一次事件被激发时，通过调用事件参数的OpenSkeletonFrame方法就能够获取当前的骨骼数据帧。 剩余的代码遍历骨骼数据帧的Skeleton数组frameSkeletons，在UI界面通过关节点将骨骼连接起来，用一条直线代表一根骨骼。 骨骼数据的检测 使用Skeleton对象的 TrackingState 属性来判断，只有骨骼追踪引擎追踪到的骨骼我们才进行绘制。 Kinect能够探测到6个游戏者，但是同时只能够追踪到2个游戏者的骨骼关节位置信息。、、 绘制骨骼直线 CreateFigure方法为每一根骨骼绘制一条直线。 GetJointPoint方法以关节点的三维坐标作为参数，然后调用 KinectSensor 对象的MapSkeletonPointToDepth 方法将骨骼坐标转换到 深度影像坐标上去。 骨骼坐标系和深度坐标及彩色影像坐标系不一样，甚至和UI界面上的坐标系不一样。 三维数据处理 骨骼关节点的三维坐标中我们舍弃了Z值，只用了X,Y值。 可以发现图像的大小是和Z值(深度)成反的。深度值越小，图像越大，即人物离Kinect越近，骨骼数据越大。 Skeleton 对象模型 对象模型有四个最主要的对象，他们是SkeletonStream，SkeletonFrame，Skeleton和Joint。 SkeletonStream对象 Enable SkeletonStream对象，才能产生数据SkeletonFrame。 骨骼数据处理是很耗费计算性能的操作。打开骨骼追踪是可以观察的到CPU的占用率明显增加。当不需要骨骼数据时，关闭骨骼追踪很有必要。 骨骼关节点帧与帧之间的位置差异。 Enable SkeletonStream对象时，调用重载的方法传入一个TransformSmoothParameters参数。 SkeletonStream对象有两个与平滑有关只读属性：IsSmoothingEnabled和SmoothParameters。 SmoothParameters属性用来存储定义平滑参数。 骨骼追踪对象选择 默认情况下，骨骼追踪引擎会对视野内的所有活动的游戏者进行追踪。但只会选择两个可能的游戏者产生骨骼数据。 如果要自己选择追踪对象，需要使用AppChoosesSkeletons属性和ChooseSkeletons方法。 要手动选择追踪者，需要将AppChoosesSkeleton设置为true，并调用ChooseSkeletons方法，传入TrackingIDs已表明需要追踪那个对象。 SkeletonFrame SkeletonStream产生SkeletonFrame对象,使用事件模型从事件参数中调用OpenSkeletonFrame方法来获取SkeletonFrame对象. 调用SkeletonFrame 对象的 CopySkeletonDataTo方法将其保存的数据拷贝到骨骼对象数组. SkeletonFrame对象有一个SkeletonArrayLength的属性，这个属性表示追踪到的骨骼信息的个数。 时间标记字段 SkeletonFrame的FrameNumber和Timestamp字段表示当前记录中的帧序列信息。 FrameNumber和Timestamp这两个字段在分析处理帧序列数据时很重要 FrameNumber 是景深数据帧中的用来产生骨骼数据帧的帧编号。帧编号通常是不连续的，但是之后的帧编号一定比之前的要大。 FrameNumber是一个32位的整型 Timestap字段记录字Kinect传感器初始化以来经过的累计毫秒时间。 imestamp是64位整型 在未来SDK中加入手势引擎之前，我们需要自己编写算法来对帧时间序列进行处理来识别手势，这样就会大量依赖这两个字段。 Frame 描述信息 FloorClipPlane字段是一个有四个元素的元组Tuple&lt;int,int,int,int&gt;，每一个都是Ax+By+Cz+D=0地面平面(floor plane)表达式里面的系数项。 D 通常为负数，是Kinect距离地面高度。 Skeleton Skeleton类定义了一系列字段来描述骨骼信息，包括描述骨骼的位置以及骨骼中关节可能的位置信息。 骨骼数据可以通过调用SkeletonFrame对象的CopySkeletonDataTo方法获得Skeleton数组。 TrackingID 骨骼追踪引擎对于每一个追踪到的游戏者的骨骼信息都有一个唯一编号。 应用程序使用TrackingID来指定需要骨骼追踪引擎追踪那个游戏者。 这个值是整型，他会随着新的追踪到的游戏者的产生添加增长。(不连续的) Kinect追踪到了一个新的游戏者，他会为其分配一个新的唯一编号。 编号值为0表示这个骨骼信息不是游戏者的，他在集合中仅仅是一个占位符。 调用SkeletonStream对象的ChooseSkeleton能以初始化对指定游戏者的追踪。 TrackingState 该字段表示当前的骨骼数据的状态。 Position Position一个SkeletonPoint类型的字段，代表所有骨骼的中间点。 该字段提供了一个最快且最简单的所有视野范围内的游戏者位置的信息，而不管其是否在追踪状态中。 例如，应用程序可能需要追踪距离Kinect最近的且处于追踪状态的游戏者，那么该字段就可以用来过滤掉其他的游戏者。 ClippedEdges ClippedEdges字段用来描述追踪者的身体哪部分位于Kinect的视野范围外，提供了一个追踪这的位置信息。 该字段类型为FrameEdges，他是一个枚举并且有一个FlagsAtrribute自定义属性修饰。 FrameEdges 值 Kinect底座上面有一个小的马达能够调整Kinect的俯仰角度。 俯仰角度可以通过更改KinectSensor对象的ElevationAnagle属性来进行调整。 如果应用程序对于游戏者脚部动作比较关注，那么通过程序调整Kinect的俯仰角能够决绝脚部超出视场下界的情况。 KinectSensor的MaxElevationAngle和MinElevationAngle确定了可以调整角度的上下界。 任何将ElevationAngle设置超出上下界的操作将会掏出ArgumentOutOfRangeExcepthion异常。 微软建议不要过于频繁重复的调整俯仰角以免损坏马达。 Joints 该字段是一个JointsCollection类型，它存储了一些列的Joint结构来描述骨骼中可追踪的关节点(如head,hands,elbow等等) 应用程序使用JointsCollection索引获取特定的关节点，并通过节点的JointType枚举来过滤指定的关节点。 骨骼追踪引擎能够跟踪和获取每个用户的近20个点或者关节点信息。 关节点 都有类型为SkeletonPoint的Position属性， 他通过X,Y,Z三个值来描述关节点的控件位置。 X,Y值是相对于骨骼平面空间的位置，他和深度影像，彩色影像的空间坐标系不一样。 最后每一个Skeleton对象还有一个JointTrackingState属性]]></content>
      <categories>
        <category>Kinect SDK</category>
        <category>Kinect</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BluetoothANT]]></title>
    <url>%2F2019%2F02%2F28%2FBluetoothANT%2F</url>
    <content type="text"><![CDATA[Bluetooth ANT 蓝牙天线的设计使用，需要注意的一些事情。 无线传感技术 蓝牙技术：要求通讯灵敏度，还需要小型化，更需要低功耗，更重要的是要低成本。 硬件天线设计：IPEX接口外接天线和PCB板载天线。 天线 天线是一种用来发射或者接收电磁波的元器件，本质上可以说是一个能量转换器。 发射天线：将发射机的高频电流能量，有效地转换成空间的电磁能量； 接收天线：将空间中的电磁能量，转化为电流能量。 IPEX接口天线​ 信号的方向指向性好，效率高，抗干扰能力强; 能远离主板上的干扰 不用过多的进行调试匹配 PCB板载天线 PCB天线容易受到主板上的干扰，效率相对较低，牺牲性能。 因为近距离数据传输本身就比较稳定，所以蓝牙模块上的天线其实在近处时的效果是差不多的。但是距离远了，外置天线会有明显的优势。 倒F型天线 特点 状或者片状，当使用介电常数较高的绝缘材料时还可以缩小蓝牙天线尺寸 天线一般放置在PCB顶层，铺地一般放在顶层并位于天线附近，但天线周围务必不能放置地，周围应是净空区。 具体尺寸 曲流型天线设计 曲流型天线的长度比较难确定。长度一般比四分之一波长稍长，其长度由其几何拓扑空间及敷地区决定。 天线一般放置在PCB顶层，铺地一般放在顶层并位于天线附近，但天线周围务必不能放置地，周围应是净空区。 具体尺寸 陶瓷天线设计 陶瓷天线是另外一种适合于蓝牙装置使用的小型化天线。 陶瓷本身介电常数较PCB电路板高，所以使用陶瓷天线能有效缩小天线尺寸，在介电损耗方面，陶瓷介质也比PCB电路板的介电损失小，所以非常适合低耗电率的的蓝牙模块中使用。 在 PCB设计时，天线周围要净空就可以了，特别注意不能敷铜。 2.4G棒状天线设计 2.4G棒状蓝牙天线体积大，但传输距离要强于其他天线。在PCB设计时，天线周围也和上述的三种天线设计一样要净空。 蓝牙天线设计 天线的信号（频率大于400MHz以上）容易受到衰减，因此天线与附近的地的距离至少要大于三倍的线宽。 1GHz=1000MHz 1MHz=1000kHz 1kHz=1000Hz 过孔会产生寄生电感，高频信号对此会产生非常大的衰减，所以走射频线的时候尽量不要有过孔。 PCB 布线问题ANT 和 GND 相连 出现一种现象：RF射频线和GND相连报错。 因为这是RF信号，也就是微波。微波就不能当一般的数字，模拟信号来对待了。虽然用万用表量，这个天线与地是短路的。而对微波，其实这整个天线铜皮其实是相当于包括了很多电阻，电容，电感等组成的等效电路。 · ANT 天线没有盖油 如何查看是否盖油 Altium Design – &gt; 只显示 Top Sloder / Bottom Sloder 原因：CC2540 的元件，绘制的时候加了 top sloder 层，导致PCB生成Gerber文件的时候默认为开窗 如何解决： 找到对应天线的元件库，删除top sloder绘制的Track]]></content>
      <categories>
        <category>Bluetooth ANT</category>
      </categories>
      <tags>
        <tag>ANT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows SDK]]></title>
    <url>%2F2019%2F02%2F28%2FWindowsSDK%2F</url>
    <content type="text"><![CDATA[Windows SDK 参考的csdn上相关的知识 了解一些关于SDK开发的一些相关的知识 Windows程序分类 Windows控制台程序 C语言编写第一个“hello world”时，当时的程序就是控制台程序。 他的本质是DOS程序，没有自己的窗口， 你看到的输出Hello world的窗口是程序本身借用了操作系统的DOS窗口 windows窗口程序 123456int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) &#123;...&#125; // APIENTRY wWinMain windos窗口程序的入口 动态链接库dll 12345BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123;...&#125; Visual studio 下的工具 所在目录：C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin 1). 编译器 CL.exe ：将源代码翻译成目标代码。 2). 连接器 LINK.exe : 将目标代码、库连接生成最终文件。 3). 资源编译器RC.exe : 将资源编译，最终通过连接器存入最终文件 Visual studio 下的 lib 库 Kernel32. dll : 提供了线程、进程、内存管理等核心的API user32.dll : 提供了窗口、消息等API gdi32.dll : 提供了绘图的API]]></content>
      <categories>
        <category>Windows SDK</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Struct]]></title>
    <url>%2F2019%2F02%2F27%2FStruct%2F</url>
    <content type="text"><![CDATA[Code link – struct 的相关代码 LinuxC Struct 学习一门语言要注意的三点 本节将以结构体为例来讲解数据类型的组合和抽象。 结构体 代码链接 结构体定义 过程抽象：将一组语句通过函数名封装Tag，当做整体调用 结构体 12345结构体：complex_struct不表示变量，而是表示类型,类似于int的符合类型 struct complex_struct &#123; double x, y; /* data */ &#125;z; 结构体的变量使用 12345678910结构体变量的初始化和使用（1）Ways1 double x = 3.0; // 不等同于Tag的z.x； z.x = x; // 变量访问成员，通过z.x z.y = 4.0; (2) Ways:定义的时候直接初始化 struct complex_struct z = &#123; 3.0, 4.0 &#125;; (3)错误的初始化 struct complex_struct z1; z1 = &#123; 3.0, 4.0 &#125;; 结构体当做函数的参数使用 123456789103. 项目描述：将结构体当做函数的参数和返回值来传递（1）结构体当做函数的参数，比如 int main,中的int(2) struct complex_struct 当做函数 add_complex的参数struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2)&#123; z1.x = z1.x + z2.x; z1.y = z1.y + z2.y; return z1; &#125; Data Abstraction (数据抽象) ​ gcc编译时提示对‘sqrt’未定义的引用 1gcc -*.c -lm // 需要链接 libm.so 库 将复数运算的代码分成块的时候，报错 代码还没有解决。DataAbstraction.cpp ​ 解决成功 123456为了避免其他文件引用DataAbstraction.h，造成重复定义的问题： add code: #ifndef _TEST_H_ #define _TEST_H_ &#123; ... &#125; #endif 数据类型的标志 也就是设立 flag （0/1）标志位 Enum 标志位 12345// 枚举类型：枚举类型的成员和变量名在同一个空间，不能定义成同样的名字。enum coordinate_type // 类似于Struct的Tag,enum代表的是枚举类型&#123; // 代表常量Rectangular（直角坐标） == 0 ； Rectangular, Polar // 代表常量Polar(极坐标) == 1&#125;; 还没有实现如何结合struct Tag 一起使用 Enum 可以实现递增赋值的Tag 1enum Month &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a,b; 结构体的嵌套 结构体有数据类型定义，结构体本身便是一种数据类型，可以进行嵌套。 1234567struct Segment&#123; struct complex_struct start; struct complex_struct end;&#125;;struct complex_struct&#123; double x,y;&#125;; 访问结构体的成员应该用多个 . 运算符 12s.start.x = 1.0;s.start.y = 2.0;]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kinect SDK for DepthImageStream]]></title>
    <url>%2F2019%2F02%2F27%2FKinectSDKDepthImageStream%2F</url>
    <content type="text"><![CDATA[Kinect SDK for DepthImageStream 网上的知识点 KinectSensor的最主要功能之一就是能够产生三维数据，它有红外发射器和红外摄像头。 介绍了Kinect红外传感器，景深数据格式，景深图像的获取与展示，景深图像的增强处理 ColorImageStream 数据流的获取 DepthImageStream和ColorImageStream都继承自ImageStream 景深影像数据从DepthImageFrame产生，它由DepthImageStream对象提供 景深帧数据 红外摄像机的视场是金字塔形状的。离摄像机远的物体比近的物体拥有更大的视场横截面积。这意味着影像的高度和宽度，比如640X480和摄像机视场的物理位置并不一一对应。 深度帧数据中，每个像素占16位，这样BytesPerPixel属性，即每一个像素占2个字节。每一个像素的深度值只占用了16个位中的13个位。 ​ 深度值存储在第3至15位中，要获取能够直接使用的深度数据需要向右移位 SDK在DepthImageFrame类中定义了一个常量PlayerIndexBitmaskWidth，它定义了要获取深度数据值需要向右移动的位数。 UI界面显示 在UI界面中Image空间的属性中，宽度和高度是硬编码的。如果不设置值，那么空间会随着父容器（From窗体）的大小进行缩放，如果空间的长宽尺寸和深度数据帧的尺寸不一致，当鼠标点击图片时，代码就会返回错误的数据，在某些情况下甚至会抛出异常。 景深图像处理增强灰度级 增强深度值图像： 按位翻转像素值。 图像的颜色是基于深度值的，他们从0开始。在数字光谱中0表示黑色，65536(16位灰阶)表示白色。 所有的不能确定深度值的数据都设置为了0 增强深度值图像 格式的转换 彩色影像的格式为了Bgr32位，每一个R,G,B分别占8位，剩余8位留用 这种模式限制了RGB的取值为0-255，所以需要将深度值转换到这一个范围内。 将深度值除以4095（13位的深度值，[2^13 -1] / 2），然后乘以255，这样就可以将深度数据转换到0至255之间了. 数据的处理 每一次当KinectSensor触发frame-ready事件时，代码顺序存储彩色影像。转换完成后，backgroud线程使用WPF中的Dispatcher来更新UI线程中Image对象的数据源。 这种异步的操作在基于Kinect开发的应用中很常见，因为获取深度数据是一个很频繁的操作。如果将获取数据以及对数据进行处理放在主UI线程中就会使得程序变得很慢。 景深数据处理 Kinect深度值最大为4096mm，0值通常表示深度值不能确定，一般应该将0值过滤掉。微软建议在开发中使用[1220mm（4’）~3810（12.5’)范围内的值。在进行其他深度图像处理之前，应该使用阈值方法过滤深度数据至1220mm-3810mm这一范围内。 可以绘制直方图 Opencv 处理景深数据处理 基于Kinect的应用程序不会对深度数据进行很多处理。如果要处理数据，也应该使用一些类库诸如OpenCV库来处理这些数据。 应用程序处理深度数据目的是用来确定人体在Kinect 视场中的位置。 对物体进行测量 c# 例子代码参考 每一个摄像机都有视场，焦距的长度和相机传感器的大小决定了视场角。Kinect中相机的水平和垂直视场角分别为57°和43°。 知道了底边的长度，我们就可以将像素的宽度转换为现实中的宽度。 1234（1）计算出等腰三角形底边的宽度为1500mm；（2）游戏者所占有的总象元的宽度为100；（3）深度影像数据的总象元宽度为320；实际宽度：（1500 / 320）*100 = 468.75mm 实现方式 1）先创建一个新的项目然后编写发现和初始化KinectSensor的代码，将DepthStream和SkeletonStream均初始化，然后注册KinectSnsor的DepthFrameReady事件。 2）CalculatePlayerSize方法遍历深度图像中的象元，然后提取游戏者索引位及其对应的深度值。 3）对于游戏者的每一个象元，方法调用PlayerDepthData对象的UpdateData方法。处理完所有象元之后，将游戏者数组复制给名为PlayerDepthData的ItemControl对象的数据源。 本文首先介绍了关于景深数据的简单图像数据，包括景深数据的直方图显示以及一些图像处理相关的算法，然后介绍了景深数据中的游戏者索引位，借助索引位，我们实现了人物宽度和高度的计算，最后借助景深数据结合彩色影像数据，将景深影像和视频图像进行了叠加。]]></content>
      <categories>
        <category>Kinect SDK</category>
        <category>Kinect</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect Sensor]]></title>
    <url>%2F2019%2F02%2F27%2FKinectSensor%2F</url>
    <content type="text"><![CDATA[Kinect Sensor 网上的知识点 Kinect 设备的硬件介绍 Kinect设备 基座和感应器之间有一个电动的马达，通过程序能够调整俯仰角度; 在上面的感应器中有一个红外投影仪，两个摄像头，四个麦克风和一个风扇。、 最左边是红外光源，其次是LED指示灯 中间的是彩色摄像头，用来收集RGB数据 最右边是红外摄像头用才采集景深数据 成像大小 彩色摄像头最大支持1280*960分辨率成像 红外摄像头最大支持640*480成像 麦克风阵列 一个在左边的红外发射器下面， 3个在右边景深摄像头下面 Kinect in windows 环境的搭建方式。 kinect in windows]]></content>
      <categories>
        <category>Kinect</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Application For Ubuntu]]></title>
    <url>%2F2019%2F02%2F26%2FApplicationForUbuntu%2F</url>
    <content type="text"><![CDATA[Application For UbuntuVS code安装1234sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-makesudo apt-get updatesudo apt-get install ubuntu-makesudo umake ide visual-studio-code 配置C/C++编译环境 C/C++ PDF阅读器Okular1$ sudo apt-get install okular Typora1234sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAEsudo add-apt-repository 'deb http://typora.io linux/'sudo apt-get updatesudo apt-get install typora Sougou link 12Download : http://pinyin.sogou.com/linux/ sudo dpkg -i sogoupinyin_2.1.0.0082_amd64.deb Arduino link Extensions 安装 搜索 arduino vs code –&gt; 首选项 –&gt; 设置 –&gt; 搜索arduino –&gt; 设置 arduino.path 123456查看软件安装目录： $ aptitude show sublime-text-installer //列出软件信息 $ dpkg -l //列车所有安装的软件 $ dpkg -l firefox //列出firefox 软件安装信息 $ dpkg -L 软件名 //没有在PATH路径下保存，通过下面命令寻找安装目录 Screenshot ubuntu 自带的截图工具 用用软件进行下载更新 Port Question查看设备的 Serial Devide123cd /devls ttyUSB* //esp32的端口Serial查询ls ttyACM* //arduino 端口的serial Port Permission denied 问题：下载程序到arduino时，端口权限报错。 12Auto-detected: /dev/ttyACM0*** [upload] could not open port /dev/ttyACM0: [Errno 13] Permission denied: '/dev/ttyACM0' ('/dev/ttyUSB0') 重启后权限消失 12给端口权限sudo chmod 666 /dev/ttyACM0 ('/dev/ttyUSB0') 永久权限 123sudo gedit /etc/udev/rules.d/70-ttyacm.rules('/dev/ttyusb') // 添加权限文件KERNEL=="ttyACM[0-9]*",MODE="0666" ('/dev/ttyUSB0') // 添加权限文件reboot Vi 编辑时上下左右键出现字母 ubuntu默认安装装的是vim tiny版本，而需要的是vim full版本。 12$sudo apt-get remove vim-common$sudo apt-get install vim 环境变量的设置 配置/etc/enviroment 1234sudo su // 用户权限vi /etc/enviromentPATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/quronghui/HustFiles/Esp32/crossTools/xtensa-esp32-elf/binsource /etc/enviroment //使之生效 配置 /etc/profile （这个不用配置） 1234sudo su // 用户权限vi /etc/profileexport PATH=/home/yan/share/usr/local/arm/3.4.1/bin:$PATHsource /etc/profile //使之生效 Linux 下的串口 minicom 123456789sudo apt-get install minicomsudo minicom // 需要在root权限下开启minicomctrl-a o //进入端口配置,先按下 Ctrl + a;放开Ctrl + a，按下 oselect ：A //修改端口 和 波特率change : /dev/ttyUSB0select : Save setup as dflctrl-a x // 退出minicon 查看已安装文件的目录 dpkg 12dpkg -l "*sougou*" //来查看软件的状态。dpkg -P //来卸载软件,或者 dpkg --purge完全删除,包括配置文件 查看目录 12ps -e //查看软件对应的名字sudo find / -name "platform" //查询得到软件的目录 设置PlatformIo 串口的波特率12stty -F /dev/ttyUSB0 //查看Usb的属性 stty -F /dev/ttyUSB0 115200 //修改usb的波特率 声卡无声音 Ubuntu 18没有声音 解决方式参考]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect SDK for ColorImageStream]]></title>
    <url>%2F2019%2F02%2F26%2FKinect%20SDK%20for%20ColorImageStream%2F</url>
    <content type="text"><![CDATA[Kinect SDK for ColorImageStream 网上的知识点 通过安装的SDK包，看相应的代码 下面介绍如何发现以及初始化Kinect传感器，从Kinect的影像摄像头获取图片。 Kinect Sensor 基于Kinect开发的应用程序最开始需要用到的对象就是KinectSensor对象，该对象直接表示Kinect硬件设备。 KinectSensor对象是我们想要获取数据。包括ColorImageStream，DepthlmageStream和SkeletonStream。 从KinectSensor获取数据：通过监听该对象的一系列事件。 每一个数据流以帧(frame)为单位。 每一种数据流都有对应的事件，当改类型数据流可用时，就会触发改时间。 ColorImageStream：触发ColorFrameReady事件 KinectSensor数据流形式 每一种数据流(Color,Depth,Skeleton)都是以数据点的方式，在不同的坐标系中显示的 inectSensor对象有一些列的方法能够进行数据流到数据点阵的转换 123MapDepthToColorImagePoint；MapDepthToSkeletonPoint；MapSkeletonPointToDepth Kinect 设备的发现和引用 通过SDK探测有无Kinect连接 123（1）KinectSeneor对象有一个静态的属性KinectSensors（2）该属性是一个KinectSensorCollection集合，该集合继承自ReadOnlyCollection（3）ReadOnlyCollection集合很简单，他只有一个索引器和一个称之为StatusChanged的事件 Kinect 的初始化 12When : Connect --- 才进行赋值操作 not connect --- KinectSensor对象抛出InvalidOperationException异常 Load and Unload 事件 1234（1）窗口的Loaded事件中程序通过DiscoverKinectSensor方法试图调用一个连接了的传感器（2）窗体的Loaded和Unloaded事件中注册这两个事件用来初始化和释放Kinect对象note : DiscoverKinectSensor方法只有两行代码，第一行代码注册StatusChanged事件，第二行代码通过lambda表达式查询集合中第一个处在Connected状态的传感器对象，并将该对象复制给Kinect属性。Kinect属性的set方法确保能都赋值一个合法的Kinect对象。 StatusChanged事件: 当状态为KinectSensor.Connected的时候，if 语句限制了应用程序只能有一个kinect传感器，他忽略了电脑中可能连接的其他Kinect传感器。 以上代码展示了用于发现和引用Kinect设备的最精简的代码。 Kinect Sensor 的打开和关闭 Connect 初始化传感器 Enable 数据流 ：Color,Depth,Skeleton 数据流使用：使用Kinect对象的一些列事件 1234ColorImageStream ---- ColorFrameReady 事件DepthImageStream ---- DepthFrameReady事件SkeletonStream ---- SkeletonFrameReady事件 AllFramesReady 事件在任何一个数据流状态enabled时就能使用 应用程序调用KinectSensor对象的Start方法 frame-ready事件就会触发从而产生数据 Stop Kinect 先检测Kinect sensor 是否为空；然后监听frameready事件 1Using KinectSensor对象的 : Stop ways 应用程序在不需要使用KinectSensor对象时，释放这些资源 12Stop ways 注销frameready事件 Notes (1)不要去调用KinectSensor对象的Dispose方法。这将会阻止应用程序再次获取传感器。 (2)应用程序必须从启或者将Kinect从新拔出然后插入才能再次获得并使用对象 ColorImageStream 的获取 初始化和释放KinectSensor和ColorImageStream对象 12345if (value!=null&amp;&amp;value.Status==KinectStatus.Connected)&#123; this.kinect=value; InitializeKinectSensor(this.kinect);&#125; InitializeKinectSensor对象 ：调用ColorImageStream的Enable方法，注册ColorFrameReady事件并调用start方法。 一旦打开了传感器，当新数据帧大道是就会触发frameready事件，该事件触发频率是每秒30次。 123456if (kinectSensor != null) &#123; kinectSensor.ColorStream.Enable(); kinectSensor.ColorFrameReady += new EventHandler&lt;ColorImageFrameReadyEventArgs&gt; (kinectSensor_ColorFrameReady); kinectSensor.Start(); &#125; 数据显示 ）ColorFrameReady方法中：打开或者获取一个frame来提取获Frame数据。 ）ColorImageFrameReadyEventArgs对象中的OpenColorImageFrame属性：返回一个当前的ColorImageFrame对象。 ）ColorImageFrame对象：提取像素数据之前需要使用一个Byte数组保存获取到的数据。 ）FrameObject对象的PixelDataLength对象返回数据和序列的具体大小。 ）调用CopyPixelDataTo方法可以填充像素数据，然后将数据展示到image控件上。 图像数据获取方式的改进 知识参考 WriteableBitmap对象 它位于System.Windows.Media.Imaging命名空间下面，该对象被用来处理需要频繁更新的像素数据。（之前是更新30幅图像 / 每秒） 创建WriteableBitmap时，应用程序需要指定它的高度，宽度以及格式，以使得能够一次性为WriteableBitmap创建好内存，以后只需根据需要更新像素即可。 图像的处理 每一帧ColorImageFrame都是以字节序列的方式返回原始的像素数据：对这些原始数据进行一定的处理，然后再展示出来。 for循环遍历每个像素，由于数据的格式是Bgr32，即RGB32位(一个像素共占4个字节，每个字节8位)，所以第一个字节是蓝色通道，第二个是绿色，第三个是红色。 循环体类，将第一个和第二个通道设置为0.所以输出的代码中只用红色通道的信息。这是最基本的图像处理。 截图 可能需要从彩色摄像头中截取一幅图像，例如可能要从摄像头中获取图像来设置人物头像。为了实现这一功能，首先需要在界面上设置一个按钮。 图片数据格式介绍 ImageStream是ColorImageStream的基类。因此ColorImageStream集成了4个描述每一帧每一个像素数据的属性。在之前的代码中，我们使用这些属性创建了一个WriteableBitmap对象。这些属性与ColorImageFormat的设置有关。 ImageStream中除了这些属性外还有一个IsEnabled属性和Disable方法。IsEnabled属性是一个只读的。当Stream打开时返回true，当调用了Disabled方法后就返回false了。Disable方法关闭Stream流，之后数据帧的产生就会停止，ColorFrameReady事件的触发也会停止。 当ColorImageStream设置为可用状态后，就能产生ColorImageFrame对象。ColorImageFrame对象很简单。他有一个Format方法，他是父类的ColorImageFormat值。他只有一个CopyPixelDataTo方法，能够将图像的像素数据拷贝到指定的byte数组中，只读的PixelDataLength属性定义了数组的大小PixelDataLength属性通过对象的宽度，高度以及每像素多少位属性来获得的。这些属性都继承自ImageFrame抽象类。 数据流的格式决定了像素的格式，如果数据流是以ColorImageFormat.RgbResolution640480Fps30格式初始化的，那么像素的格式就是Bgr32，它表示每一个像素占32位(4个字节)，第一个字节表示蓝色通道值，第二个表示绿色，第三个表示红色。第四个待用。当像素的格式是Bgra32时，第四个字节表示像素的alpha或者透明度值。如果一个图像的大小是640480，那么对于的字节数组有122880个字节(widthheightBytesPerPixel=6404804).在处理影像时有时候也会用到Stride这一术语，他表示影像中一行的像素所占的字节数，可以通过图像的宽度乘以每一个像素所占字节数得到。 ImageStream 数据获取的方式事件模式 目前为止我们都是使用KinectSensor对象的事件来获取数据的。事件在WPF（为不同用户界面提供统一的显示系统（ Windows Presentation Foundation））中应用很广泛，在数据或者状态发生变化时，事件机制能够通知应用程序。 “拉”模式 采用拉模式获取数据的性能应该好于事件模式。 唯一不能使用事件模型获取数据的情况是在编写非WPF平台的应用程序的时候。比如，当编写XNA或者其他的采用拉模式架构的应用程序。建议在编写基于WPF平台的Kinect应用程序时采用事件模式来获取数据。只有在极端注重性能的情况下才考虑使用“拉”的方式。]]></content>
      <categories>
        <category>Kinect SDK</category>
        <category>Kinect</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect in Windows]]></title>
    <url>%2F2019%2F02%2F20%2FKinect%20in%20Win%2F</url>
    <content type="text"><![CDATA[[TOC] Kinect in Windows Kinect in Windows 开发指南 kinect + opencv + vs 环境配置 安装 Kinect SDK Bug 首次安装KinectSDK-v1.8-Setup 连上kinect后，打开一次后，第二次打开提示 “ No kinet to connect ” 重新卸载后，安装KinectSDK-v1.7-Setup，成功 在官方网站下载Kinect for Windows SDK和Developer Toolkit： 参考教程 KinectSDK-v1.7-Setup.exe KinectDeveloperToolkit-v1.7.0-Setup.exe 安装成功后，连上kinect, 设备管理器出现 “ Kinect for windows ” 通过kinect tools 测试 XBox的好坏 安装 Visual StudioVS2017 安装教程 Download Visual Studio Community免费版 选择工作负载这里仅勾选”使用C++的桌面开发”，单个组件和语音包使用默认 按照需要选择要安装的模块（但是我下载后没有已安装的选项） VS2017的文件目录 C:\Users\quronghui\source\repos 安装注意 直接安装VS2017，并且卸载完之前安装的VS2015版本（如果可以的话直接升级） 我的是因为之前安装的VS2015 ios镜像不成功，卸载不完全，导致的系统重装. Mircosoft 的软件安装的时候，不要中途暂停，不然容易造成卸载不了的问题 解决方案 重装系统后，直接安装VS2017，这样就不会报错了 因该是以前装VS其他版本没有卸载干净，导致的后果 Kiinect SDK 关于 VS 的配置 Kiinect SDK 关于 VS 的配置 使用VS进行开发的话，需要配置include和lib路径 进入VS，右键-项目属性，Debug + x64，选择VC++Directories: 1234Debug and Release 都要添加 Include files : add C:\Program Files\Microsoft SDKs\Kinect\v1.7\inc； Library files : add C:\Program Files\Microsoft SDKs\Kinect\v1.7\lib\x64； 链接器 : add Kinect10.lib C:\Program Files\MicrosoftSDKs\Kinect\v1.6\inc 目录下有： 1234- NuiApi.h ---包含所有的NUI(自然用户界面) API头文件和定义基本的初始化和函数访问入口。这是我们C++工程的主要头文件，它已经包含了NuiImageCamera.h 和 NuiSkeleton.h。- NuiImageCamera.h ---定义了图像和摄像头服务的API，包括调整摄像头的角度和仰角，打开数据流和读取数据流等。- NuiSkeleton.h ---骨架有关的API，包括使能骨架跟踪，获取骨架数据，骨架数据转换和平滑渲染等。- NuiSensor.h ---音频API，包括ISoundSourceLocalizer接口，用于返回声源的方向（波束形成）和音频的位置。 安装 OpenCV 本次安装的opencv，是为了迁移上一个工程师的代码，所以opencv的版本需要一致才能编译成功。 opencv 2.4.6.0，vc10 提取码：f3pz Opencv 的安装和配置教程 Opencv 的安装 我是直接复制工程师的 opencv 解压包，只是进行依赖链接的配置。 环境变量 Opencv Start Dll 文件的复制 dll 文件都在安装的opencv的 bin 目录下 12copy : opencv_ffmpeg .dll to C:\Windows\System32copy : opencv_other .dll to C:\Windows\SysWOW64 Opencv With VS2017 VS 属性中（ Include Direction）: 12345Include Direction： C:\Software\opencv\opencv\includeC:\Software\opencv\opencv\build\include\opencvC:\Software\opencv\opencv\build\include\opencv2C:\Software\opencv\freetype\include // 为了在opencv里面检测的图片上加上字 VS 属性里面的 库目录 12Library Direction: C:\Software\opencv\opencv\build\x64\vc10\lib VS 属性 – 链接器 – 输入项 – 附加依赖项 1234567" **在 Debug x64 下面进行配置**"Link : opencv_core246d.lib // lib 库下面 opencv_xxx "d" : 代表的是Debug版本使用的库 opencv_highgui246d.lib opencv_video246d.lib opencv_imgproc246d.lib opencv_photo246d.lib 1234567" **切换 Release x64 下面进行配置**"Link : opencv_core246.lib // lib 库下面 opencv_xxx : 代表的是Release版本使用的库 opencv_highgui246.lib opencv_video246.lib opencv_imgproc246.lib opencv_photo246.lib 安装QTQT 的安装 安装方式 1234Notes: QT组件的选取： MSVC 2017 64-bit : VS2017 的QT编译器 MinGW 5.3.0 32 bit : gcc 的编译器吧 QT with VS2017 配置方式 Notes 123456VS 属性 -- 链接器 -- 输入项 -- 附加依赖项 ：加入QT. lib如果报错再加入： qtmain.lib Qt5Core.lib Qt5Gui.lib Qt5Widgets.lib 代码迁移后需要改动VS 的项目 – 配置属性 VC ++ 目录 ： 下面的包含目录和库目录。 注意修改迁移项目的目录链接。 （之前背的工程师的SDK or opencv 放在其他的目录下） Qt Meta-Object Complier: Include Path C/C++ 目录 常规 – 附加包含目录： 所有选项 – 附加包含目录 计算机中丢失 MSVCP100D.dll 代码迁移后，会报计算机中丢失 MSVCP100D.dll 解决方案：去对应工程师的电脑下，拷贝MSVCP100D.dll download提取码：fkvr 12copy xxx.dll files to C:\Windows\SysWOW64 copy xxx.dll files to C:\Windows\System32 VS2017 项目打包部署（.exe files） 参考链接 Vs的部署方式 部署连接，Mircosoft官网 Vs + Qt 的应用程序发布部署 通过编译Release 得到可执行文件exe，生成相关可执行文件 将需要发布的exe（Release ）文件编译后（如QtGuiApplication1.exe），放到单独的目录。 在“开始菜单”启动Qt 5.9.1 32-bit for Desktop (MSVC 2015); Win + R 进去 cmd编辑； cd C:\Software\kinect\QtGuiApplication1\x64\Release 进入 exe 文件的目录 执行命令 1windeployqt.exe QtGuiApplication1.exe --qmldir C:\Qt\Qt5.12.1\5.12.1\msvc2017_64\qml 生成运行时需要的文件。（源程序发生改变，需要重新生成一次） Vs 2017的依赖库 123456789进入路径C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\Remote Debugger\x64拷贝文件api-ms-win-core-* concrt140.dllmsvcp140.dllucrtbase.dllvcruntime140.dll粘贴到 *步骤一的目录下* 这样迁移到相同屏幕尺寸的电脑下，就可以运行了。 如果出现Qt提示的文字超出界面，修改字体的大小就能自适应平板了。 增加语音功能 增加语音功能，实现特定语句的播放]]></content>
      <categories>
        <category>Kinect</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect in Ubuntu]]></title>
    <url>%2F2019%2F02%2F20%2FKinect%20in%20Ubuntu%2F</url>
    <content type="text"><![CDATA[OpenKinect Application for UbuntuOpenKinect on linux 环境搭建 OpenKinect/libfreenect libusb的安装 Download libusb &gt;= 1.0.18 安装过程 ./configure执行报错时 1./configure --build=x86_64-linux --disable-udev sudo make install Use 提示安装好了lib，目录所在。 1make[1]: 离开目录“/home/quronghui/Kinect/libusb-1.0.22” 所以我们基于libusb编程的时候，需要包含这个库 */ 编译时加上 –lusb-1.0 就是这个原因，库放在这个目录下，需要链接上。 CMake安装方法 Download : Source Distribution 或者 Binary Distribution，前者是源代码版，你需要自己编译成可执行软件。后者是已经编译好的可执行版，直接可以拿来用的。 安装教程 Python3 安装方法 参考教程 下载Python3 时候特别的慢，一直在等。 Libfreenect 安装 编译 1234567git clone https://github.com/OpenKinect/libfreenectcd libfreenectmkdir buildcd build // 在这之后的操作需要插入设备 // 尽量带sudo ,不然会少安装一些东西sudo cmake -L .. # -L lists all the project optionssudo make 更新依赖库 12sudo apt-get install git cmake build-essential libusb-1.0-0-devsudo apt-get install freeglut3-dev libxmu-dev libxi-dev 测试设备 12cd build/binsudo ./freenect-glview QTGUI for linuxKinect for WindowsKinect SDK 安装 Bug 首次安装KinectSDK-v1.8-Setup]]></content>
      <categories>
        <category>Kinect</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SerialCommunication]]></title>
    <url>%2F2019%2F02%2F19%2FSerialCommunication%2F</url>
    <content type="text"><![CDATA[GPIO，I2C，SPI，UART，USART，USB的区别GPIO（General Purpose Input Output ） 系统需要采用远端串行通信或控制时，GPIO产品能够提供额外的控制和监视功能。 SPI (Serial Peripheral Interface) 是一种标准的四线同步双向串行总线。 SPI接口主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。 芯片 – 间的高效通信 数据线 串行时钟(SCLK)、串行数据输出(SDO)、串行数据输入(SDI) SPI总线：一个Master，多个Slave设备 主从设备间可以实现全双工通信 通用IO口模拟SPI总线 主从设备：必须要有一个输出口(SDO)，一个输入口(SDI)， SCLK则视实现的设备类型而定 SPI 通信协议 一个主设备启动一个与从设备的同步通讯的协议，从而完成数据的交换 与普通的串行通讯不同，普通的串行通讯一次连续传送至少8位数据，而SPI允许数据一位一位的传送 至少8次时钟信号的改变（上沿和下沿为一次），就可以完成8位数据的传输 主设备通过对SCK时钟线的控制可以完成对通讯的控制 I2C (INTER IC BUS) 是一种集成电路间的总线标准，用于连接微控制器及其外围设备 非常适合在器件之间进行近距离、非经常性的数据通信 数据传输 传输数据时都会带上目的设备的设备地址，因此可以实现设备组网。 双向、两线(SCL、SDA)、串行、多主控（multi-master）接口标准 通用IO口模拟IIC总线 则需一个输入输出口(SDA)，另外还需一个输出口(SCL) I2C通信协议 接到总线的器件都可以通过唯一的地址和一直存在的简单的主机从机关系软件设定地址主机可以作为主机发送器或主机接收器 UART(Universal Asynchronous Receiver Transmitter) 通用异步接收/发送装置。 复杂 : 异步串口，因此一般比前两种同步串口的结构要复杂很多，半双工通信 数据线 一般由波特率产生器(产生的波特率等于传输波特率的16倍)、UART接收器、UART发送器组成 通用IO口模拟UART总线 需一个输入口，一个输出口 USART 通用同步异步收发器； USB：Universal Serial BUS 通用串行总线 CAN 现场总线]]></content>
      <categories>
        <category>Communication</category>
      </categories>
      <tags>
        <tag>SerialCommunication</tag>
        <tag>Electronic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言入门]]></title>
    <url>%2F2019%2F02%2F19%2FLinuxC%2F</url>
    <content type="text"><![CDATA[Linux C编程一站式学习 C语言入门 程序的五个步骤 math函数的gcc编译 12$ gcc math.cpp -o math -lm // math的编译要加上 "-lm"$ gcc hello.c -o hello -Wall // gcc编译带上 -Wall,显示所有警告的信息 [UNIX编程艺术] The Art of UNIX Programming. Eric Raymond. 全局/局部变量 虽然方便，但是要慎用，能用函数传递参数的就不要使用全局变量 局部变量可以用任意类型相符的表达式来初始化,而全局变量只能用常量表达式初始化。 Debug 如果全局变量在定义时不初始化,则初始值是0。但是局部变量不初始化时，初值就不确定，局部变量先赋值 if/else else 总是和最近的一个if配对 如果需要隔开的话，加 “ { } ” 隔开 Debug Ways 增量式开发：通过printf的方式，一步步打印结果查看 printf (“ “) // 通过打印进行调试 递归函数：要加上 Base Case 12345int factorial(int n)&#123; if (n == 0) //也就是0项 return 1;&#125; 递归和循环是等价的; 用循环能做的事用递归都能做 循环函数 循环函数:相当于将函数表达式展开，然后通过while()，进行循环的迭代 do / while 的格式 123do 语句；while(); // while 后面有个分号 Break and Continue break : 跳出当前循环体，执行后面的语句； Continue : 终止本次循环(循环里面的内容，在continue之后的语句都不执行)，然后回到循环体的开头准备再次执行循环体。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO Github]]></title>
    <url>%2F2019%2F02%2F18%2FHEXOGithub%2F</url>
    <content type="text"><![CDATA[Linux 下HEXO + Github 搭建博客HEXO 环境搭建流程 HEXO 环境搭建流程 安装Nodejs 和 npm 正式安装Hexo 初始化文件夹 hexo init Github 的部署 github 上建立repository ； 命名为 username.github.io; 修改hexo 目录下的_config.yml 12345修改hexo 目录下的_config.yml deploy: type: git repository: https://github.com/quronghui/quronghui.github.io.git branch: master 配置github 12$ git config --global user.name "yourName"$ git config --global user.eamil "email@example.com" HEXO 主题的修改 使用 NEXT主题 更改主题配置文件(NEXT)中的，站点配置文件_config.yml 动态效果还未实现 官方NEXT的配置文档 avatar 下添加头像 Hexo的Next主题详细配置 HEXO 博客分支备份 参考教程 在 hexo 博客文件夹下，创建两个分支（Github 的部署, 修改_config.yml时，只是添加git的源在里面，没有进行add 或者clone，因此没有master主分支） 12$ git branch dev(master) // 创建分支,dev只是分支名字$ git checkout dev(master) // 分支切换（也就是设置默认分支） clone 博客文件到本地，git clone https://github.com/quronghui/quronghui.github.io.git 将之前的hexo文件夹中的文件 ，复制至username.github.io文件夹，为了进行一次分支提交； 123456_config.ymlthemes/source/scaffolds/package.json.gitignore 将themes/next/ 下的.git/删除，否则无法将主题文件夹push； 123delete : themes/next/ 下的.git/删除 两个地方都删除 在username.github.io 下创建分支dev , 并且切换分支dev 这样以后就在username.github.io 下工作 123456分支： git branch dev git checkout devinstall sudo npm install sudo npm install hexo-deployer-git --save 提交文件到分支dev上。 123git add -A ;git commit -m "" ;git push origin dev ; 部署至Github上 12hexo ghexo d HEXO 博客迁移 主要是需要重装一遍环境 安装git； 安装Nodejs和npmwin； 使用`git clone -b hexo https://github.com/quronghui/quronghui.github.io.git 将仓库拷贝至本地； 在文件夹内执行以下命令 123ubuntunpm install hexo-cli -gnpm installnpm install hexo-deployer-git HEXO 博客分支问题 在quronghui.github.io 文件夹下进行提交的时候，产生了很多冲突。因此，我直接删除hexo文件夹。 使用clone将仓库拷贝至本地； 1git clone -b hexo https://github.com/quronghui/quronghui.github.io.git 在文件夹内执行以下命令 12sudo npm installsudo npm install hexo-deployer-git 这样相当于在本地重建环境 HEXO关于Tags 点击无反应 参考链接 添加标签 ： hexo new page tags 确定配置文件中，大小写一致 确认站点配置文件里有tag_dir: tags 确认主题配置文件里有tags: /tags 编辑站点的source/tags/index.md，添加 1234title: tagsdate: 2015-10-20 06:49:50type: "tags"comments: false HEXO 添加搜索 npm install hexo-generator-searchdb –save 修改站点配置文件 12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件 123hemes/next下的_config.yml文件local_search: enable: true## HEXO 添加搜索 HEXO 修改默认生成的文档界面 站点配置文件_config.yml查看 1default_layout ：post 修改 123456/scaffolds/post : 修改默认页面 layout: post title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125; categories: tags: 新建页面 使用 hexo new post &lt; name &gt; HEXO 文章引用pdf – 可查看 安装pdf插件 1npm install --save hexo-pdf 本地存在的pdf 121. 将pdf文件放在 /source/_post/name 下2. 文档中使用 &#123;% pdf ./pdf名字.pdf %&#125; 网上链接 1&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125; HEXO 添加本地文件下载 调整程序配置文件_config.yml 里的post_asset_folder:这个选项设置为True 在source下创建/document文件夹 12mkdir document把文件复制到这个文件夹 在 .md 中引入 [ name ]（/ document /name.ppt） HEXO markdown文档添加多个分类 添加子分类 123categories: - Java - Servlet 添加多个分类 123categories: -[Java] -[Servlet] Hexo 的侧边栏，显示错误 问题描述：Search 显示成了Suche]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>linux hexo github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxAndWin10]]></title>
    <url>%2F2019%2F02%2F18%2FLinuxAndWin10%2F</url>
    <content type="text"><![CDATA[Win10 + Ubuntu 双系统Win10 + Ubuntu环境的搭建 参考链接 有些工作需要切换windows,因此才搭建了双系统。 准备工作 下载UltralSO，这是用来制作启动盘的软件 下载Linux系统的镜像ubuntu16.04，可以在官网上下载 （可选）下载启动项编辑工具[EasyBCD] windows系统下进行分盘 我的电脑–计算机管理–压缩的磁盘–右键–压缩卷 选择未分配区域，右键选择“新建卷“ – 右键“删除卷”可以将这变成可用空间 制作ubunut启动盘 打开UltraSO软件，选择“文件”-“打开”打开之前下好的iso映像文件 选择“启动”-“写入硬盘映像”。此处注意选择正确硬盘驱动器。 依次点击“格式化”和“写入”，完成后它会在消息处提示“刻录成功！” 设置window 下的BIOS 关闭快速启动。选择控制面板-电源选项-选择电源按钮的功能，选择“更改当前不可用的设置”，取消选中“启用快速启动” 安装ubuntu 在下一步之前，一定要先联网，会进行下载 选择 安装音频相关软件…… Ubuntu 工具的安装 参考链接 用到的时候直接搜索]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>linux win10 双系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArduinoMQ135]]></title>
    <url>%2F2019%2F02%2F17%2FArduinoMQ135%2F</url>
    <content type="text"><![CDATA[口气检测仪项目报告 基于Arduino和MQ135硫化物传感器，实现口气检测 [TOC] 1. 总体实现描述 人呼出的气体中含有多种痕量挥发性硫化物 , VSCs中硫化氢、甲硫醇和二甲基硫醚的量与口臭的强弱直接相关。这些化合物通常与人体健康及代谢过程相关, 一般分为口腔性和非口腔性, 其中90%来源于口腔，目前监测这种变化的方法目前有: (1) 感官分析法, 即鼻测法; (2) 仪器分析法:气相色谱法、气相色谱质谱联用法、硫化物分析仪 (Halimeter) 法、便携式气相色谱口臭测量仪。本产品主要是根据人体呼出气体中硫化物的浓度进行评判的。 本产品基于Arduino作为主控，通过其模拟通道，结合MQ135传感器，对人体呼出的气体中硫化物的浓度进行采集，（人体口气中的成分如如图）对浓度值进行AD转换，对得到的浓度值进行等级的划分，最后得到用户口气检测的等级，用户通过等级查看小程序的相关建议，从而得到口腔保护的建议。 ​ 产品设计总的流程框架图如下所示: ​ 2. 硬件平台搭建2.1 主控Arduino 主控选择开源硬件Arduino, 使用AD转换的模拟通道进行MQ135的检测，数字通道检测按键的状态，IIC通信方式显示检测过程中的浓度大小。 ​ 2.2 传感器 MQ135 传感器检测口气中可挥发性硫化物，使用的是电导率较低的二样化锡SnO2，电导率随空气中污染气体浓度的增加而增大，输出一个模拟电压，主控arduino的AD采样值进行采样，并将电压值映射10-1000ppm之间的浓度。 ​ 2.3 显示OLED 采用IIC的OLED显示屏，对检测过程中的浓度进行动态显示，并且能显示以前检测的浓度值。 ​ 2.4 按键设计 按键设计了两部分： （1）按键一：按下时开始进行口气检测，并在OLED上动态实现；当按键弹起的时候，OLED上固定显示本次检测的最大浓度值和评价等级； （2）按键二：按下的时候，显示第几次检测，检测的口气浓度值大小和等级。 2.5 供电 锂电池供电，提供充电模块。 3. 软件平台搭建 完整源码：https://github.com/quronghui/Arduino 3.1 MQ135浓度采样 通过map()函数，对采样的电压值进行映射，得到浓度值。将MQ135输出的电压值（0.1-0.3V – 4V）映射成浓度（10-1000 ppm）。 1long mapping(long x, long in_min, long in_max, long out_min, long out_max); // 函数的映射 3.2 存储采样数据 通过数据对MQ135每次采样数据的存储，通过排序得到本次检测的最大浓度值，实现按键一（中断0）的功能。 12void MemoryData(); // 采样数据的存储，存储到数据；void max(); // 排序得到最大值 3.3 EEPROM 存储本次检测的等级和浓度值 为了用户能查阅以前检测的等级，设计EEPROM函数，对每次检测的等级和浓度值进行保存，当按键二（中断1）按下时后，显示第几次检测，检测的口气浓度值大小和等级，实现按键二的功能。 12345// EEPROM 存储的函数声明void EepromWriteMaxArray(int EEP_data); // 写入每次检测到的最大浓度值EEPROM存储器,void EepromWriteGrade(int grade_data); // 写入每次检测的等级值void EepromRead(); // 从EEPROM存储器读出数据void EepromClear(); // 清除EEPROM里面的数据 3.4 OLED显示 采用IIC通信方式，动态显示每次检测的浓度值，以及显示EEPROM 存储的检测值，满足按键一和按键二的需求。 12345678// 对每一次数组的采样值进行OLED显示u8g.firstPage(); //一下是显示实现部分do &#123; u8g.setFont(u8g_font_fub30); //设置字体和自号，目前测试字号有fub14,17,20,30 u8g.setPrintPos(0, 50); //显示的位置 u8g.print(array[i]); //显示变量i的值&#125; while( u8g.nextPage() );delay(500); 3.5 浓度等级评定 浓度等级的评定，主要是根据MQ135的检测结果，和人体承受硫化物浓度的范围进行设定的，根据需求将测量的浓度等级分为5大块，具体设定参考下图。 1234567int MQgrade(int temp); // 进行等级的评定int score[] = &#123; &lt;30, // grade = 0 未检测 40,45,50, // grade = 1-3 轻微 55,65,70, // grade = 4-6 中度 75,85,90, // grade = 7-9 重度 &gt; 100 // grade =100 检测其他物体/或者传感器没有正常连接 &#125;; ​ 4. 实现效果图 实现效果图主要分为以下三部分：（1）动态检测的浓度值；（2）本次检测的最大浓度值和浓度等级；（3）显示EEPROM 存储的检测值，显示第几次检测，检测的口气浓度值大小和等级。 (1) 按键一按下后，显示口气检测仪的动态浓度采样值 (2) 按键一弹起后，固定显示本次口气检测的最大浓度值和等级 (3) 按键二：按一次，显示第几次检测（T），检测浓度大小（ppm），评价等级（G） 5. 总结注意 MQ135传感器的特性，要求预热足够的时间，40小时以上，检测的浓度值才会稳定。 口气检测仪开始检测时，要进行通电预热，待稳定的时候在进行检测。 由于MQ135的材料特性，每个传感器预热后的初值都不太相同，因此为了检测的灵敏度要求，需要手动调整一下代码。 6. 价格 物料 / 个 价格 / 元 链接 Arduino Pro Mini 10.9 智能创客科技 MQ135 9.23 risym旗舰店 OLED 22.99 telesky旗舰店 PCB制板 5 嘉利创 锂电池 13 海兄弟锂电池 其他电容电阻和接插件]]></content>
      <categories>
        <category>Product</category>
      </categories>
      <tags>
        <tag>arduino</tag>
        <tag>MQ135</tag>
        <tag>OLED</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electronic Direction]]></title>
    <url>%2F2018%2F12%2F25%2FElectronicDirection%2F</url>
    <content type="text"><![CDATA[Electronic Studying 嵌入式学习的一个方向指导 嵌入式过程中常用的工具，社区，书籍 Contents[TOC] Computer history 从嵌入式的元件，到计算机的整体架构； bilibili 视频学习教程 搜索计算机科学—-【计算机科学速成课】 Awesome Electronics 介绍嵌入式的一些网址，工具，和开源社区 GitHub 中kitspace/awesome-electronics github 中的 awesome，是一个很强大的 Project Communication IIC and Uart and SPI Book Eagle 的学习使用【高质量PCB设计入门–Eagle使用】 LinuxC 编程一站式学习 凸优化，嵌入式的算法模型 看芯片制作的相关书 ToolsAutoDesk Student AutoDesk 选择地区是中国的，为了后面的学校验证 { % aeest_img autodesk.png % } 用学校邮箱创建账户，进行验证 进入免费软件一栏，可以看到免费软件 { % aeest_img autodesk_free.png % } Eagle PCB绘制工具，相对于AD来说更加轻量级，而且有大量的封装库。 申请免费的Eagle { % aeest_img eagle.png % } 学习【高质量PCB设计入门–Eagle使用】 Adobe Creative Cloud Adobe Creative Cloud 通过安装Adobe Creative Cloud desk，从而安装 Illustrator (AI的矢量图) Illustrator 能够绘制矢量图，从而导入到 Eagle. Eagle : 不能写中文，而且图形不是矢量的。 AutoCADOpen Link IT Community stackoverflow ：IT与程序相关的IT技术问答网站 element : IT的互助社群 China IT Community CSDN ：国内IT的博客分享平台 开源中国 ：中国最大的开源IT社区 UI Design UI dribbble UI Behance Vector ICONS FlatIcon : 有版权限制的矢量图标 iconfont : 矢量图标 Security Community 看雪论坛 : 致力于PC、移动、智能设备安全研究及逆向工程的开发者社区 吾爱破解：论坛致力于软件安全与病毒分析的前沿,丰富的技术版块交相辉映,由无数热衷于软件加密解密及反病毒爱好者共同维护 [ i 春秋 ]注网络安全、信息安全、白帽子技术的在线学习,教育、培训的平台 Emebadded Community hackaday ： Hardware open source items hackster ：Hardware open source store Cadlab.io ： 可以使用github push 的可视化图形软件 Crowdfunding Community kickstarter ：众筹项目 indiegogo : 众筹项目 modian : 中国的众筹项目 Hacker New ：世界的重要新闻 RSS (Really Simple Syndication) inoreader : RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合）。 feedly : Feedly是一款第三方RSS阅读器，在经过了几次更新后，已经有比较多的忠实的使用者。 第一次访问Feedly的用户，Feedly会自动提示接入 Google Reader的访问权限，无需注册新会员. 能够增加我们之前的Open Source PDF Transform Doc https://pdf2doc.com/ Algorithm visualization* https://visualgo.net/zh : 算法可视化的工具，用于展示算法的好工具 UART HMI 通过串口发送，就之间显示出对应的图形和数据 在显示屏上显示二维码就可以用。 与非网：一些嵌入式的前沿 可能你已修炼成资深行业观察家，如何小庆老师那样真知灼见； 可能你善于分析行业趋势，如飞翔的鸭子侃侃而谈； 可能你精通某一项技术，如加菲那样精讲技术而不失幽默； 可能你善于发现身边的工程师故事，如骆驼般娓娓道来。]]></content>
      <categories>
        <category>Electronic Direction</category>
        <category>Open Link</category>
        <category>awesome-electronics</category>
      </categories>
      <tags>
        <tag>Electronic Direction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018_HUST_PPT]]></title>
    <url>%2F2018%2F12%2F11%2F2018-12-11-2018-HUST-PPT%2F</url>
    <content type="text"><![CDATA[2018_HUST_PPTEPIC Lab PPT 20180905AIWAC宝宝机器人.pptx 20180905武大EEG硬件PPT.pptx 20181211CBIB口气检测仪.pptx 20181211EEG项目汇报.pptx 20181211Minchen.pptx 20181216EEG项目汇报.pptx CBIB Lab PPT 20181228CBIB电影龙猫.pptx 20181228CBIB开发社区.pptx 20190104长跑.pptx 20190111Computer.pptx 20190119 Computer Programe.pptx]]></content>
      <categories>
        <category>PPT</category>
      </categories>
      <tags>
        <tag>PPT</tag>
        <tag>epic</tag>
        <tag>cbib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows and GitHub Pages and Jeklly Building owns Bolg]]></title>
    <url>%2F2018%2F11%2F14%2F2018-11-14-win-git-jekyll%2F</url>
    <content type="text"><![CDATA[Windows By GitHub Pages and Jekyll building BlogInstall Tools 整个流程参考链接如下，包括博客的模板 Visit Link github Building yourself github account number. Build a New respository. Name : “github_name”.github.io (ep: quronghui.github.io) git clone 选好的模板 上传到你的GitHub Github Page GitHub Page 相当于一个服务器 Jekyll 运行在 GitHub Page 上 Jekyll 环境的搭建Jekyll Knowledge Jekyll 是一个简单的博客形态的静态站点生产机器 Jeklly 的一个最好的特点是“关注 blog 本身”，一个文件夹_posts下进行管理，减少繁琐 Jekyll 搭建 GitHub Pages + jekyll 的方式 直接参考这个Link Jekyll环境的搭建 Jekyll 搭建中安装包的说明 安装Ruby Ruby 是一种开源的面向对象程序设计的服务器端脚本语言 没找到在Blog中担当的角色 安装RubyGems 用于对 Ruby 组件进行打包的 Ruby 打包系统 也就是 Ruby 的管理系统 用Rubygem 安装Jekyll,所有的依赖包都会被安装 用RubyGems安装Jekyll cd到博客文件夹，开启服务器 访问 http://localhost:4000/ 提交代码到远程GitHub上 jekyll 中文说明文档 Jekyll 变量语法 jekyll serve =&gt; 一个开发服务器将会运行在 http://localhost:4000/ 始终需要重新更新 jekyll serve –watch 本地调试的时候，会自动更新 categories 和 tags categories 属性归类 tags 类似于搜索标签 date 变量 这个日期会覆盖文件命名的日期，并作为发布的时间。 Jekyll 文件夹 _posts Blog文件夹 年-月-日-标题.MARKUP MARKUP : 是一种标记，是用什么格式写。 example .md 和 .textile _assets 图片和文档目录 图片和文档的引用，前提是图片和文档放在assets 目录下 PDF文档 _drafts 草稿文件夹 保存一些占时没有写好的文档，不会进行发表。 jekyll serve –drafts : 查看未发表的草稿博客 github.io 文件夹目录 index.html – 创建主页面 任何网站的配置一样，需要按约定在站点的要目录下找到index.html 这个文件就将是你的 Jekyll 生成站点的主页。 为其他文件创建页面 命名 HTML 文件 没有真正理解这个每个页面的展示，没有成功实现 _config.yml – 文件 修改文件，好像本地博客不会发生改变代码亮亮 代码亮亮 给代码加入行号]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>jeklly Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Language]]></title>
    <url>%2F2018%2F02%2F19%2FComputerLanguage%2F</url>
    <content type="text"><![CDATA[第二章 指令–计算机的语言Schedule Dateline start time end time Learning 2018/12/6 8：50 9：50 第二章计算机指令 2018/12/7 8：20 9：30 MIPS寄存器和存储器 2018/12/8 8：40 9:11 效率低 2018/12/10 19：00 19：44 效率低 2018/12/11 8：36 9：22 多寄存器的冲突问题 Proper Noun Full name 中文 acronym instruction set 指令集 一个给定的计算机体系结构所包含的指令集合。 American Standrad Code for Information Interchange ASCII 计算机的文字处理 Acorn Risc Machine ARM 处理器 P99页 ARM 有更多的寻址模式 MIPS 有更多的寄存器 Question 1、为什么 Java 和 C 会是一样的呢？？ 解释和编译的平衡随着时间的推移逐步形成。 2、加速大概率事件？是什么意思. 3、编译C语言和解释Java语言？在配套的网站上。 Conception 指令集：计算机体系结构所包含的指令集合； MISP: 可方便硬件和编译器的设计，性能最佳且功耗最低。 存储程序的概念：多种类型的指令和数据均以数字形式存储于存储器中的概念。 数据传送指令：在存储器和寄存器之间移动数据的指令； 地址：用于在存储器空间中表示元素位置的值 存储程序：存储器存放程序和编译后的机器码（0/1），文本；甚至是用于生成机器码的编译器。 MIPS 的指令集 MIPS指令集，是一种寄存器到寄存器的语言。 MIPS操作数： | 类别 | 表示 | 数据访问 | 特点 || —————- | ——– | —————————- | ————————————– || 32个寄存器(32位) | $zero | 寄存器用于数据的快速存取 | 只能对存放在寄存器的数据进行算术操作。 || 2^30个存储器字 | Memory[] | 只能通过数据访问传输指令访问 | 字节编程；相邻Memory[4] 字地址相差4 | MIPS 算术运算 一条指令，由三个操作数构成 其余的汇编指令 P42页 ​ MIPS 32位各字段的表示和命名 操作码：指令中用来表示操作和格式的字段 计算机硬件的操作数 寄存器 $s0…… 用于表示C和Java程序中变量所对应的寄存器； $t0……用于表示将程序编译为MIPS，用到的临时寄存器； MIPS 算数运算指令的操作数，必须来自寄存器，由于寄存器位数有限，所以需要从存储器中取数据； 存储器 数据传送指令和地址； 存放像数组或结构那样的复杂数据结构； 存储器 –&gt; 寄存器 ：取数操作 load word 寄存器 –&gt; 存储器 ：存数操作 store word 软硬件接口 将变量和寄存器对应； 编译器在存储器中为数组和结构数据分配相应的位置； 编译器将存储器中数据对应的起始地址存放在：数据传送指令中。 软硬件接口 由于load和store指令中的地址是二进制的，作为主存的DRAM容量使用二进制而非十进制。 符号位和非符号位表示方式 负数的表示方式：采用补码的形式表示 补码：最高位设置为1，源码取反（最高位不变），最低位加1。 软硬件接口 寄存器的数量和定长指令的需求和设置–矛盾； 寄存器任何数量的增长，都需要在指令格式中各个寄存器字段至少增加一位； 寄存器越小越快，所以目用的寄存器大多是16/32。 逻辑操作 逻辑左移sll 和右移srl ：$$左移i位 = 原数 * 2^i$$ 软硬件接口 编译器的最初阶段：将程序分解为若干基本块； 基本快：没有分支，并且没有分支目标和标签的指令序列. 计算机硬件对过程的支持 为了解决更多寄存器使用的冲突问题。 栈的使用 栈的增长是一种先进先出的结构； 地址从高到低进行的,压栈时，栈的指针值减小；（从上到下） 过程嵌套，出现寄存器的冲突问题 通多对寄存器进行压栈处理，解决冲突； 软硬件接口–全局指针 全局指针：$gp，指向静态数据区的保留寄存器 为了简化静态数据的访问时间。 栈中使用的指针 帧指针（frame pointer)：$fp—-指向过程帧的第一个字； 栈指针：$sp 指向栈顶 人机交互 计算机是为了数字计算 计算机表示文字的处理，实现了人机交互。遵循ASCII 为了表示web的全球特性,当今的大部分web页面采Unicode,而非ASCII。 Java中的字符和字符串 字符串是一个标准的Java类，它对连接，比较，转换的方法提供了专门的方法 P75 数组和指针 1、指针中变量的地址用 &amp; 表示，指针所指向的对象用 * 表示。 2、寄存器的操作都是通过地址进行操作的。 3、编译器技术的理解，是理解性能的关键。 ARM7(32)位指令集 区别 ARM(32位) MIPS 多寻址模式 多寄存器 保存0 没有专门的寄存器 zero寄存器保存 第三章 计算机的算数运算Proper Noun Full name 中文 acronym Arithmetic logic unit 算数逻辑单元 ALU Exception Program Counter 异常程序计数器 EPC Question ？ 1、无符号数通常表示内存地址，溢出可以忽略？ 2、每个编译器都将以2为底的指数乘法替换为移位来进行优化。 3、使用32位数据表示通常要处理的无限数字。 4、乘法和除法：尽可能用 0/1 加法和减法 运算规则 加法运算：从右到左，二进制代码相加进位； 减法运算：将负数取反后，按照加法进行 计算是否会溢出 加法:源操作数异号时，不会溢出。 减法:源操作数同号时，不会溢出。 异常程序计数器EPC 保存导致异常的指令地址 乘法 乘法运算 被乘数和乘数的表示？ 被乘数每次左移一位，和乘数的一位相乘，结果相加 积的位数 = 被乘数的位数 + 乘数的位数 被乘数，乘数，积 每次进行的移位操作 积：每次的求和结果 更快速乘法 给每一个乘法数分配一个32位的加法器； 形成一个加法树； 除法 除法没有怎么看懂？ 计算的方式 除数：在右边补0，使其和被除数一样的位数 计算的时候：商左移，除数右移 除法：做减法；乘法：做加法 第四章 处理器]]></content>
      <categories>
        <category>Hardware Interface</category>
        <category>Computer-Composition-Principle</category>
      </categories>
      <tags>
        <tag>Hardware Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-matric]]></title>
    <url>%2F2018%2F02%2F18%2FMath-matric%2F</url>
    <content type="text"><![CDATA[邮箱： hustmath2018@163.com – math2018 typora使用操作 矩阵论 考试内容 Schedule Dateline start time end time Learning 2018/12/4 20:00 20:40 2018/12/10 20:00 10:00 2018/12/12 15:10 2018/12/13 14：35-17: 10 19:20- 2018/12/15 15：00 线性空间 条件：V是一非空集，F是数域，V中元满足向量的一些性质（数乘，交换和结合）； 结论：V为F上的线性空间(或向量空间),记为V(F); 空间V中的元称为向量； 若 性质：零元是唯一的 线性相关：集合中某一元素可由其他元素组线性表示。 线性无关定义： 当 m &gt;2 时；线性无关的条件是，向量组a_i中没有一个元素，可以由其他元素线性表示 单个非零向量组是线性无关； 在空间V中若能找到 n 个线性无关的向量组成dimV = n; 基（基底）的概念 基：最大线性无关向量的集合。 如何求多项式P(t)，在基B={a_i}下，的坐标x={x_i} 坐标：其实就是 A x = b中，向量x的解 求解：（1）构造增广矩阵，进行初等行变换化简；（2）行元素对应相等进行求解 基变换矩阵 空间 V 中的两个基B1 和 B2，存在一个变换矩阵P(ij)，使得B2中的每一个元素，可以通过B1和矩阵P(ij)的某一列相乘得到： 求解技巧： 通过逆矩阵：求解的坐标是n*m维，选用增广矩阵构造 单位矩阵 E，进行初等行变换； 坐标变换矩阵 由基变换引出的概念：求同一个坐标下，不同基对应的元素求解； 根据对应关系求解就行：向量 X = 基 B * 坐标 P； 这样，在根据基变换矩阵便可以求出关系式 当基为标准基：单位矩阵时；任何其他基，相同坐标下的向量都为零矩阵 子空间 线性空间V本身及由V的零元构成的零空间(记为{0}，都是V的子空间，称它们为平凡子空间。 张成子空间：span 子空间W的交；子空间W的和 —-维度 对于维度：先求W的和，再用公式求W交 子空间满足维 dim 的性质，维度就是不能线性表示的，元素的个数。 子空间的交，和满足的维度dim 子空间W的交；子空间W的和 —-基 对于基：先求W交的基，在求W和的基； 对于：W的交求基 存在一组不全为0的K，使得 V * K =0；最大线性无关向量的集合。 对于：W的和求基 直和：强调的是和空间的元素：唯一分解为两个子空间（各出一个元素）的和 直和：会考证明题——根据性质进行判断 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 2. 直和的性质： 1. W的交为零空间； 2. dim( W1 + W2) = dim(W1) + dim(W2) 3. 直接证明组成的：W(1)+W(2)—线性无关 直和的性质： W的交为零空间； dim( W1 + W2) = dim(W1) + dim(W2) refs/remotes/origin/master]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>matric</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera]]></title>
    <url>%2F2018%2F02%2F18%2FCamera%2F</url>
    <content type="text"><![CDATA[摄影知识三大元素 拍摄参数 | 场景 | 模式 | 光圈 | 感光度IOS | 快门 || :——–: | :——————: | :———————–: | :———: | :————: || 拍人像 | A模式-光圈优先 | 大光圈f/1.4、f/1.8、f/2.8 | 低 ISO &lt; 50 | A模式自动生成 || 拍夜景 | M-手动 或者 A | 大光圈 | 高ISO &gt; 400 | 大 = 1 / value || 晴朗的户外 | M-柔散迷人的景深效果 | 大光圈（F2.8） | 低 ISO &lt; 50 | 小 = 1/4000秒 || 快速的运动 | S-快门优先 | | | || 最常用的 | A-光圈优先 | 中等最好 | | 快门补偿曝光 | 光圈 摄影最重要的一个概念：光圈优先。光圈优先就是手动定义光圈的大小，相机会根据这个光圈值确定能正确曝光的快门速度。 光圈就是镜头里调节进光孔大小的装置。 光圈值： F1， F1.4， F2， F2.8， F4， F5.6， F8， F11， F16， F22， F32， F44， F64； 光圈大小：依次减小；进光量依次减小，相邻进光量相差一倍； 构图确定情况下（焦距确定），我们能控制景深的武器就只剩下光圈了。 大光圈（f/1.4、f/1.8、f/2.8等） 适用于光线不足时，增加曝光时间（快门速度变慢）； 背景模糊=景深浅：适用于拍人像（光圈数值越大，清晰的区域越小）； 小光圈（f/11、f/16、f/22等） 适用于光线充足时，捕捉时间； 背景清楚=景深深：适合拍风景（光圈数值越大，清晰的区域越大）； 中等光圈 镜头在中等光圈的时候成像最好（图片最清晰），成像最好的那档光圈就是最佳光圈； 景深：能够清晰成像的距离 景深浅，前景清晰，背景模糊；景深深，前景清晰，背景同样清晰； 拍摄时光圈越大景深就越浅； 拍摄时采用镜头焦距越长景深就越浅； 拍摄时相机与被摄对象距离越近景深就越浅。 调节位置：副拨码盘 感光度 IOS 高画质、低噪点与慢速快门 ISO &lt; 50 为低感光度 可以获得极为平滑、细腻的照片； 只要能够把照片拍清楚，就尽量使用低感光度。（宁可开大一级光圈，也不要把感光度提高一挡）; ISO400以上是高感光度 高的感光度能获得更快的快门速度; 但是高感光度的画质则是噪点比较大； 夜景的部份，则主要是利用在需要凝结瞬间的情境; 建议值：晴朗的室外使用ISO100；阴郁的天气使用ISO200；室内使用ISO400或更高。 调节位置 快门时间 快门时间 = 1 / value 快门速度 value 很大时：高速运动的瞬间被凝结了； value 很慢时：运动的过程被凝结下来 安全快门速度 快门值不慢于1/镜头焦距； 你使用的是50mm，快门值1/50便可以拍到一张不手震的照片了； 快门值设置 拍行走或快速移动时，设在1/250秒左右； 更快的自由落体或飞驰的物体，提高到1/400秒左右； 快速飞行时，设在1/800秒以上。 测光和自动曝光测光 测光范围：调节的方式 曝光和测光是一对双胞胎，如果不能准确测定光照强度，正确曝光就无从谈起。 点测光 ：只测取景框内一个小点的光线强度； 中央重点测光是简化的区域（平均）测光； 区域（平均）测光：加权平均得到光照强度； 曝光值：正值使拍摄对象更亮，负值则使其更暗]]></content>
      <categories>
        <category>Camera</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Outline and Technology]]></title>
    <url>%2F2018%2F02%2F18%2FComputerComposition-principle%2F</url>
    <content type="text"><![CDATA[第一章 计算机概要与技术 Proper Noun Full name 中文 acronym personal mobile device 个人移动设备 PMD Warehouse scale computer 巨型数据中心 WSC Liquid Crystal Display 液晶显示 LCD active matrix display 动态矩阵显示 Integrated circuit 集成电路 Central peocessor unit 中央处理单元 CPU dynamic random access memory 动态随机存储器 DRAM static random access memory 静态随机存储器 SRAM – 价格高于DRAM very large-scale integrated circuit 超大规模集成电路 VLSI clock cycle per instruction 执行每条指令所需时钟周期数的平均值 CPI System performance evaluation cooperative 计算机组织，为现代计算机系统建立基准测试集 SPEC Conception 计算机革命推动人类的进步 个人计算机和服务器 服务于个人，和服务于多人的一种可视化操作系统 嵌入式计算机：嵌入到其他设备中的计算机，一般运行预定义的一个或者一组应用程序。 云计算：集群服务器 软件即服务 现代微处理器： 理解现代微处理器硬件如何使性能提高200倍。 摩尔定律： 计算机设计者面临问题： 单芯片上的集成度没18-24个月翻一番，意味着驱动的快速变化。 使用抽象简化设计 抽象：表示不同的设计层次，从高层此种只能看到一个简化模型。 通过冗余提高可靠性 使用冗余部件提高系统的可靠性，并可以帮助检测错误。 学到啥 如何正确剖析软硬件，如何评价性能与功耗 程序入门概念 应用软件–&gt;系统软件–&gt;硬件执行 系统软件 提供常用的服务软件：操作系统，编译程序，加载程序和汇编程序。 操作系统 编译程序：将高级语言翻译为计算机识别的机器语言的程序 指令 0/1数字：即表述指令（计算机硬件理解并服从的命令），又表示数据（二进制位） 汇编语言 语言是一种指令（表示），程序是转换的过程。 汇编程序：将指令由助记符形式翻译成二进制形式的程序 汇编语言：以助记符形式表示的机器指令； 机器语言：以二进制形式表示的机器指令 硬件入门 正确剖析软硬件 基础硬件的基本功能 输入数据–输出数据–处理数据（数据通路和控制器）–存储数据 显示器 图像由像素矩阵组成，可以表示成二进制位的矩阵，称为位图（bit map） 处理器 逻辑上分为两部分：数据通路和控制器 数据通路：负责完成算数运算 控制器：负责指导数据通路 内存 内存：程序运行时的存储空间， 由多片DRAM组成 缓存 cache memory — SRAM 处理其内部的另外一种存储器 小而快的存储效应，作为DRAM的缓冲 抽象之一 - P15 该抽象被命名为计算机指令集体系结构 – 体系结构 硬件的实现方法必须依照体系结构的抽样 抽象系统中的一个关键接口是指令集体系结构–硬件和底层软件的接口 计算机网络 计算机不可缺少的功能 晶体管-硅制作的工艺–芯片chip 成品率的计算 性能 性能的评价因素 响应时间和吞吐量 增加性能和降低执行时间是一个倒数关系 CPU（Central Processing Unit） 性能及其影响因素 时钟周期数、时钟周期时间（时钟频率的倒数） CPU（t） = CPU ( 时钟周期数 ) / CPU ( 时钟频率 ) CPU 时钟周期数 = 程序的指令数 * CPI(每条指令的平均时钟周期数） 经典公式 ：CPU(t) = 指令数 * CPI / 时钟频率 功耗：使用能耗更合理 功耗：由于CMOS管0-1-0的跳变 能耗的来源是 CMOS 管开关动作中的消耗 一个晶体管能耗 = 1/2 负载电容 电压（平方） 一个晶体管功耗 = 1/2 负载电容 电压（平方）* 开关频率 单处理器–&gt;多处理器 原因： 增加多个微处理器，得到更大的吞吐量。不再继续追求单个程序运行在单个处理器上的响应时间 单处理器–processor or cores; 多核处理器(微处理器)– microprocessor 并行性 并行性对计算机性能十分重要，但它往往是隐蔽的 挑战：调度、负载平衡、同步、通信 硬件/软件接口：显示并行编程 并行性对计算机一直十分重要 程序员未来：显式并行编程，不单是串行 Iner Core i7 基准 SPEC CPU 基准测试程序 工作负载：运行在计算机上的一组程序。 基准测试程序：用于比较计算机性能的一组程序。 SPEC 采用单个的数字来进行归纳 SPECpower 功耗是有规定 称为：overall ssi_ops per watt 计算公式 谬论和陷阱 谬论：面向性能的设计和面向能量效率（功耗）的设计具有不相关的指标。 陷阱：用性能公示的一个子集去度量性能。 硬件和软件的设计者都采用分层的方法构建计算机系统，每个下层都对其上层隐藏本层的细节。 抽象：理解硬件和底层软件之间的接口，指令集的体系结构。 执行时间：唯一有效且不可推翻的性能评价指标。]]></content>
      <categories>
        <category>Hardware Interface</category>
        <category>Computer-Composition-Principle</category>
      </categories>
      <tags>
        <tag>Hardware Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HC-05-Bluetooth]]></title>
    <url>%2F2018%2F02%2F18%2FHC05-Bluetooth%2F</url>
    <content type="text"><![CDATA[HC-05-Bluetooth-ATResourse 这个软件只能设置HC-03 和HC-05,其他的还需要另外的软件 百度网盘 AT指令调试 先安装setep控件； 打开“蓝牙测试软件”，这样才会获取模块的信息； HC-05的模块进入绝对AT状态 按住按键在上电（或者EN脚接高电平）； 波特率 38400； 按照AT指令输入相应的设置；]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>Bluetooth</tag>
        <tag>AT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP8266]]></title>
    <url>%2F2018%2F02%2F18%2FESP8266%2F</url>
    <content type="text"><![CDATA[ESP8266 串口测试 串口WiFi，将串口数据发送到服务器上 工作： 连接wifi 开启服务器监听，连接到服务器 所需工具软件 下载串口调试工具sscom 这个调试工具在输入 AT command后,需要加同一个回车 硬件 ESP8266 USB转TTL下载器 接线方式 esp8266供电方式VCC = 3.3v EN 使能方式,上拉到VCC=3.3v AT指令测试 ATcommand 波特率的设置9600 或者115200 ESP8266有三种模式 第一种是客户端模式：Station 第二种是接入点模式：AP 第三种是两种模式共存:Station+AP 发送指令：AT+CWMODE=3 发送指令：AT+CWJAP=”SSID的信号名”,”密码” 建议：在之后的实验中，可以先用手机热点或者电脑热点来测试设备。 重启自动连接 EN：使能脚需要一直拉高 ESP8266 tcp测试理论知识 什么是TCP 什么是UDP？ 任何网络服务器：理解为监听在指定端口的程序，负责接收数据并且做出反应。 需要在同一个网络下进行测试。ep：ESP8266和主机处于同一个路由器下。 手机作为服务器，进行TCP测试 测试原因：台式机没有无线发射器；实验室路由器没有充钱 后续： 在手机上测试，明白其原理，后续还是需要无线发射器。 软件 电脑：下载串口调试工具sscom 手机：手机TCP调试助手USR-TCP-Test 硬件 ESP8266 USB转TTL下载器 测试过程 手机开启热点，等待被连接； 电脑打开 sscom ,进行AT指令调试； AT+RST // 重启模块 AT+CWMODE=3 // 设置模式Station+AP 第三种是两种模式共存 AT+CWJAP=”SSID的信号名”,”密码” // 连接手机热点 AT+CIFSR // 查看ESP8266连上热点后的IP 注意 AT指令输入后，都会输出OK, 才表明配置成功 此时手机WLAN扫描可以看到ESP8266的wifi 如果不知道名字，可以先配置连上手机热点，看连接设备的名字。 手机打开调试助手–USR-TCP-Test 手机作为服务器，进行端口监视； 选择 tcp serve 配置端口号（IP 地址是手机网络的IP，不能更改（电脑也一样）） 点击激活，记下此时出现的 IP 和 端口port 切换到电脑 sscom, 进行AT调试 AT+CIPSTART=”TCP/UDP”,”IP”,port // 输入serve的IP和port,TCP/UDP用大写 手机端显示tcp连接成功的设备 此时，ESP8266和serve建立起了tcp连接；后面进行数据发送。 电脑 sscom，AT调试 AT+CIPSEND=4 // 设置数据包的字节数 输入 ABCD ESP8266作为服务器，进行TCP测试测试条件 在上面软硬件的基础上； ESP8266 连上手机wifi热点 测试过程 电脑端sscom AT+CIFSR // 查看ESP8266连上热点后的IP，使用START下的IP AT+CIPMUX=1 // AT+ CIPMUX=1 时才能开启服务器 AT+CIPSERVER=1,333 // 开启 server 后自动建立 server 监听 此时ESP8266开启了服务器监听 手机USR-TCP-Test，选择TCP Client 输入ESP8266模块的START_IP,和port; 连接服务器 输入数据进行发送 服务器接收到的数据 将手机换成笔记本 只需要换一个TCP调试工具 NetAssist。 完成了ESP8266的数据收发问题 接下来结合arduino,进行数据测试 参考链接]]></content>
      <categories>
        <category>WIFI</category>
      </categories>
      <tags>
        <tag>ESP8266</tag>
      </tags>
  </entry>
</search>
