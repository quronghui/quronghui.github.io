<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[优化时间和空间效率]]></title>
    <url>%2F2019%2F07%2F06%2F%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[优化时间和空间效率 Introduction 数据结构：对大量数据的组织和研究 算法分析：对算法运行时间的评估 运行时间最坏的计算。 数学知识 指数 和 对数之间的转换 级数公式 当 i 趋近于无穷时，得出一个公式的表达式 模运算 除法需要很高的时间复杂度 归纳法证明： base case 成立 k成立 – &gt; (k+1)成立 反证法证明 递归实现 Algorithm 对于一个问题：给定某种算法并且确定其是正确的 最重要的一步便是：计算时间和空间资源 相对增长率 四种增长关系的定义 将其放在坐标上表示： 1）常数：是直线 2）乘级：直线方程 四种定义：在坐标上理解其含义 1) 大O： &lt;= 的关系；是上限值 2) 小o : &lt;的关系 3) omega: &gt;= 的关系；是下限值 4) theta: = 的关系 相对增长率 算法分析中，相对增长率是很重要的度量 关系表达式中 大O：精度表示的时候 1）各种简化的方式都是可能发生的 2）低阶项可以忽略；常数项可以省略 取 lim [ f(N) / g(N) ] 极限的值，便能得到增长率的关系式 运行时间的计算 算法的时间复杂度：针对的是大量数据的计算，小量数据不用花费时间设计算法 1）考虑数据读入的时间效率； 2）低效的算法：虽然算法复杂度低，但是对数据的处理基本上处于停滞状态 2）算法足够有效，也不产生其他问题，这样的算法才是好的 最大O时间单元的计算： 大O：是上限值 1）一次赋值：一个时间单元 2）一次return value ：一个时间单元 3）+ - × / ：一种运算算一个时间单元 4）包括循环里面的：赋值，比较运算–&gt;一次一个时间单元 5）省去低阶和常数 计算时间成本：将O( ) 作为上限后，有几种简化的法则，不用一步步去加 1）for(;;) –&gt; 时间=测试语句 × 迭代次数;化简为O(N); 2）for(;;)嵌套 –&gt; O(N^2); 3) 计算任何一件事，都不要超过一次 最大子序列：只能顺序取一个序列，中间不能有跳过 几种常见算法的时间复杂度 对分查找： 在排好序的数组中进行的这半查找 它提供了在 O(log N)的时间内进行查找 幂运算 还是利用指数折半进行计算 线性程序：顺序执行的程序 O(N) 非线性程序：O( N * log(N) ) 时间效率优化时间效率编程习惯 传递复杂参数：使用指针； 值传递：需要产生一次复制的操作 循环和递归 循环：当递归中有大量的重复时，使用循环； 各类查找算法 应用一： 面试题39：数组中出现次数超过一半的数字. 题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字 存在三种解题思路； 快速排序数组；改变数组值 考虑数组下标的特性；改变数组值 考虑数字超过一半这个特性，并且只遍历一边数组，不改动数组； 应用二：面试题40：最小的k个数。题目：输入n个整数，找出其中最小的k个数应用三：面试题41：数据流中的中位数。题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么 中位数就是所有数值排序之后位于中间的数值 题目注意：数据流中读出，数目随时间变化而增加；需要考虑数据容器。 数据结构的选择 ​ a. 数组：进行插入排序，需要移动O(n)个数, O(1)得到中位数； ​ b. 排序链表：和插入排序数组一样； ​ c. 二叉搜索树：插入 – 平均O(log(N))，最差O(N); 查找O(logN),最差O(N) ​ d. AVL树：让左右子树的高度差不超过1，插入O(logN), 查找O(1); 接口很难实现 ​ e. 最大堆和最小堆：保证数据平均分配到两个堆中； ​ 最大堆：保存着小于中位数的那些数； ​ 最小堆：保存着大于中位数的那些数；、 ​ 3. 代码没有实现 应用四：面试题42：连续子数组的最大和. 求所有子数组的和的最大值,并输出子数组 解题思路二：分析数组规律 连续子数组的最大和： 当前面的和小于0时，删除啊前面的序列，从当前位置开始； 应用五：面试题43：从1到n整数中1出现的次数。题目：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数 解题思路：字符串的应用 将整数转换为字符串进行处理 将大数进行分段处理的实现 应用六:面试题44：数字序列中某一位的数字. 题目：数字以0123456789101112131415…的格式序列化到一个字符序列中 解题思路：对大数的位数进行区分； 通过对数字位数进行区分得到规律;]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>O(N)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F2019%2F06%2F26%2FString%2F</url>
    <content type="text"><![CDATA[数据结构–字符串字符串 feature 末尾有一个’\0’，内存覆盖要有警惕； 解决问题 a. 字符串中空格的替换 b. 两个数组，将B数组插入A数组 字符串的情况 方法 时间 空间 数组未有递增的规律； 复制到新的空间 O(N) O(N) 不允许使用新的空间 原数组保证足够的空间大小 从后往前进行查找替换空格 O(N) O(1) 字符串相关知识 字符串 赋值给数组 字符串结尾影藏 ‘\0’; 字符串赋值给数组：数组要分配内存空间存储 字符串赋值给指针：指针指向字符串地址，不分配内存空间 网络编程中，URL参数含有 #，空格，则不能正常访问 将特殊字符进行替换 替换规则 ： % + ASCII(十六进制表示) 字符串赋值数组 *使用变量定义长度时，不可在定义时同时进行初始化赋值，需要在之后进行赋值 123const int length = 100; char string[length] ; strcpy(string, "hello world"); 字符串： 是一种简单，有效表示大数的方法 字符串的赋值 同一个字符赋值给两个指针； 这两个指针保存的地址是一样的，所以改变其中一个的值，另外一个也会变 123456789101112char name = 'a';char *str = &amp;name;char *pbeg = &amp;name; printf("str adress is %p value is %c:\n", str, *str);printf("pbeg adress is %p value is %c:\n",pbeg, *pbeg); char temp = 'b' ;*str = temp; // 注意，这里赋值的是值；不能是地址 printf("str adress is %p value is %c:\n", str, *str);printf("pbeg adress is %p value is %c:\n",pbeg, *pbeg); 1234str adress is 0x7ffda0eefe36 value is a:pbeg adress is 0x7ffda0eefe36 value is a:str adress is 0x7ffda0eefe36 value is b:pbeg adress is 0x7ffda0eefe36 value is b: 字符串的动态空间申请 1char *number = malloc(strlen(str) + 1); //字符串不使用sizeof() 非面试题应用一：题目：字符串转换到int类型，使用atoi函数可以轻松完成类型转换应用二： 题目：Int型整数，转化为字符串 还可以通过一个函数：sprintf 直接将整数写到字符串中； 123char str[50];int n = 21345;sprintf(str, %d, n); 面试题应用一：面试题5：替换字符串中的空格应用二：面试题17：打印1到最大的n位数应用三：面试题19：正则表达式匹配 根据题目的要求：举例子后找出规律； 应用四：面试题20：表示数值的字符串。判断字符串，是不是数值应用五：面试题38：字符串的排列 。题目：输入一个字符串，打印出该字符串中字符的所有排列 字符串的排列： ​ a. 将字符串分为两部分：第一个字符，后面的所有字符； ​ b. 通过第一个字符和后面的字符一一交换；然后固定第一个字符；（全排列的首字母） ​ c. 然后将后面的字符：再次分为两部分，递归过程a,b; ​ d. 直到后面的字符为 ‘\0’ 打印 字符串的组合：]]></content>
      <categories>
        <category>data struct</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码质量]]></title>
    <url>%2F2019%2F06%2F26%2F%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[代码质量的要求代码编写的要求 代码的规范性 代码的完整性 需要进行三方面测试 边界值测试：循环条件是否正确 错误的处理方式 全局变量的处理方式：检查全局变量，进行相应的错误处理 代码质量完整性练习应用一： 面试题 16不使用库函数，实现pow函数的功能，求base的exponent次方 异常情况：需要异常处理 通过举例的方式，找出特殊的情况 base = 0.0; exponent &lt; 0; 需要异常处理 double 精度数的比较 12double d1=0.0000001，double d2=0d 由于精度不一样，一般不直接使用 “==” 设定一个允许的误差值，对两个double类型数据做差，求绝对值再和允许的误差做比较来判断是否相等。 C规定，float 类型必须至少能表示6位有效数字 全局变量对局部变量的修改 局部变量中的值修改，调用修改函数后，会对全局变量产生影响； 应用二：面试题17：打印1到最大的n位数 相当于考察数据结构[字符串]，算法实现[递归和循环] 大数的存储：采用字符串或数组进行表示 : char i : 表示 ‘0’ - ‘9’ 每一个字符，保存一位 如何打印 方法一：通过对数加1，进行循环打印 方法二： n位的十进制数，相当于 n 个从0到9的全排列，递归实现全排列 符合阅读习惯：098 只能答应 98；从第一个非0开始打印]]></content>
      <categories>
        <category>Sword offer</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕设的方向]]></title>
    <url>%2F2019%2F06%2F22%2FOpenLink%2F</url>
    <content type="text"><![CDATA[毕设的方向 基于物联网设备的边缘计算系统的搭建 研究背景​ 随着大数据、云计算、物联网、人工智能等技术的快速发展，万物互联时代加速到来，连接到网络的设备数量和数据量都呈现快速增长态势。 ​ 如果按照传统的方式，将嵌入式设备采集到的数组一起发送到云平台，将会造成网络的严重负载。云计算模式的缺陷日益突出，而边缘计算为解决工业互联网智能制造过程中数据分析和实时控制提供了有效手段。 ​ 在健康监测等领域，边缘计算可以让需要针对用户进行无监督机器学习的可穿戴设备获益颇多。此外，在未经事先学习的情况下，定制的应用程序若要实现迅速推理，通常需要极高的数据处理能力作为支撑，而这正是边缘人工智能的专长所在。 研究内容 边缘人工智能化：嵌入式设备方案 + 物联网云平台 + 边缘计算框架的搭建和部署 嵌入式设备方案 (嵌入式方案可以更换) 看物联网如何颠覆传统设计，这十个方案给你答案！ 题目一：基于STM32单片机的物联网远程数据监控系统 物联网云平台 通过WIFI无线通讯技术将数据上传到物联网云平台，通过物联网云平台将数据可视化， 可进行远程监控和计算 边缘计算框架的搭建和部署 研究边缘计算的相关框架，以及如何将模型迁移到物联网的基础设备上 将一部分的计算放在嵌入式设备上，减少云平台和嵌入式设备间的直接交互； 通过嵌入式设备本地的计算，发送控制信号； 物联网 + 边缘计算 ：是一种理论的研究。仿真或者是 边缘智能或将打通物联网应用之路的最后一公里 物联网+边缘计算：减少物联网设备中数据的发送，在边缘进行处理 我们能得到什么 计算的迁移 我们手机端 或者后台的算法可以迁移到嵌入式设备上； 嵌入式设备就不需要一直与后台交互才能得到指令； 我们的睡眠监测，如果用户不想打开手机的话； 我们就需要将数据的计算放在嵌入式设备上，让其计算后得到报警指令； 当我们嵌入式设备量很多的时候 比如：我们的空中检测仪，当数量很庞大时，一起使用是，必然造成蓝牙传输的阻塞，导致我们APP上波形显示延迟度高 我们就可以在嵌入式设备上，进行数据的筛选，将需要的数据发送到手机端后者后台，后台在用已选择的数据进行计算； 边缘计算 让嵌入式设备：不在只做数据的采集端和搬运工； 让嵌入式设备，在原有的基础上智能化；这也是5G商用后，物联网设备需要进行的革命 这次研究后 结合物联网平台的使用：在嵌入式设备采集到数据后，不是一直需要Android进行收集，而是通过物联网平台进行展示，通过物联网平台进行数据处理，从而缩短研发成本； 结合边缘计算： 将计算嵌入到物联网设备中，而不是脱离网络后，嵌入式设备就不能工作； 当嵌入式设备量很大时：我们能有效降低能耗，减小延迟 无线睡眠全态监视系统电路设计设计背景 眠呼吸暂停症是一种很常见的睡眠呼吸疾病，根据研究调查，在美国约有 24%的成年男性及9%成年女性或超过 200 万人口患有此疾病，在中国台湾至少有 35 万人也有此问题。一般在诊断患者是否罹患睡眠呼吸暂停症是指患者在睡眠中出现呼吸暂停和低通气的总次数超过每小时 5 次。 采集模块 心率和血氧采集 ：Max30102; 鼾声感测电路：检测呼吸暂停，呼吸阻塞时的声音 睡眠姿态检测电路：身体是否平躺； 判断和处理机制 通过三方面的数据判断用户是否处于呼吸暂停状态； 唤醒方式： 硬件唤醒：震动加蜂鸣器 软件唤醒：手机APP短信； 数据保存： 外挂FLASH进行保存； 蓝牙发送到手机； 应用 是关于睡眠呼吸暂停检测的；他的新方法是加了呼吸暂停时鼾声的检测； GLO：物联网智能灯设计背景 GLO 不仅仅是一种灯，您可以将其改变成您喜欢的任何颜色。 而 GLO也可以在您不在的时候充当您家中的安全监控器。 当任何人进入房间时，GLO 将自动打开灯。 当房间变暗时，GLO 可以自动打开灯。 应用场景 睡眠模式状态，或者工作模式下灯管的颜色切换； 当任何人进入房间时，GLO 将自动打开灯； 1（1）是一个比较新的GLO物联网灯，这个灯可以根据RGB混合出喜欢的颜色，以及作为自动开关的灯；（2）也可以作为室内预警检测；（3）是否能作为睡眠呼吸暂停的辅助设计，变成一个呼吸灯； 其他 加一个磁铁在底部，制作成悬浮的智能灯 制作一个迷你雷达，检测周围是否存在人； 室内环境传感器装置设计背景 如今，人们更关心他们居住的室内质量，因为这与他们的健康息息相关。拥有更好的生活质量的重要性包括知道您的生活条件得到改善。 一些办公室可能安装了自己的室内环境传感器，以便为员工提供更好的工作环境。但我怎么知道我住的楼宇甚至是我租的房间都能提供良好的生活条件？ 采集模块 温湿度传感器 SHT31 气压和海拔高度 BMP280 空气质量传感器 CCS811 光传感器 响度传感器 带适配器的 PM2.5 传感器（PM1.0，PM2.5，PM10） 应用场景 室内环境传感器装置，主要就是能够实时、便携的检测除室内的环境；]]></content>
      <categories>
        <category>毕业设技</category>
      </categories>
      <tags>
        <tag>毕设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一维数组和二维数组的查找]]></title>
    <url>%2F2019%2F06%2F15%2F%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[数组中元素的查找数组方法的应用 缺点 空间效率应用差 优点 内存连续：根据下标在O(1)时间读写任意元素； 数组实现简单的哈希表 一维数组 解决问题：在一个长度为n的数组里的所有数字都在0到n-1的范围内。找出重复的数字 和面试官交流的问题： 数组是否排序； 数组是够可以改变； 数组的情况 方法 时间 空间 数组排序 遍历下标和数组元素值 O(n) O(1) 未排序，可改变数组 先排序O(nlogn)，在遍历(O(n))： O(nlogn) + O(n) O(1) 创建哈希表，记录次数 查找O(1) O(n) 下标和值对应相等，不相等则进行交换 O(n) O(1) 未排序，不可改变数组 创建额外O(n)数组，复制条件：数值为m元素放在下标为m处的位置 遍历一遍O(n) O(n) 二分查找法：中间元素进行分半 O(nlogn) O(1) 时间和空间复杂度：查找元素时候的花费 创建哈希表的时候，以数组的下标进行分就行；扫描一遍数组，便能通过O(1)的时间查找出有无重复 二维数组 解决问题：二维数组中元素的查找 和面试官交流的问题： 数组是否有递增的规律； 数组的情况 方法 时间 空间 数组未有递增的规律； 遍历数组 O(n^2) O(1) left to right 递增 col : up to down 递增 从右上角进行遍历 O(row) or O(col) 数组注意事项 bool 类型 1#include &lt;stdbool.h&gt; //C中包含头文件 while 和for 循环 for : 准确知道循环次数； while：准确知道循环结束条件 数组的长度 1length = sizeof(array) / sizeof(int); /* 分32位和64位的系统，判断数组中一个元素占4个字节 */ 二维数组的表示 通过一位数组的方式，表示二维数组 1matrix[row*cols + col] == number) 题目强调不能修改数组中的元素 1const int *number; 数组越界情况 array [ N ] ：元素访问从 array[0] – array[ N-1 ] array [N] : 访问不到 %p 1printf("%p\t", (&amp;numbers)[col]); //printf函数族中对于%p一般以十六进制整数方式输出指针的值，附加前缀0x 数组和指针一位数组 数组名的概念： 下表和数组名一起使用，用于标示该集合的某个特定值； 数组名的值：是一个指针常量，也就是数组第一个元素的地址； 常量：是不允许修改的 错误： 1int a[10]; int b[10]; a=b // 错误的，数组元素的复制要通过循环；数组名是一个指针常量 下表引用 下标应用 间接访问 :相互等价的； 12array[subscript]; *(array + (subscript)) // 首元素的地址，加上一个偏移量，间接访问某一个元素 在使用下标的地方，可以使用对等的指针表达式来替代； 效率问题 在正确使用的前提下：下标绝不会比指针更有效率，但是指针有时会比下标有效率； 可读性 &gt; 细微的时间效率； 数组和指针 数组声明：编译器将根据声明的元素数量，为数组保留内存空间；然后在创建数组名，指向这段空间的起始位置； 指针声明：只为指针本身保留内存空间，并不为任何整形值分配内存空间； 在未被初始化之前：指针变量并未初始化指向任何现有的内存空间， 作为函数参数的数组名 传递给函数的参数：传值调用—- 通过传递值的方式进行； 传址调用：传递一个指针，通过指针进行间接访问，实现对数据的操作； 字符数组的初始化 12char message1[] = "hello"; // 字符数组的初始化char *message2 = "hello"; // 表示字符串常量，指针指向其存储位置； 多维数组 多维数组： int array[3] [4] : 一维数组的一维数组；包含3行元素，每行包含4个元素 存储顺序 行主序存储：按照最右边下标率先变化的原则； 数组名： 一位数组名：值是一个指针常量，类型：是指向元素类型(int)的指针；int *p = array; 二维数组名：多维数组第一维的元素实际上是另外一个数组； matrix: 数组名表示一维中的第一个元素 1int matrix[3][3]; // matrix 下标 int matrix[3] [3] 第一维元素的地址和值表示：第一维其实是每一行数组的首地址 123matrix; //表示一维中的第一个元素的地址，指向包含3个整形元素的数组的指针 (matrix + 1); // 表示一维中的第二个元素的首地址；*(matrix + 1) -- &gt; matrix[1] ---&gt; matrix[1][0]; 间接访问第一维的元素，表示的是每行中首元素 第二维元素的地址和值的表示： 12*(matrix + 1) + 2 ---&gt; matrix[1] + 2 ---&gt; ; // 表示的是第一行第二列元素的地址*(*(matrix + 1) + 2) ---&gt;*(matrix[1] + 2) ----&gt; matrix[1][2]; // 间接访问：表示的是元素 指向数组的指针 123int matrix[3][10];int (*p)[10] = matrix; // 二维数组的表示；逐行访问；(*p)[10] --&gt; ( (*p) + 10) // 表示的是首行的地址 二维数组的列下标：必须是确定的 一维数组应用：应用一： 一维数组: 可以修改数组的情况下 ，找出数组中重复的数字应用二：一维数组 :不可修改数组的情况下，找出数组中重复的数字应用三：面试题21：调整数组顺序使奇数位于偶数前面 将数组中的元素，分成性质不同的两部分 二维数组应用：应用一：题目：如何动态申请二维数组空间​ 1. 三种方式动态申请二维数组空间，并进行初始化，打印地址 应用一：面试题 4： 二维数组中元素的查找，数组中重复的数字应用二：面试题29：顺时针打印矩阵。题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字 考察边界条件的判断：全部梳理出来之后；就是顺序书写代码； 题目扩展： 逆时针打印呢？]]></content>
      <categories>
        <category>data struct</category>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表和双链表应用]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%2F</url>
    <content type="text"><![CDATA[链表节点的应用 动态分配的指针：使用后要进行销毁 对于需要判断的题目：使用bool类型创建函数； 比链表难得应用：就是树 链表插入的知识点 链表的插入：通过画图 链表的存储空间是不连续的，需要插入新的节点的时候 12#include &lt;stdlib.h&gt;$ malloc 双链表的插入：学会画图理解指针 链表出现的错误：指针变量定义，没有初始化 1error：memory access violation；segmentation violation 双等号 1return s-&gt;Next == NULL; // 这个 == 表示比较的意思；比较两个的值，返回值是0/1 链表插入的应用应用一 ：单链表节点的插入应用二：双链表节点的插入链表删除的应用应用一: 面试题18（一）：在O(1)时间删除链表结点 O(1)时间限制：不能按照常规思路，查找前驱节点； 将pToBeDeleted 的 Next_node 复制到删除节点位置，删除的是Next_node： 存在三种情况 a. pToBeDeleted 的下一个节点不为空； (n-1)O(1) –&gt; 不是尾节点的有n-1 b. 链表中只有一个头结点； – 指向指针的指针保证链表删除后，地址不会变 删除节点位于尾部： 需要遍历得到前驱节点 O(n) –&gt; 一个尾节点 应用二：面试题18（二）：删除链表中重复的结点 a. 如何删除：通过遍历时，节点值是否存在重复，进行节点的释放； b. 同一个值，赋值给两个不同指针时，两个指针的地址是一样的； c. 但是在删除重复节点时，需要一个节点一个节点的释放 链表的查找应用一:面试题22：链表中倒数第k个结点 当问题使用一个指针遍历一次解决不了问题时，通过两个指正进行快慢遍历 应用二：面试题23：链表中环的入口结点, 一个链表中包含环，如何找出环的入口结点？链表的反转应用一：面试题24：反转链表1. 题目一：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 2. 题目二：定义一个函数，输入一个链表头结点，从链表中的第 k 个节点到 m个位置进行反转，返回反转链表的头结点； 3. 题目扩展三：将链表前面k个节点进行反转； 用题目二的思路 应用二：面试题24(四)：从倒数第k个节点反转链表链表的合并应用一：面试题25：合并两个排序的链表 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 复杂链表应用一：面试题35：复杂链表的复制。将复杂链表复制，返回一个新的链表头指针]]></content>
      <categories>
        <category>data_struct</category>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sword_offer]]></title>
    <url>%2F2019%2F06%2F03%2FSword-offer%2F</url>
    <content type="text"><![CDATA[Sword_offer code 题目分析，判断条件，边界检测 总体规划 开始时间：2019.6.12号 看的书籍：LinuxC ，数据结构和算法C描述，剑指offer 参加招聘公司：编程问题很严重 开始时间： 结束时间 做的事情 2019.6.12 2019.6.30 1. 剑指offer的代码编程题目思考模式代码框架 2. C编程语言的基础知识 LinuxC，再过一遍 3. 软件设计模式 广泛阅读 UML设计模式 时序图 技术面试 ( 6月份 完成 ) 基础知识 编程语言：多翻阅几次C 的相关知识； LinuxC C Primer 数据结构：熟练掌握链表，树，队列，栈，哈希表； 链表的插入和删除 二叉树的遍历 算法：查找和排序算法 二分查找； 归并排序； 快速排序； 题目的分析方法 代码结构的布局 代码的检验 数据结构 熟悉数据结构之间的特点，才知道如何选择 数据结构类型 类型 特点 数组和字符串 最基本 连续内存分别存储数字和字符 链表和树 出现频率最高 操作大量指针，留意代码鲁棒性 栈 算法采用方式 与递归紧密相关 队列 算法采用方式 与广度优先遍历算法相关 哈希表 解决问题：第一次只出现一次的字符 解决的问题 数据结构类型 创建 解决问题 哈希表 数组实现，下标实现键值对 第一次只出现一次的字符 数组 数组的相关题目解答 字符串 基础数据结构，字符串的相关应用 链表 链表中节点的插入 树的应用 树的应用 算法和数据操作 算法和数据描述相关问题 高质量代码 高质量代码需要考虑的方面) 时间效率和空间效率+]]></content>
      <categories>
        <category>offer</category>
      </categories>
      <tags>
        <tag>sword offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C_C++_test]]></title>
    <url>%2F2019%2F05%2F27%2FC-C-test%2F</url>
    <content type="text"><![CDATA[C/C++ testQuestion 数组和指针间的相互表示？ 用指针表示某一个数组元素 常量的表示 e 后面是指数，不能有小数：e0.4 关键字 全部都是C / C++关键字 关键字小写； C/C++ 没有太大区别 类型转换 假定x和y为double型，则表达式x=2，y=x+3/2的值是 3/2=1 3.0/2.0=1.500000 y = (double) 3/2; –&gt; 1.5 取余数 0 % 2 余数和商都是 0； printf 123以下程序段的输出结果是（ ）。int a=1234；printf("%2d\n",a); %d前面的数字表示打印格式的位数。 如果输出的内容位数不足将会在左边补足空格 如果输出的内容位数超过%d前面的数字会将内容全部输出，%d前面的数字相当于无效 typedef and #define 代码：判断哪个不是指针 1234#define INT_PTR int*typedef int* int_ptr;INT_PTR a,b;int_ptr c,d; typedef 给已有类型声明一个别名，故c和d都是int_ptr类型也即都是int *类型； #define宏定义，在预编译时直接进行简单替换，即原式变为：int* a,b; 这相当于是int *a, int b; define 宏定义时，加括号 define 后，应该是一个整体； 12#define FUN(A,B) A+B FUN(2,3)*4 = 2+3*4;#define FUN(A,B) (A+B) FUN(2,3)*4 = (2+3)*4; 12int``* p1, p2; ``// p1是指向int的指针，p2是intint *p1, *p2; // p1和p2都是指向int的指针 #define #define只是在预处理阶段将a替换为相应数值，具体替换的值只与define在文件中的位置有关； #define 将值替换后给最近的函数使用； 基本概念 一个 C 语言程序是由：函数组成 不是程序组成 创建对象，是否需要初始化 需要初始化 静态对象：需要初始化； 局部变量：需要初始化； 不需要初始化 全局变量，不初始化时为0； 循环 123do &#123; ... &#125;while(); / 加；号 / 关于 return 语句 在主函数和其他函数中均可出现 可以在同一个函数中出现多次 1# if else; /* 一个函数中可以出现多次，一次运行只能有一个return进行返回 */ 字符常量 用单引号 关于“深拷贝” 会拷贝动态分配的成员对象 32 位 的long and int 一样，占4个字节； C语言中最简单的数据类型包括 1整型、实型、字符型 不能作为重载函数的调用的依据是： 基类型相同的两个指针变量之间，不能进行的运算是 数组 数组a[3] [ 4 ] 不正确引用 1a[3] [ 4 ] /* 0-(N-1)：访问不到a[3][4],超出界限 */ 数组定义时候： 列必须确定，行可以不确定 数组越界问题 1a[2] = &#123;'0', '1', '2'&#125;; /* 数组越界了 */ 数组打印 1printf("%d\n", s); /* %d 只打印首地址 */ 数组的赋值： 在数组定义的时候进行赋值； 在被调用函数中，不需要考虑形参数组的大小; 形参和实参 实参和与其对应的形参各占用独立的存储单元 形参在编译时是不会分配存储容间，在调用时才在栈里分配 输入输出语句 输入和输出并不是C++语言中的正式组成成分｡ C和C++本身都没有为输入和输出提供专门的语句结构｡ 输入输出不是由C++本身定义的,而是在编译系统提供的I/O库中定义的｡ 用C程序实现的算法可以没有输入但必须要有输出 函数 sizeof and strlen 12$ sizeof(); /* 结尾包含字符 '\0' */$ strlen(); /* 结尾不包含 */ sizeof（str）:str中间有 \0 时，算作一个字符； strlen（str）: 遇到 \0时，便停止计算大小 123456789101112131415161718192021222324void strarray()&#123; char x[] = "abcde"; char y[] = &#123;'a', 'b', 'c', 'd','e'&#125;; printf("sizeofx[] = %ld\n", sizeof(x)); /* 包含末尾的\0 */ printf("strlenx[] = %ld\n", strlen(x)); printf("sizeofy[] = %ld\n", sizeof(y)); /* 字符长度 */ printf("strleny[] = %ld\n", strlen(y)); /* 包含所有字符 */ char *p = x; printf("p = %ld\n", sizeof(p)); /* 指针类型占得字节数 */ printf("strlen = %ld\n", strlen("std\n007\1\\")); char a[] = "a\0b\054de"; /* 是一个8进制数 */ printf("strlen = %ld\n", sizeof(a));&#125;sizeofx[] = 6strlenx[] = 5sizeofy[] = 5strleny[] = 10p = 8strlen = 9strlen = 8 malloc malloc函数进行内存分配是在什么阶段: 执行阶段 #include 12#include &lt;&gt; /* 从标准库文件目录下搜索，对于标准库文件搜索效率快。*/#include "" /* 从用户工作目录下开始搜索，对于自定义文件搜索比较快，然后搜索整个磁盘。 */ 结构体 32位系统中，结构体中的对齐 12345678struct A &#123; int a; char b; short c; /* 4, 1, 2 byte 内存对齐：4，2，2*/&#125;;struct B&#123; char b; int a; short c; /* 1, 4, 2 byte */&#125;; 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。 Token 划分 自加运算符 ++ ++运算符的操作数必须是左值；a++; a++ 之后便是表达式，不是左值了，因此在使用 a++ ++ 就是错误 位运算 按位与、或、异或、取反 C++ 基类的公有成员是其私有派生类的（ 私有 ）成员 C++ 不能重载的是 12$ '.*' ; '::' /* 不能重载的是 */$ '*' ; operator delete /* 可以重载 */]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[red_and_black_tree]]></title>
    <url>%2F2019%2F05%2F27%2Fred-and-black-tree%2F</url>
    <content type="text"><![CDATA[red and black tree摊还分析 摊还时间界 长时期运行中的这种数据结构的行为，就像是每次操作花费O(log N)时间一样； 每次操作花费时间； 自顶向下伸展树 伸展树的三种变换形式： 单旋转：Y成为新的root；X成为Y的right_child; 一字型：最左边的Z依次上升到root；X下降到右边； 之字形：双旋转；Z成为=root；其他的左边的是leftchild;右边的是rightchild 自顶向下 自底部向上：是一棵AVL树 1) 单旋转； 2）双旋转；dafa 自顶向下的展开：生成三棵树 1）L 左子树；&lt; 中间的树；&lt; R右子树； 自顶向下的算法： 1）应用：简化之字形展开； 2）一步步展开，旋转后分别存储为三棵树； 3）进行整理合并； 红黑树 红黑树是具有着色性质的二叉查找树： 二叉查找树： 左子树的所有关键字 &lt; X-root &lt; 右子树的所有关键字 红黑树着色： 1）黑色节点：一个圈表示；红色节点：两个圈表示； 2）root：黑色； 3）一个节点是红色，那么其子节点必须是黑色； 4）从一个节点到一个NULL指针的每一条路径必须包含相同数目的黑色节点 新元素的插入情况 插入节点的parent 是黑色 —&gt; 直接插入就完成； 插入点的parent是红色，且parent 的兄弟是黑色：—&gt; 自底向上插入 插入点的parent是红色，且parent 的兄弟是红色：—&gt; 自顶向下插入 自底向上插入 插入的节点满足条件： 1）二叉树的性质：left &lt; X &lt; right; 2）红黑树的性质：颜色和黑节点路径； 新节点的插入： 1）新项作为树叶放到树种； 2）插入操作进行：颜色的改变和树的旋转 插入点的parent是红色：parent 的兄弟是黑色 自底向上插入：先插入，在平衡 a.形式：一字链和之字链； b.平衡条件：单旋转和双旋转； c.颜色的改变：根节点由黑转红； 自顶向下插入 插入点情况：插入点的parent是红色：parent 的兄弟是红色 先平衡再插入 a. 执行一次颜色翻转：图； b. 单旋转（两个连续的红色节点）； c. 使得插入点的parent是黑色； 先进行一系列的操作，将插入节点的parent变成黑色；直接插入节点就行。 自顶向下删除 自顶向下的插入： 1）先平衡，保证插入节点的父节点再插入的时候是黑色节点； 2）不影响红黑树的性质三 自顶向下的删除： 1）先平衡，保证删除的树叶在删除期间是红色的； 2）不影响红黑树的性质四]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>red_and_black_tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algorithm_design]]></title>
    <url>%2F2019%2F05%2F25%2Falgorithm-design%2F</url>
    <content type="text"><![CDATA[algorithm design 算法的实现转为算法的设计；递归和循环实现算法 算法 适用场合 排序和查找 二分查找，归并排序，快速排序 回溯法 二维数组上搜索路径，回溯法通过递归实现（当限定不能递归时，用栈模拟） 动态规划 求某个问题最优解，(1)该问题可以分为多个子问题；(2)子问题的最优解组合成该问题的最优解自上而下进行分析，(3)子问题存在重叠现象；通过循环的方式避免重复计算 贪婪算法 在动态规划思路之后，提示某一个特殊选择后，得到最优解 位运算 数字的二进制形式对0/1的操作，有与、或、异或、左移和右移 递归和循环 递归的实现：通过调用函数自身 每一次函数的调用，需要在内存栈中分配空间用以保存参数，返回地址和临时变量； 每次往栈中压入数据和读取数据都需要时间； 应用动态规划解决的问题：递归分析，循环实现 可以使用递归的思路分析问题； 从下而上通过循环实现代码； 递归引起的问题： 调用栈溢出，每个进程的栈容量优先。 应用一：面试题：斐波那契数列，青蛙跳台阶排序和查找 查找排序算法 适用场合 二分查找算法 在排序数组中（部分排序）：查找一个数字或者某个数字出现的次数 哈希表二叉排序树 考察重点在数据结构，不是算法 快速排序 最后得到的就是两个已排序的数组，加一个枢纽元 应用一：快速排序算法的实现应用二：面试题11：旋转数组的最小数字回溯算法 回溯算法的定义：蛮力法的升级版 它从解决问题的每一步的所有可能进行尝试，选择一个可行的方案，一步步的得到最终的约束条件 适用的题目： 路径的选择，或者是背包问题； 二维矩阵上路劲的查找问题 解题的方法： 回溯法属于递归的性质，通过栈进行实现； 每一步的选择，对下一步将产生影响；如果一直没有找到路径，就回溯到上一个节点，从新选择路劲尝试； 应用一 :面试题12：矩阵中的路径应用二: 面试题13：机器人的运动范围 动态规划贪婪算法 动态规划：需要O(n^2)的时间和O(n) 空间； 贪婪算法：需要O(1)的时间和空间 动态规划类求解 动态规划的三个特点： 求某个问题最优解：该问题可以分为多个子问题； 子问题的最优解组合成该问题的最优解 子问题存在重叠现象；通过循环的方式避免重复计算 自上而下进行分析问题，从下往上解决问题； 动态规划从下往上解决问题，中间数据怎么存储 中间数据通过一维 / 二维 数组 进行存储； 贪婪算法 贪婪算法特点 希望在动态规划中的，每一个局部都是最优的； 然后组合起来才是最优的解； gcc 编译时：需要链接数学库 12Greedy_maxProduct: Greedy_maxProduct.o $(CC) $^ -o $@ -lm // 在链接成目标文件时，加上动态链接库函数 -lm 动态规划应用一: 剪绳子 :给你一根长度为n绳子，请把绳子剪成m段贪婪算法应用一：剪绳子 :给你一根长度为n绳子，请把绳子剪成m段 位运算概念 了解进制的概念： 几进制：在一系列递增数中，一位能表示的最大值 &lt; “几”进制 比如：时分秒的六十进制 位运算： 与，或，异或，左移和右移 按位进行 右移：针对符号位时 正数：符号位为0；右移n位时，补n个0； 负数：符号位为1；右移n位时，补n个1； 1n = n &gt;&gt; 1; // 不能只写 n &gt;&gt; 1 应用一： 计算一个整数转换为二进制后，1的个数 方法1：将整数n循环右移 每进行一次运算：n &amp; 1，整数n右移一位：n&gt;&gt;1 缺点：当n为负数时后，循环右移导致n的二进制数全为1；判断会进入死循环 方法2：整数n不移动，1循环左移 每进行一次 : n &amp; 1，与位 1 左移一位：1 &lt;&lt; 1; –&gt; 10 缺点：32位的整数，需要循环32次 方法3： 整数 n &gt; 0; 那么其二进制数中至少有一个1； 整数 n 的二进制有多少个1，就能进行多少次运算 1234while(n)&#123; ++count; n = (n-1) &amp; n; // 将整数n与(n-1)按位与运算；&#125; 一个数减去 1 之后和原来的数进行位与运算：相当于把整数二进制表示中最右边的1变成0； 分治算法 分治算法： 至少含有两次递归才算是分治算法 分治算法 最大子序列； 线性时间树遍历方法； 归并和快排； 非分治算法：只使用一次递归 dijkstra 算法 随机化算法 定义： 在算法期间，随机数至少有一次用于决策。 该算法的运行时间不仅依赖与特定的输入，还依赖于所发生的随机数 贪婪算法其余的知识点 最小化处理 平均完成时间最小化：先处理需要时间更短的作业； 最后完成时间最小化：进行大小搭配，组合 huffman 算法 用于文件压缩：字符是不同频率出现，文件压缩才是可能的； Huffman 算法： 1）将树组合成森林； 2）一棵树的权中等于他的树叶的频率之和； 3）选择权值最小的两棵树，进行merge； 4）两棵老树成为新树的左右儿子； 5）新树的权总是那些老树权值和； 集装箱处理问题 联机装箱：必须把每一件物品放入一个箱子后才处理下一件物品； 脱机处理：将所有输入数据全部读入后才进行处理 联机处理： 下项适合算法：检查箱子空余空间是否还能装下刚刚处理的物品，不能就创建新空间； 首次适合算法： 1）一次扫描箱子，需要O（N）； 2）把新的一项物品放入足够能放入的第一个箱子中； 3）只有放不下时才创建新空间 脱机处理 将所有物品信息全部排序后，在进行处理‘ 首次适合递减算法和最佳适合递减算法]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[graph]]></title>
    <url>%2F2019%2F05%2F24%2Fgraph%2F</url>
    <content type="text"><![CDATA[Graph AlogrithmDedine graph 图Graph = [ 顶点（vertex），边（edge） ] 1）每一条边：点对（v,w）属于V，或者弧（arc） 2）点对有序：图是有向; 3）无向图的边：还具有第三种成分，权（weight） 考虑有向图和无向图中的边的区别 1）（u, v）和（v, u）; 2) 在无向图中，他们是相同的边，不是圈； 3）再有向图中，他们是不同的边，是圈 连通图：每一个顶点到其他顶点都存在一条路径； 1）强连通图：有方向的； 2）弱连通图：没有方向； 3）完全图：每一对顶点间都存在一条边的图； 邻接矩阵：一个二维数组表示每一条边； 1）每条边（u, v）：A[u][v] = 1，相邻; 2）有v个顶点，空间需求则是O( V^2 ); 图的标准表示：邻接表，通过散列表进行完成； 1）将每个顶点进行内部编号：1 - V; 2) 将有相邻边的内部编号和顶点名字存入指针数组中； 3）具有相同顶点指向关系的顶点存在同一个指针数组中 3）最终要输出顶点名字而不是内部编号 拓扑结构 拓扑排序：是有向的无圈图的顶点组成； 1）有向边（v, w）：v要在w之前弄完； 2）邻接表：找出任意一个没有入边的顶点，存的是V顶点的出边； 出队前的入度表：某个顶点，被其他顶点指向；则入度加1； 1）指向：分为直接指向；间接指向（v1 –&gt; v4）有路径完成指向 2）入队：将所有入度为0的顶点放入一个初始为空的队列中； 4）出队：每出队一个元素，删除该顶点 最短路径算法 赋权路径长：权重值的和； 无全路径长：从u -&gt; v 的边数 负值圈：边的权重是一个负值； 1）负值圈的出现：最短路径就不确定； 2）在没有负值圈时，从s到s的最短路劲为0 无权最短路径 方法 1）某个顶点s作为输入参数，找出s到其他顶点的最短路径； 2）最短路径：边数和最小；找相邻的顶点，边为1 广度优先搜索： 1）按照顶点s到其他顶点的距离，进行分层处理； 2）每个顶点追踪三个信息： 3) 距离d： s到其他顶点的距离一开始为无穷，不可到达； d=0的点是选中的点； 4）p(v)：簿记变量 – 显示实际的路径； 5）know：对应顶点被处理后置为1； Dijkstra 算法 解决单源最短路径问题的方法； 边有权重； 有向图； 此时d 的更新：权重之和； 1）每个顶点否会被申明，也就是出队； 2）此时表中的d路径是否更新：d保留的是最短路径； 3）更新的顶点：是被申明顶点直接指向的点 网络流问题 s称为发点，t称为收点 1）除了s点和t点外，其他的顶点v ：总的进入流 = 总的输出流； 2）根据上面的点：更新图中的值 3）算法结束时的最大的流量：s 到 t 可以通过的最大流量 G: 图 G(f)：流图：算法任意阶段包含的流信息； G(r): 残余图，每条边还能再添加多少流 要以路径上最小的流进行调整： G（f）:保存的是此次各边上流的信息； G（r）: 用G - G(f) 后的流的信息； 1）更新残留图G(r)的信息，直到t由s出发是不能到达的，算法中止 最小生成树 最小生成树： 无向图中进行; 最小生成树存在：当且仅当G是连通的 最小生成树：构成的是树，不是图 1）无向的图； 2）包含所有节点； 3）顶点只要被包含为节点就算成功，只考虑更新每个节点的最小值， prim算法 计算最小生成树的方法 把每一个节点当成root，往上加； 每一步添加一条边和一个顶点到树上； kruskal 算法 连续按照边的权重，由小到大开始选边；并且当选的边不产生圈时，确定这条边； 算法处理的是一个森林； Union/Find 的merge方法进行树的合并 深度优先搜索的应用 深度优先搜索：先序遍历的推广； 访问到该点，标记该点被访问过，并且对尚未标记的所有领接顶点递归调用深度优先搜索； 使用邻接表，保证每一条边被访问一次； 背向图 实线：递归调用有效； 虚线（背向图）：顶点被访问过，无效 边（v, w）：如果w被访问过，那么Num(w)便是有值的，此时称为背向边 双连通性 任意顶点删除后，图还是连通的； 割点：该顶点删除后，图将不在连通； Num / Low Num():访问到该顶点时的编号； Low(): 背向值指向的顶点编号 欧拉回路 附加条件： 1）每条边只能走一次； 2）笔不能离开纸张； 3）还要回到起点，终点和起点在同一个位置； 欧拉回路： 1）当图是连通的，并且每个顶点的度（边的条数）是偶数才能存在； 2）边为偶数：入度+出度 解决这个问题： 1）找出有尚未访问的边的路径上的第一个节点p； 2) p作为root进行另外一次优先搜索，得到一个圈，每个点的度为偶数，将此时的回路拼接到原来的回路上； 3）循环到所有边都遍历位置（一个顶点会出多次，多条边） 欧拉回路实现： 1）增加数据结构：保留路径作为一个链表，便面重复扫面； 2）邻接表：有一个指针指向后一个元素]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Union_ADT]]></title>
    <url>%2F2019%2F05%2F24%2FUnion-ADT%2F</url>
    <content type="text"><![CDATA[Union ADT等价关系 等价关系：满足三个条件 1）R：表示的是两个元素之间的关系； 2）电器连通性：是一个等价关系 动态等价性问题 S 是一个等价类：将与元素a有关的元素都放在一个等价类中 Union/Find 算法：查找合并算法 1）若要确定等价关系a~b：搜索a和b是否都在同一个等价类中 2）Find运算：返回包含给定元素的集合（等价类）的名字； 3）添加关系：a,b不在同一个类中，使用并运算Union，合并为新的等价类； 4）find(a) = find(b),当且仅当a和b在同一个集合中 Union/Find算法FInd 算法1.Find：为了实现find的查找 1）我们用树表示成一个集合，集合是森林； 2）数组中只需要保存的信息便是父指针； 3）数组中保存的元素为 P(i)：P[i] 表示元素i的父亲 Union 算法一：让第二棵树成为第一棵树的子树。（没有偏向） 算法二–按大小求并：总让较小的树成为较大的树的子树。 1）任何节点的深度不会超过O(log N) 算法三：按高度合并，时的深度前的书成为深的树的子树； 1）当两棵树的深度一样时，合并后深度才会增加]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>Union</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sort_ways]]></title>
    <url>%2F2019%2F05%2F22%2FSort-ways%2F</url>
    <content type="text"><![CDATA[Sort ways 数据结构：考虑数据的存储方式，数据的快速查找和取出 排序前提 假设： 1）数组中元素类型为整数； 2）内部排序：整个排序工作在主存中完成 3）外部排序：在磁盘上完成排序 算法： 1）每个算法都将接受一个含有元素的数组和一个包含元素个数的整数。 内部排序插入排序 算法： 每次取后一个元素，和前面已排好序的数组进行比较； 1）每次都是取后一个元素p，和前面的数组进行比较，如果比p大，那么就往后移一位，替换覆盖； 2）前面的数组都是排好序的； 3）以前的想法：每一个元素：和所有的元素比较，先找出最小值 插入排序的运行时间 反序输入：O(N^2) 正序输入：O(N) – 元素不需要排序，将元素输入到数组需要花时间 逆序 逆序性质 当 i &lt; j, a[ i ] &gt; a[ j ] ：这边是一个逆序对（ a[ i ] ， a[ j ] ） I = 是数组中的逆序对数； 排序好的数组是没有逆序的，所以插入排序运行时间 O(I + N); 交换相邻的两个元素，相当于交换逆序对。 插入排序 互异数：假设没有重复的数； 在插入排序的时候，每次比较交换删除的不止一个逆序对 希尔排序 算法： 比较相距一定间隔的元素来工作，各趟比较所用的距离h(k)，随算法的进行而减小，直到只比较相邻元素的最后一趟排序为止 shell缩小增量序列 1）用 a[i] 数组和 a[ i + h(k) ]进行比较； 2）初始值：h(k) = N/2 ; 3）递减：h(k) = h(k) / 2 希尔比较的方式 增量的选择 使用 shell 的希尔增量最坏情况 O(N^2)，类似插入排序 使用 hibbard 的希尔增量最坏情况 O(N ^ (3/2)) sedgewick 增量排序：其他的几种增量形式，降低运行时间； 堆排序 算法： 通过优先队列方式：进行delete_min，得到排序数组； 优先队列花费时间O(N * log N)，只是需要附加数组 delete_min 实现 每次将最后的单元，存放刚刚删除的元素，得到从小到大的排序数组 1）delete_min 删除最后的元素后，整个堆以递减的顺序得到数组–max 堆； 2）现实中构建的堆：和二叉堆的性质相反之处 – （任一节点的关键字大于其儿子节点的关键字）； 3）delete_min：得到从小到大的排序数组 和二叉堆不同的是：0位置包含元素 归并排序 算法 合并两个已经排序的表，将两个表插入到第三个表中完成排序 N 为元素的总数： 1）将N分为前 / 后半部分数据各自递归排序； 2）将排好序的两部分进行合并，两个指针分别指向A,B；每次比较后插入一个元素；直到最后一次比较，插入两个数据 3）得到一个排序数组 归并排序 运行时间：O(N * log N) 归并排序：递归排序 快速排序 快速排序 当枢纽元位于中间，平均时间 = O(N log N); 当枢纽元选择为最小元素，最坏的情况 = O(N^2); 类似于归并排序，快速排序也是归并排序； 快排算法 假设：元素互异 在数组中选择枢纽元 v； 将数组分割为三部分，a [left] = { x &lt; v }；a[center] = {v} ; a[right] = { x &gt; v }； 三部分各自排序后，组合在一起 枢纽元选择： 三数中值分割法 ：选择中间 v = [ ( left + right) / 2 ] 分割策略： 1）将枢纽元与最后元素交换，使得枢纽元离开要被分割的数据段； 2）i从第一个元素开始；j从倒数第二个元素开始；相对于枢纽元，i和j的元素才交换 3）将所有小元素移到左边，大元素移到右边； 4）当i 和j交错时，停止移动，此时 i指向一个大元素，j指向一个小元素； 5）将枢纽元和i的元素交换 6）分割策略注意：当i和j遇到和枢纽p相同时，i和j停止移动 排序的下界 – 决策树 决策树：用于证明下届的抽象概念； 决策树：一颗二叉树； 决策树表示： 只是用比较进行排序的算法，都可以通过决策树表示； 决策树：只有输入数据非常少的情况下决策树才是可行的。 画出 a, b, c三个元素的比较情况 每次是两个元素的比较，进行分支 决策树的性质 1）深度为k的决策树（二叉树），最多有(2^k)个树叶； 2）反之，具有L片树叶的深度至少是log L 比较次数 = 决策树的深度； 只使用元素间比较的任何排序算法，需要进行 桶式排序 桶式排序提供了一个前提： 输入数据都需要小于一个M的整数 外部排序 外部排序的限制 内部排序算法：将数据装入内存，这样数据的访问便可以不按顺序进行； 外部排序：数据的输入输出是在物理设备上，只能按照顺序访问； 外部排序的模型： 外部排序比内部排序对设备依赖性更高； 建立的模型：在磁带上进行； 访问某个元素时，需要把磁带转动到正确位置 算法： 使用归并排序的merge例程； 四个磁带空间：不停地将两个磁带中的数据（顺串）作为输入，另外两个磁带空间作为输出；直到所有的顺串合并为一个长的顺串； 顺串：将每组排过序的记录叫做顺串； merge算法进过的次数 这个算法是两路merge：两个输入，两个输出 算法需要 [ log( N/M )]趟工作，每次合并2^n个数据； 1）N：总得自己数； 2）M：内存的大小； 3）N/M：数据被分成多少个顺串； 多路合并merge 两路合并：只需要比较两个元素的最小值； k路合并： 每次需要比较k个元素的最小值； 1）优先队列的方法，delete_min 2) 算法需要 [ log(k) [ N/M ] ]趟工作，每次以2^n进行合并； 3）十盘磁带：k = 5；一半作为输入，一半作为输出； k路合并，需要2k盘磁带 多相合并 k 路合并，需要（k+1）盘磁带 为了减小磁带数量 顺串最初的分配有很大的关系，决定后续多少趟的进行； 顺串不均分在k个磁带上，第（k+1）个磁带用于输出数据 替换选择 目的：考虑顺串的构造 替换选择 1）首先读入M个记录放在队列上，然后delete_min将最小值输出到磁带上； 2）读入下一个记录是和 最小值比较，大于–放入优先对列；(二叉堆的构建) 3）优先队列少一个元素，将小于每次delete_min的元素，存入优先队列的死区，直到顺串完成构建； 4）这个元素用于下一个顺串；（堆排序的做法：最小值取出后放在最后一个位置） 5）持续上述做法，直到优先队列大小为0，完成顺串构建 总结 内部排序算法的选择： 插入排序；希尔排序；快速排序； 通过数据的输入量的大小决定 外部排序算法： 合并 merge 是中心思想]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[priority_queue]]></title>
    <url>%2F2019%2F05%2F19%2Fpriority-queue%2F</url>
    <content type="text"><![CDATA[priority queueIntroduction 优先队列： 具有队列的性质，进行insert and delete; 此时的delete 要删除最小值（某些元素具有优先级） 如何让队列实现优先级 优先队列的一些实现方式 链表实现优先队列： 1）插入是无序：insert – O(1); delete – O(N)，进行遍历 2）插入是有序：insert – O(N); delete – O（1） 二叉树实现 1）平均时间 O(log N); 2) 删除最小值：的时间不是平均时间 上面两种方式的运行时间太长 二叉堆 当堆（heap）不加任何修饰词使用时，就是值得该数据结构 二叉堆的性质 堆：是完全二叉树 性质 任意节点的关键字小于所有后裔的关键字 1）底层：元素依次从左到右填入； 2）高为h 的完全二叉树节点数：2^h — (2^(h+1) -1) 3) 完全二叉树的高是logN 4) 完全二叉树：用数组，不用指针 5) 0位置的数组不存储数据 堆序性质 任意节点的关键字小于它所有后裔的关键字； 堆的操作 insert: 1）完全二叉树的插入：从左边依次插入，所以不用考虑顺序； 2）上滤策略：插入 i 节点后，破坏了堆序性质：将其父节点的关键字交换到 i位置；原来i节点的关键字放到父节点 （i/2）的位置； 3）插入的关键字最小的话，i将是1；我们在数组的0位置放置一条哑信息（放一个很小的值 = 小于等于堆中的任意值） 4）这样插入和移动的时间高达 O(logN) delete_min 1）堆序性质：最小值应该是根节点的值； 2）下滤策略： + 删除根节点的值后，一步步的从根节点的儿子节点选出相对较小的关键字，放入root中； 将最后的元素，上升到被提到根节点的位置; 平衡树，满足堆序性质 Other decreaseKey 降低位置P处关键字的值 破坏序的平衡：采用上滤策略 increaseKey 增加位置P处关键字的值 破坏序的平衡：采用下滤策略 构建堆： 将N个节点以任意顺序放入树中，保持结构特性； 在调整成一棵有堆序的树 如果对一棵乱序的树，进行堆序化 最大的虚线条数：计算堆中所有节点的高度和，等于N的最大上限 O(N) 1）任意节点的高度 = 它到叶子节点的最大路径值； 2）理想二叉树：节点数 = 2 ^ (height +1) – 1 3）理想二叉树：节点高度和 = 2 ^ (height +1) – (height +1) 我们此时算的最大虚线条数：要调整的次数 通过理想二叉树 ，计算出最大上限 堆的应用 问题描述对于N个元素，读出第k个最小值： 1）N个元素得有序； 2）find 第k个最小值； algorithm 1A 1) double for cycle； 2）排序时间：O(N^2) algorithm 2A 1) 先取k个元素组成一个排序数组array_order； 2）每次去一个元素和array_order进行比较插入； 3)中位数的时间界限 = ：O(N^2) algorithm 6A – 堆排序（不用指针） 1) 构造堆最坏情况：O(N); 2) 每次的delete_min：O(log N); 3) k 次删除，总时间：O(N + k logN) 4) K = N/2; 运行时间：O(N * log N) 找出中位数的时间界限 = (N logN) d-堆 d-堆：是二叉堆，只是所有节点都由d个儿子 左式堆左式堆性质 合并merge：需要把一个数组拷贝到另外一个数组中，需要花费O(N)时间； 合并操作需要的数据结构：需要使用指针 左式堆：需要用到指针 左式堆性质 1）左式堆：也是二叉树，左式堆不是理想平衡的。 2）节点X的零路径长Npl：从X到一个没有两个儿子的节点的最短路径长。 3）任意节点X，左儿子的Npl &gt;= 右儿子的Npl，不满足便需要调节 1)树偏向左增加深度，存在有节点形成的长路径构成的树，更有益于合并操作。 2）节点个数：右路劲上有r节点，左式树至少有（2^r - 1）个 左式堆的操作 左式堆：实现堆之间的合并 1）左式堆和二叉堆的insert不兼容的； 2）二叉堆没有指针，插入后没有返回值 斜堆 斜堆：具有堆序的二叉树，只是不存在树的结构限制； 斜堆 merge： 不需要附接空间保存路劲长度 也不需要测试确定何时交换儿子 没有Npl零路径的限制 二项队列定义 二项队列： 不是一棵堆序树，而是堆序树的集合，称为森林 二项队列的实现 k 是二项队列的高度，包含的堆序树集合 = { B(0), B(1),……B(k-1) } 性质 : 每一个高度至多存在一颗二项树，超过就需要merge 实现方式：B(k)高度的二项树构成：将B(k-1)的树全部附接到B(k-1)的根节点； 二项队列的操作 insert 插入一个节点后 没有打破 性质，则保留为B(0)的堆序树； 打破了性质，进行合并 delete_min 按照堆序树：进行递归删除 Difference priority queue 性质 操作 二叉堆 1) 完全二叉树的性质：2) child 依次从左到右填满3) 通过数组存储，存储为树的形式； 1) insert: 进行堆序的平衡2）delete_min: 删除根节点，下滤策略平衡 d-堆 本质是二叉堆，只是所有节点都由d个儿子 同上 左式堆 1)用于堆的合并merge；2）任意节点X，左儿子的Npl &gt;= 右儿子的Npl3）需要指针进行 1）merge：根据性质—-确定何时交换儿子 斜堆 1）用于堆的合并merge；2）去除左式堆 Npl 的限制 二项队列 1）用于堆树的merge，森林；2）任意高度至多包含一棵二项树； 1）merge：B(k)树的形成— 将大的B(k-1)的树，依附在小的B(k-1)的root上]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hash_ADT]]></title>
    <url>%2F2019%2F05%2F19%2Fhash-ADT%2F</url>
    <content type="text"><![CDATA[Hash ADTIntroduction 散列表 以常数平均时间执行插入、删除、和查找的技术； 散列表的ADT 包含有关键字的具有固定大小的数组 散列 将关键字，通过散列函数映射到，0-tablesize 的表中存储 1）散列函数的选择； 2）分配到同一值的冲突解决； 3) 关键字：字符类型的不同，决定了散列函数 散列函数 散列函数的选择 key mod tablesize ：余数是几，放在相应的表中存储； tablesize：取素数，减少（key mod tablesize）为同一个值的概率 所以会造成冲突 分离链接法—解决冲突 构造链表数组：解决冲突 1) 分配一个存储空间：存储 0 - tablesize； 2） 每一个 tablisize:分配一个数组，存储相同的值的关键字； 3) 每个数组：分配一个头指针 header */ 保证素数：减少占同一个值的情况 表头：如果链表不涉及删除，那么可以去掉表头 开放定址法 分离链接法 每个新单元插入：需要指针；malloc分配存储单元 开放定址法 创建一个大的数组，对数据进行散列存储； 冲突：按照函数F 进行探测，查找空单元 线性探测法 探测函数： F(i) = i; // 一步步的往前探测，直到出现空单元 探测因子 介于0-1之间； 计算插入一个函数时：成功探测和不成功探测，需要的次数 出现问题： 一次聚集：占据的单元会形成一块区域 平均探测法 探测函数： F(i) = i^2 ; // 消除一次聚集的问题 tablesize 为素数 一旦表的填充过半，如果tablesize是素数，中能找到一个空的单元 问题： 消除一次聚集，产生二次聚集 双散列 探测函数： F(I) = i * hash(x) hash(x) = R - X mod R 再散列 当分配的 0-tablesize 空间产生冲突时： 选择创建一个 2 * tablesize 空间； 将原先的关键字，迁移到新的空间 散列表 二叉树 find 不能迅速找到一定范围内的所有项 快速找到 other 不需要存储有序的信息， 存储有序的信息 对图论是有效的；在线拼写检验程序]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tree]]></title>
    <url>%2F2019%2F05%2F17%2Ftree%2F</url>
    <content type="text"><![CDATA[Tree 文件系统：三种访问结构；前中后序访问 树的操作基本时间：O(logN) 通过递归的方式实现树 树的实现树的元素 – 节点 树中节点的关系 1）n(1) –&gt; n(2)：n(1) 是n(2)的祖先； 2）n(1) != n(2); n(1) 是n(2)的真祖先； 3）parent 、child、sibling、leaf、grandparents、grandchild 节点数的长度length：从1递增到n的 1)节点深度depth：从root到n(i)的唯一路径长；root(depth) = 0 2)节点的高度height：从n(i)到树叶leaf的最长路径; leaf(height) = 0 3)一棵树的深度 = 高度 树的一种表达方式 12345struct treenode&#123; ElementType element; struct treenode firstchild; //第一个儿子节点 struct treenode nextsibling; //下一个兄弟节点&#125;; 树的遍历 遍历的顺序 针对于父节点先处理还是后处理： 1）先序遍历：先父节点，在左儿子节点，最后右儿子。 打印出目录结构 2）后序遍历：先左儿子节点，然后右儿子，在父节点。 打印出每个文件占的块block大小（文件最小单位：块） 二叉树 二叉树：是一棵树，每个节点的child，不能多于两个。 平均深度的计算： 1）平均二叉树：depth = O( sqrt(N) ) 2）二叉查找树：depth = O(logN) 二叉树实现 二叉树的图形表示：圆圈加直线 二叉树的每一次插入： 调用malloc创建一个节点； 调用free删除后被释放； Null 指针： 每一棵N节点的二叉树，需要（N+1）个NULL指针 每一个叶子节点：包含两个NULL指针 二叉树应用–表达式树 编译器的设计领域，计算表达式的应用： 中序遍历策略：中缀表达式； 后序遍历策略：后缀表达式； 前序遍历策略：前缀表达式； 树定义：表达式 操作数：叶子节点 运算符：父节点 构造表达式树： 把后缀表达式 转化为中缀表达式，每一部分加上括号 方法相反：操作数压栈，读操作数时弹出操作数； a. 用指针指向：每个操作数，以及每次运算得到的大操作数 操作数的指针压栈，顺序是左child，右child； 读到操作符时弹出操作数：每次弹出两个操作数； 操作符做为父节点； 先弹出的做为右child；后弹出的为左child 将每次操作后得到的大操作数指针：压入栈中； 最后有一个指针指向这个树：将指针压入栈中 栈中只有一个指针 查找树 一 ： 二叉查找树ADT 二叉查找树： 1）每个节点：指定一个关键字值； 2）关键字互异，没有重复值； 3) 关键字：左子树的 &lt; 小于X节点 &lt; 右子树的 二叉树的创建 空间创建的时候：以节点数N来进行创建的。 平均深度是O(logN)，不用担心栈空间用尽 二叉树的删除： 当被删除节点：包含两个child节点时； 用该节点右子树的最小数据代替该节点的数据，并递归的删除那个节点； 懒惰删除： 当元素x的出现频率&gt;1时，当删除x一次，只是频率减一，树不发生变化 AVL 树：是带有平衡条件的二叉查找树 AVL树的平衡条件 平衡条件1：每个节点的左右子树具有相同高度 平衡条件2（最终）：一棵AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树 AVL 特性破坏：插入新的节点后，破坏了原来的AVL树特性 插入新的节点，破坏了AVL的深度，插入的节点会变大，导致不在同一层 旋转：重新平衡插入后树的深度 新的节点插入树的方式 四中插入方式： 单旋转 元素插入是：左左插入和右右插入 双旋转： 元素插入是：左右插入和右左插入 旋转 单旋转发生的操作： 插入节点n的：父节点p往上升一级，n的祖父节点g往下降一级； p的另外一个孩子，高度不变，换到相反的一边 形成新的AVL树； 插入节点n和父节点p，祖父节点g 进行比较： 1）n &lt; p &lt; g : 破坏AVL平衡的话，单旋转便能达到新的平衡； 2）p &lt; n &lt; g : 破坏AVL平衡的话，双旋转才行； 3）原先节点p 的另外一个孩子，调整到另外一边 4）插入多个数据的时候：单双旋转都需要进行； 5）旋转除了保证AVL高度平衡外；还需要满足二叉树关键字大小的特性 双旋转发生的操作 插入节点n的：父节点p往上升二级，到达n的祖祖父节点gg 的位置，往下降一级； p节点的其他孩子：在左边child的就分配到左边（做另外节点的右child）； 伸展树 伸展树的思想： 当一个节点被访问后，节点就要经过一系列AVL树的旋转到达根节点。 不需要考虑存储的花费 一棵伸展树每次操作的摊还代价是：O(log N) 进行M次操作的时间就是 O(M logN ) 展开： 类似于前面介绍的旋转的想法，旋转的实施上有了选择 情形一：之字形 zig-zag AVL那样的双旋转 情形二：一字形 zig-zig 查找树二：B-树 阶为M的B-树具备下列的结构 非root 和 非叶子节点：包含的儿子数 （M/2 – M） 所有节点的高度是一样的； 所有的关键字包含在叶子节点上； 内部节点：只包含判断信息； 内部节点： 以圆圈作为边框， 判断信息形式：( A : B ：C …) 具有的儿子数目：( child &lt; A ) and ( A &lt; child &lt; B ) and ( B &lt; child &lt; C ) … 判断信息的形式：( A: - ) 儿子数目：两个儿子，( child &lt; A ) and ( A &lt; child ) 3 阶 B-树 : 2-3 B树 非root 和 非叶子节点：包含的儿子数 （1 – 3） M=3阶 B树 插入新的关键字 增加内部节点：其儿子数目在 （M/2 – M）之间 同一层调整不成功的话：增加树的深度（保证叶子节点在同一深度） Difference tree 作用 时间复杂度 表达式树 分析树–编译器中分析树不是二叉树：表达式树的扩充 查找树一： – 二叉查找树 递归实现查找 O(logN) AVL树– 带有平衡条件的二叉查找树 要求每个节点的左右子树：height 差 &lt; 1插入关键字后：进行新的平衡–通过旋转 O(logN) 伸展树–不带平衡条件的二叉查找树 节点的深度：不做限制节点就要经过一系列AVL树的旋转到达根节点。 O(M logN) 查找树二：B-树 平衡M-路树，很好的匹配磁盘平衡的条件：内部节点的儿子数 (M/2 – M)； 平衡树方案 AVL 和 B-树 树的实现基础知识 树的几种特例 二叉搜索树：左边节点值 &lt; root &lt; 右边节点的值 二叉堆：任意节点的关键字小于它所有后裔的关键字； 完全二叉树的插入：从左边依次插入，所以不用考虑顺序； 红黑树：红黑树是具有着色性质的二叉查找树； 树实现的两种方法：递归和循环； 由于递归在尾部的算法出现(尾部递归)，所以使用迭代更加有效. 迭代：递归是不停的调用自身，迭代是通过叠加旧值产生新值 树的遍历： 前序，中序，后序，层次遍历 二叉搜索树的知识 二叉树中删除节点 代码中没有给出，实现太过复杂 情况1：删除没有孩子的节点； 不存在重新建立连接的问题 情况2：删除只有一个孩子的节点； 把这个节点的：双亲和孩子连接就行，仍然保持二叉树的特性； 情况3：删除有两个孩子的节点； 不删除这个节点，删除其左子树中值最大的那个节点 二叉搜索树的插入： 默认没有重复的节点 数组实现二叉搜索树： 最重要的条件：数组元素的下标，应该和树中节点的位置对应 对应关系：树的深度为 – depth，树最多能存储 2^(depth + 1) - 1 个节点 数组的空间大小至少是 2^(depth + 1) - 1 数组下标 数组下标：从0开始，所以我们假定0位置不存节点，从位置1开始存储； 节点N的双亲节点 N/2；左孩子 2N；右孩子2N+1; 序列化和反序列化二叉树 序列化： 二叉树遍历为前序遍历序列，中序遍历序列； 反序列化： 由前序和中序 序列：反序列化二叉树； 应用：面试题7 前序和中序 的反序列化 – 缺点 二叉树不能存在重复节点； 需要将两个序列都读入后才能进行反序列化 序列化规则：进行序列化和反序列化 序列化：前序遍历后输出一个规则的字符串 1"[1,2,3,null,null,4,5]" 反序列化：只根据前序遍历得到的序列构建二叉树； 构建二叉树 (用的同一个接口)应用一 ： 面试题 7 ：根据前序遍历和中序遍历，构建一颗二叉树 应用：[]应用二：静态数组实现二叉搜索树，能实现节点的插入，搜索，前序遍历应用三：链式构建二叉搜索树,实现节点的插入，搜索，递归遍历 这是C和指针上面的内容；实现节点插入，构建二叉搜索树 应用二相当于数组的实现；应用三相当于链表的实现 找出中序遍历的下一个节点应用一：面试题 8：找一颗二叉树中序遍历的下一个节点，节点有指向父结点的指针 多了一个指针，指向父节点； 对称树判断应用一: 面试题26：树的子结构 题目：输入两棵二叉树A和B，判断B是不是A的子结构 没有说明是二叉搜索树，因此是普通树，存在重复节点； 树的值类型是double，判断相等的时候； 1-0.0000001 &lt; (num1 - num2) &lt; 0.0000001 应用二：面试题27：二叉树的镜像 。题目： 请完成一个函数，输入一个二叉树，该函数输出它的镜像 解题思路： a.镜像的概念：从根节点开始，根节点含有左 or 右子树；交换左右子树； b.判断条件：root-&gt;pLeft != NULL || root-&gt;pRight != NULL; 应用三：面试题28：对称的二叉树。题目请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的 如果是对称的树，树中的节点就存在重复，该树就不是二叉搜索树 解题思路： 123456789101. 思路一： a. 利用以前的代码：先将树A进行镜像，得到树B; mirror_recursively_binatyTree.c b. 然后判断 树A 和树 B 的结构是否一样 Substructure_inTree.c c. 也可以通过前序遍历得到两棵树的数组，比较数组是否相同； 2. 思路二： a. 不用直接得到镜像的树B，假定一种遍历方式：先遍历root，然后遍历右子树，最后遍历左子书； b. 在遍历的时候，同时判断和 A树的关系 c. 特殊情况 Aroot 树为空 ，镜像树对应相等 树中某一些节点为NULL，这时候镜像树是不对称的; 树和队列 将两种ADT数据抽象类型融合在一起； 应用一：面试题32（一）：不分行从上往下打印二叉树。 层级遍历二叉树 遇到的问题 入队的节点是树的节点：这个可以通过改变Queue接口中的QUEUE_TYPE, 修改成BinaryTreeNode * 这样解决； 但是入队后，队列执行一次后就判断为空: 我一开始写的queue.c有问题，queue-&gt;rear没有处理好； 题目扩展 广度优先遍历，或者是有向图，还是一棵树，都需要用到队列； 应用二：面试题32（二）：分行从上到下打印二叉树。 每层打印之后换行 解题思路： 和面试题32（一）是一样的思路； 在打印换行的时候，需要知道每一层有多少个节点，需要两个变量进行表示； 树和栈应用一：面试题32（三）：之字形打印二叉树 之字形打印的思路：通过画图能看出来 通过栈实现：两个栈结构进行打印 保存节点的顺序 打印奇数层：左子节点 –&gt; 右子节点 打印偶数层：右子节点 –&gt; 左子节点 之字型打印：默认要分行 把一个栈打印完了之后就可以分行，不用去记录每一层多少个 应用二：面试题34：二叉树中和为某一值的路径. 题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。 解题思路 ​ a. 路径：起始于根节点，结束于叶子节点； ​ b. 前序遍历：需要将路径中的节点进行入栈，作为路径的保存。 ​ c. 节点遍历后，需要回溯到上一个节点； 注意的是：打印条件–&gt; 1if( currentSum == expectedSum &amp;&amp; is_leaf(pRoot) ) 压入栈后的节点：如何顺序打印路径； 方法：通过双栈模拟队列，实现栈的打印 二叉树后遍历的判断应用一： 面试题33：二叉搜索树的后序遍历序列。输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果1.解题思路： ​ a.根据后序遍历中，root在最后一个，将序列分为两部分； ​ b.左半部分 &lt; root &lt; 右半部分 (当左半部分出现大于 root， 将后面的所有节点归于右半部分) ​ c.依次判断每一部分时候满足； （出现错误：右半部分出现了小于root的节点序列） 树和链表应用一：面试题36：二叉搜索树与双向链表.输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表 不能创建新的任何节点：意味着我们在遍历的时候，就需要对每一个节点进行转换（节点需要动态分配，指针初始化一个地址） 转换为的转换为的链表是排序：选择中序遍历]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Abstract Data Type]]></title>
    <url>%2F2019%2F05%2F15%2Ftable-stack-queue%2F</url>
    <content type="text"><![CDATA[Abstract Data Type 数据结构与算法教程，数据结构C语言版教程 理解数据结构的三种类型：看代码实现的细微差别 函数设计，我就只给一个接口，外部看不到设计，保留头指针与否，取决于自己设计的习惯 内存分配 所有的ADT都需要确定，如何获取内存存储值； 静态数组：结构长度固定 动态分配的数组结构：重新构建一个数组，复制原先数组到新数组，并删除原先数组 动态分配：考虑创建，以及销毁 为了避免内存泄露 动态分配的链式结构：每个元素单独分配内存空间 Link_list 数组存储数据 插入和删除，时间成本很昂贵 简单数组一般不用来实现表这种结构 链表节点的插入和删除 Stack 堆栈的接口： push : 新值压入堆栈顶部； pop：只把顶部元素移出堆栈，不返回值 top：返回顶部元素，不进行元素的移除 实现堆栈： push：存储于数组中连续的位置，因此需要考虑empty and full 堆栈的实现方式： 动态分配数组实现 动态分配链表实现 静态数组实现– 我修改了头文件，先不使用 栈的应用应用一：包含min函数的栈:题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数1. 有几个难点： + 和链表一样，一开始没有code栈的操作，导致这道题目没有思路； + 栈和队列的数据结构：将会用于树的操作 应用二：面试题31：栈的压入、弹出序列. 题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序Queuequeue – array 静态数组实现循环队列麻烦之处： ​ a. 判断元素存储在队列循环的位置：(rear = (rear+1) % QUEUE_SIZE) ​ b. 判断何时为空，何时为满 ​ 数组中有一个位置空着不用，front出队后比rear大1； ​ (rear+1) % QUEUE_SIZE == front 队列为空 ​ (rear+2) % QUEUE_SIZE == front 队列为满 ​ c. a % b : if(a&lt;b),那么输出的直接是元素a 队列是否为空的方式 定义一个标志位 size，判断是否为空，或者满了 再循环数组中，空出一个位置不用 123456 数组中有一个位置空着不用； (rear+1) % QUEUE_SIZE == front 队列为空 (rear+2) % QUEUE_SIZE == front 队列为满 数组的初始化rear = 0; front = 1; // 空出下标为0的位置 queue 的实现 静态数组实现 , 现在还没有用 动态分配数组实现 动态分配链表实现 queue 的应用–&gt; 用于树的操作Tree 关于树的构建和遍历]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>ADT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket]]></title>
    <url>%2F2019%2F05%2F08%2Fsocket%2F</url>
    <content type="text"><![CDATA[Socket socket：IP地址 + TCP/UDP 端口号 —– 唯一标识网络通讯中的一个进程 socket pair ：建立连接的两个进程各自有一个socket来标识，两个socket连接 socket API ：TCP/IP协议设计的应用层编程接口。 unix 网络编程 介绍TCP协议的函数接口 最后简要介绍UDP协议和UNIX Domain Socket （套接字）的函数接口。 Introduction网络字节序 多字节数据 多字节数据：看成一个整体，也就是数据流； 数据流：在内存、磁盘文件存储的时候都是存在顺序的，顺序分为大端和小端； 网络数据流的地址：先发出的数据是低地址，后发出的数据是高地址。 TCP/IP协议网络数据流 应采用大端字节序，即低地址 高字节。 低地址：数据在内存中的存储地址是由低到高的 高字节：字节在进制数表示时的位置 主机和网络字节序 考虑发送和接收数据方：大端、小端字节序—–需要统一 库函数 网络字节序和主机字节序的转换。 12$ uint32_t htonl(uint32_t hostlong);// h表示host,n表示network,to表示转换方向；l表示32位长整数,s表示16位短整数。 如果主机是小端字节序,这些函数将参数做相应的大小端转换然后返回, 如果主机是大端字节序,这些函数不做转换,将参数原封不动地返回。 socket地址的数据类型 socket API 是一层抽象的网络编程接口，适用于各种底层网络协议：IPv4、IPv6，UNIX Domain Socket。 然而,各种网络协议的地址格式并不相同 socket 地址结构体 1234$ #include &lt;sys/socket.h &gt; //介绍程序中用到的socket API函数$ #include &lt;netinet/in.h&gt; // IPv4和IPv6的地址格式定义$ sockaddr_in 结构体 // 表示IPV4的地址，,包括16位端口号和32位IP地址$ sockaddr_in6 结构体 // 表示IPv6地址包括16位端口号、128位IP地址 各种socket地址结构体的开头都是相同的； 前16位表示整个结构体的长度； 后16位表示地址类型 IPv4 – AF_INET、IPv6 – AF_INET6；Unix Domain Socket – AF_UNIX socket API可以接受各种类型的sockaddr结构体指针做参数 参数都用struct sockaddr *类型强制转换一下 bind、accept、connect等函数 IPV4 的socket网络编程 sockaddr_in中的成员struct in_addr sin_addr表示32位的IP地址。 我们通常用点分十进制的字符串表示IP地址 字符串(10进制) 转 in_addr (十六进制)的函数: 其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr,还可以转换IPv6的in6_addr 函数的接口是void *addrptr。 基于TCP协议的网络程序 client to server 函数操作过程中：没有数据到达时，进行阻塞等待 关闭连接 调用close()：任何一方调用close()后,连接的两个传输方向都关闭,不能再发送数据了。 调用shutdown()：如果一方调用shutdown()则连接处于半关闭状态,仍可接收对方发来的数据。 学习socket API时要注意应用程序和TCP协议层是如何交互的: 调用connect()会发出SYN段 如read()返回0就表明收到了FIN段 TCP 网络程序 socket / server.c server 完成server的全过程 socket()函数 socket()打开一个网络通讯端口，成功返回的文件描述符 网络通讯端口：就像是一个文件一样，有了文件描述符，便能对一个文件进行读写操作 bind()函数 服务器程序：需要调用bind绑定一个固定的网络地址和端口号，为了方便客户端的连接 内核分配的话：每次都会发生改变 12int bind(int sockfd, const struct sockaddr *myaddr, socklen_taddrlen); bind()的作用是将参数sockfd和myaddr绑定在一起,使sockfd这个用于网络通讯的文件描述符监听myaddr所描述的地址和端口号。 struct sockaddr *是一个通用指针类型，myaddr参数实际上可以接受多种协议的sockaddr结构体 myaddr 初始化之后，才能用bind()函数 网络地址 IPV4 或者是IPV6 INADDR_ANY 参数目前还不知道哪里找到的； 表示本地的任意IP地址, 两个文件描述符 accept()的参数listenfd是先前的监听文件描述符； 而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯 之后与客户端之间就通过这个connfd通讯, 再次回到循环开头listenfd仍然用作accept的参数 client connect() connect和bind的参数形式一致 区别在于bind的参数是自己的地址 而connect的参数是对方的地址。 运行 123$ ./server // 启动server$ netstat -apn|grep 8000 // 得到此时开启的tcp的源地址和端口号$ ./client advvv // 启动客户端 socket文件描述符 一个socket文件描述符对应一个socket pair ,也就是源地址:源端口号和目的地址:目的端口号,也对应一个TCP连接。 错误处理和读写控制 socket / wrap.c 针对文件读写的一个错误信息跳转 信号重连接 慢系统调用accept、read和write被信号中断时应该重试。 connect虽然也会阻塞,但是被信号中断时不能立刻重试。 如果应用层协议的各字段长度固定,用readn来读是非常方便的。 字段长度固定的协议往往不够灵活,难以适应新的变化。 TFTP协议的各字段是可变长的 常见的应用层协议都是带有可变长字段的 可变长字段的协议用readn来读就很不方便了,为此我们实现一个类似于fgets的readline函数 server and client 多用户处理 client改为交互式输入 不断从终端接受用户输入并和server交互 修改 [socket_api/TCP/client.c] server 修改，可以多次处理同一客户端的请求。 fork() 并发 处理多个client的请求 父进程专门负责监听端口，每次accept一个新的客户端连接就fork出一个子进程专门服务这个客户端。 setsockopt 在同一个终端，关闭server后，还能重新开启server 表示创建端口号相同，但IP地址不同的多个socket描述符。 select * 1)select是网络程序中很常用的一个系统调用,它可以同时监听多个阻塞的文件描述符 * 2)不需要fork和多进程就可以实现并发服务的server。 * 3) 未使用 基于UDP的网络编程 udp 中的采用的是数据报文，并非流 SOCK_STREAM –&gt; SOCK_DGRAM UDP 不用考虑多个client的链接 不用考虑同意终端关闭server后不能重新开启的现象 UNIX Domain Socket IPC 网络socket 用于同一台主机的进程间通讯(通过loopback地Domain Soc址127.0.0.1) UNIX Domain Socket socket API原本是为网络通讯设计的，但后来在socket的框架上发展出一种IPC机制 不需要经过网络协议栈,不需要打包拆包、计算校验和、维护序号和应答等 只是将应用层数据从一个进程拷贝到另一个进程 IPC机制：本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。 UNIX Domain Socket 提供面向流和面向数据包两种API接口，类似于TCP和UDP 但是面向消息的UNIX Domain Socket也是可靠的,消息既不会丢失也不会顺序错乱。 区别 | | UNIX Domain Socket | 网络socket || —————- | —————————————————- | —————- || socket文件描述符 | fd = sock() | fd = sock() || address family | AF_UNIX | AF_INET || type | 择SOCK_DGRAM或SOCK_STREAM | tcp/udp 区分 || 地址格式 | sockaddr_un | sockaddr_in || socket地址 | socket类型的文件在文件系统中的路径 | 是IP地址加端口号 || connect() | 客户端要显式调用bind函数，而不依赖系统自动分配的地址 | | 客户端bind一个自己指定的socket文件名的好处是： 该文件名可以包含客户端的pid以便服务器区分不同的客户端。 Web server web服务器对浏览器的处理方式 浏览器 —-&gt; 发送http协议请求 —&gt; web server input ：IP + Port HTTP 的协议头 1$ GET / HTTP/1.1 // 第一行是GET请求和协议版本 web server —&gt; 将对应目录下的索引页(默认的根目录/(在是index.html) —- &gt; 发送给浏览器 格式应答 123456789HTTP/1.1 200 OK // 是协议版本和应答码；200--标示成功，ok可以随意写Content-Type: text/html //为MIME类型--text/html；纯文本是text/plain；图 片则是image/jpg&lt;html&gt;&lt;head&gt;&lt;title&gt;Test Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Test OK&lt;/p&gt; &lt;img src='mypic.jpg'&gt;&lt;/body&gt;&lt;/html&gt; 而HTTP协议规定服务器主动关闭连接]]></content>
      <categories>
        <category>LinuxC</category>
        <category>socket</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tcp/IP]]></title>
    <url>%2F2019%2F05%2F06%2FTcpIp%2F</url>
    <content type="text"><![CDATA[TCP / IP 协议网络基础知识 计算机网络的作用? 提供一种网络形态, 将单用户工作模式,转化为多用户信息共享 互联模式; 分时系统 通过多个终端与同一计算机相连, 允许多个用户同时操作一台计算机; 通过分时系统, 虚拟的实现了”一人一机”; 特性: 独占性 实现: 多任务调度 协议 不同计算机之间通信的基本要求; 举例: 人与人交流的语言 – 中文/ 英语 电路交换和分组交换 网络通信的方式 电路交换：通信双方独占一条线路进行数据传输，其与用户只能等待； 分组交换：通信双方将数组包分组，在一条通信线路上实现多组用户通信； 接收端的数量进行分析 单播； 广播: 同一个链路中相互链接主机间通信 多播：特定组内进行的通信; (一年级一班) 任播：特定组内任意一台主机；(一年级一班小李) 传输速率和吞吐量 传输速率：单位时间内传输的数据量，单位是bps；也称之为带宽； 吞吐量：主机间通信过程中实际的传输速率； 衡量CPU处理能力和网络拥塞程度 OSI 7层参考模型（Open System Interconnection Reference Model） 计算机通信的前提：能上网 网卡：计算机连网的设备 OSI 参考模型的作用？ OSI协议的作用：让异构计算机之间能互相通信； OSI 分层的作用：抽象出每一层的接口，让网络间通信更简单； 同一层之间的通信: 遵循相同的协议; 上下层之间: 调用接口 分层 功能 硬件设备 应用层 针对特定应用的协议邮件协议–&gt;电子邮件 表示层 数据格式转换：转化为网络标准格式 网关：转换协议的设备；对数据进行转换；代理服务器 会话层 通信管理：决定何时建立断开同行连接决定采用何种连接方式 传输层 管理两个通信节点之间的数据传输；实际建立逻辑上的通道 4-7层交换机：分析收发数据，进行特定处理负载均衡器 网络层 完整数据包发送，进行数据链路转换(完整行程列表) 网桥/３层交换机：分组数据转换路由器 数据链路层 负责一个数据段帧的发送 网桥/２层交换机：连接两个网络以太网使用：交换集线器 物理层 将0/1数据转换为不同介质间的信号量进行传送 中继器：信号整形放大；延长网络 TCP/IP 基础知识 TCP/IP协议 ARPANET 指定的协议 网际协议族: 通信必须用到的协议群统称; RFC概念 Request for Comment TCP/IP 由IETF讨论制定, 需要标准化的协议, 被列入RFC文档并在互联网上公布; 标准化流程 互联网草案阶段 - - RFC提议标准 – 草案标准 – 整整的标准 互联网 The Internet / 网际网 Internet ISP Internet server provider : 不同的区域网ISP, 相互连接称互联网 NOC network operation connect : 同一个ISP 中不同网络之间的连接 IX Internet Exchange: 不同的ISP区域网之间的链接 TCP/IP 协议分层模型 OSI 模型和TCP/IP模型区别 OSI模型: 注重通信协议具备的功能是什么; TCP/IP : 注重计算机上实现协议应该开发哪些程序 { % asset_img tcpip.png %} 模式和使用的协议 Client –&gt; Server : 使用TCP/IP协议 Wed –&gt; Server: 使用HTTP协议 属性 分层 功能 / 协议 数据单位 应用程序 应用层(会话层以上) HTTP: 万维网(WWW) web; 数据格式 – HTML 消息 SMTP: Email使用(simple mail transfer protocol) FTP: 文件传输(file…); 建立两个TCP连接– 控制和数据 TELENT SSH 远程连接 (secure shell)(更安全) SNMP 网络管理: (simple network management) 操作系统 传输层 根据端口号: 让应用程序实现通信; 段 TCP : 面向连接的传输协议; 有重传机制 TCP数据流 UDP: 面向无连接; 主要用于多播, 广播和视频 互联网层(网络层) 通过路由器: 实现数据包的分组转发, 实现IP协议 数据报 IP协议:根据IP地址进行转发分包数据, 不具备重发机制 (IP UDP) ICMP: IP数据包出故障时, 发送异常通知给发送端 ARP: 从IP地址中解析MAC地址 设备驱动程序与网络接口 网络接口层(数据链路层) 网卡层 根据MAC地址, 通过以太网中的数据链路进行通信驱动程序: 在操作系统和硬件起桥梁作用 帧 WLAN : 无线局域网 PPP: 点对点协议 物理层 负责数据传输 数据封装 每一层都会加一个首部: 数据链路层: 除了加首部, 在尾部加包尾, 循环冗余检测 数据包处理 数据链路层和网络层: 根据协议进行转发; TCP处理: 先检查校验和 – 序列号 – 端口号; 确认数据无误: 发送确认回执 TCP/IP抽象 抽象为一个送快递模型. 云南到北京 网络层 从云南到北京 : 要经过哪些其他省份; 相当于一个行程表 数据链路层: 根据不同的省份划分的区间; 每个区间采用货车大小不同: 最大传输单元MTU(maximum transmission union) 数据链路层 提供直连两个设备之间的通信功能; 网络拓扑结构 网络连接和构成的形态 总线型 ，环形，星型，混合型； MAC地址 48bit 第一位 和 第二位 介质型网络传输 共享介质中传递方式: 多个用户采用一条传输线 争用方式: CSMA/CD 载波监听多路访问 + 碰撞检测 令牌传递方式: 每一个用户能占有一段时间 非共享介质: 通过2层交换机: 与交换机直连, 构建每个用户的独享; 缺点: 交换机故障,所有用户不能通信 以太网 以太网: 最具兼容性的一种数据链路; 介质模式: 非共享介质, 冲突检测不在必要, 让网路变得更加高速; 传输速度: 1K = 1000 ,并非二进制的1024; 协议: IEEE 802.11 以太网帧格式 类型(2byte): 代表上一层协议 FCS(frame check sequence): 数据帧在传输过程中,收到电子干扰,导致0/1错码, 需要进行检测; 无线通信 使用介质: 电磁波 几种类型: | 分类 | 技术 || ————————— | ——– || 短距离无线 | RFID || 无线PAN Person Area Network | Bletooth || 无线LAN Local Area Network | Wifi || 无线WAN Wide Area Network | 3G, 4G | 使用协议 IEEE802.11 : 定义了无线LAN协议与数据了链路层的一部分; 介质上采用CSMA/CA PPP 协议 与以太网的区别: 纯数据链路层, 与物理层没有任何关系; 仅有PPP协议是无法通信, 需要物理层的支持 PPP协议的数据发送: 建立PPP级的连接, 建立以后进行身份认证, 加密 和压缩 LCP: link control protocol, 负责建立和断开连接; NCP: network control protocol. 负责IP地址的设置以及TCP/IP首部压缩; PAP: password authentication protocol, 用户身份的认证协议, 两次握手进行验证, 密码明文传输 CHAP: challenge handshake authentication protocol, 一次性密码,建立连接后定期换密码 数据包大小: 0-1500 byte FDDI fiber distributed data interface FDDI: 分布式光纤数据接口; 采用令牌环进行通信 ATM ATM: asynchronous(异步) transfer mode : 以信元为单位进行数据连接; 特点: 面向连接的数据链路; 允许同时与多个对端建立通信连接 IP协议 提供没有直连的两个网络通信 提尽力服务, 没有数据包丢失检测 网络层和数据链路层关系: 数据链路层: 相当于每一站的车票; 网络层: 从起点到终点的行程安排; IP三个模块 IP寻址: IP地址, 唯一性和层次性 路由控制: 将分组数据发送到最终目标地址的功能; IP的分包和组包 IP 地址 作用: 标识主机和路由器, 使用不同的主机之间通信; 早期 IP地址由两部分组成 网络地址: 在数据链路的每个段配置不同的值; 互联的每个段地址不能重复; 路由器: 包含不同段的网络地址, 数据在不同的网段之间传播 主机地址: 标识不同的主机; 引入子网掩码的IP地址 IP地址本身 + 表示网络的子网掩码 CIDR: 将多个C类地址聚合成一个大的地址, 减少一位网络地址,增加一位主机地址; 路由聚合, 减小路由控制表 IP地址分类: 4类地址 注意他们的区间 D类地址: 没有主机标识, 全部用于多播(某些组内) 主机地址全为1: 用作同一个链路之间的广播地址; IP多播实现: D类地址 + IGMP(组内控制协议) 224.0.0.0 - 223.255.255.255 多播地址可用范围 全局地址和私有地址 私有地址分为三类: 其主机数 /8 /10 /12; 全局地址: 由ISP进行管理 路由控制 路由协议 – 生成路由控制表 – 控制数据包的下一跳 – 实现IP通信 Hop 一跳 IP数据包在一个链路区间的传递; 到达的应该是下一个路由器; 路由控制表 从源主机到目的主机的路由控制表 也就是下一个路由到哪里; | 路由 | 地址 | 功能 || ——– | —————————— | ————————————— || 默认路由 | 0.0.0.0/0 /0 不是表示的主机IP | 路由表中任一地址都能匹配 || 主机路由 | IP地址/32 | 整个IP地址都参与路由,不通过网络地址路由 || 环回路由 | 127.0.0.1 localhost | 主机内部路由 | IP 数据报分割与重组 IP数据报为什么要进行分包? 不同的数据链路有不同的传输单元MTU; 以太网:1500; byte FDDI : 4352; byte ATM: 9180 byte IP数据包分割与重组 IP/UDP 数据分割: 路由器完成 IP/UDP 数据片重组: 目标主机 TCP的数据分割和重组: 由TCP层自己完成; IPV4 首部 地址格式含义 | 名称 ( 32bit一组) | 长度 bit | 值 || ——————————— | ———————- | ———————————————————— || 版本号 | 0-3(4bit) | 4 = 0100 || 首部长度 : 首部字节数 54 =20 | 4-7(4bit) | 5 = 0101 || 区分服务: 网络状况 | 8-13 (DSCP) 14-15(ECN) | DSCP: 表示优先度;ECN: 表示网络拥塞 || 总长度: IP数据包的总长度 | 16-31 (16bit) | 2^16 = 65535字节; 包含首部长度 || 32bit一组 | | || 标识:用于分片重建, 记录分片的顺序 | 0-15(16bit) | 2^16 大小, 分片就递增加1 || 标志: 是否可以分片/ 最后一个分片 | 16-18 (3bit) | 16bit: 0; 17bit: 0–分片; 1–不能分片18bit: 0–最后一个包; 1–中间的包 || 片偏移: 表示IP数据包中的位置 | 19-31(13bit) | 2^13 = 81928 = 65536; 单位是8byte || 32bit一组 | | || 生存周期: 经过路由器个数 | 0-7 (8bit) | 2^8:= 255 每经过一个路由器, TTL减1 || 协议: 表示上层协议TCP/UDP | 8-15 (16bit) | TCP = 6 ; UDP = 17 || 首部校验和 | 16-31 (16bit) | 校验数据包的首部,不校验数据 || 32bit一组 | | || 源地址 | 0-31 | || 目标地址 | 0-31 | | IPV6 IPV6地址大小 128bits 8个 16bit 的字节进行表示; :: 双冒号表示省略0, 只能用一次 包首部 首部40 bytes 路由器不参与分片处理, 直接以最小MTU 1280字节进行发出 地址结构 ipv6 首部 地址格式 名称(32bit一组) 长度 bit 值 版本: 6 0-3 0110 通信量类 = 区分服务 4-11(8bit) 占时没用 流标号: + 源/目的地址 == 判断是同一个数据流 12-31(20bit) 进行服务质量时, 设置为随机数 32bit一组 有效负载长度: 能包含的数据包长度 不包含首部长度 0-15 2^15=65535 bytes: 不包含首部 下一个首部 = 协议 16-23(8bit) 表示上一层协议 调数限制 = TTL 24-31(8bit) 可经过的路由器个数, 每进过一个减一 32bit一组 源地址 4个32bit 目的地址 4个32bit 32bit一组 IPV6的首部是可以扩展的]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread]]></title>
    <url>%2F2019%2F05%2F05%2FThread%2F</url>
    <content type="text"><![CDATA[ThreadIntroduction Why? 有些情况需要在一个进程中同时执行多个控制流程； 比如实现一个图形界面的下载软件：下载和交互多个线程 main 函数和信号处理函数是同一个进程地址空间中的多个控制流程 信号处理函数的控制流程只是在信号递达时产生 在处理完信号之后就结束 多线程的控制流程 可以长期并存，操作系统会在各线程之间调度和切换,就像在多个进程之间调度和切换一样。 同一进程的多个线程共享同一地址空间 Text Segment、Data Segment都是共享 文件描述符表；每种信号的处理方式；当前工作目录；用户id和组id 线程独立的资源 线程id …. Complie 在Linux上线程函数位于libpthread 共享库中,因此在编译时要加上-lpthread 选项 1$ gcc main.c -lpthread 线程库函数是由POSIX标准定义的,称为POSIX thread或者pthread。 1$ man pthread_ Thread Control 变量类型 pthread_t thread_create thread_create() 线程 –&gt; pthread_create( )，当前线程从pthread_create()返回继续往下执行; 新线程执行代码： 由函数指针start_routine决定 start_routine 函数接收一个参数,是通过pthread_create的arg参数传递给它 类型为void * start_routine 返回时,这个线程就退出 其它线程可以调用pthread_join 得到start_routine的返回值 Process vs Thread Process id 的类型是pid_t ，id在整个系统中是唯一的； 调用getpid(2)可以获得当前进程的id , 是一个正整数值。 Thread 线程id的类型是thread_t，它只在当前进程中保证是唯一的 id 值类型不唯一，不能简单地当成整数用printf打印,调用pthread_self(3) 可以获得当前线程的id pid and tid 多个线程调用getpid(2) 可以得到相同的进程号 而调用pthread_self(3) 得到的线程号各不相同。 error fork : 错误码保存在errno 中，直接用perror(3) 打印错误信息, thread：先用strerror(3)把错误码转换成错误信息再打印。 中止 如果任意一个线程调用了exit 或_exit ,则整个进程的所有线程都终止 make 编译 12$ gcc -g -c thread.c -o thread.o$ gcc thread.o -plthread -o thread // -plthread 位置要在后面，才能正常link thread_exit 三种终止线程的方式 pthread_join() 在Linux的pthread库中常数PTHREAD_CANCELED 的值是-1。可以在头文件pthread.h 中找到它的定义。 pthread_detach 线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止 线程置为detach状态：这样的线程一旦终止就立刻回收它占用的所有资源,而不保留终止状态。 一个线程调用了pthread_detach 就不能再调用pthread_join 了。 thread time synchronizemetux 变量类型：pthread_mutex_t 多个线程同时访问共享数据时可能会冲突,这跟前面讲信号时所说的可重入性是同样的问题。 Mutual Excludive Lock 互斥锁 获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据 这样“读-修改-写”三步操作组成一个原子操作，中间不会被打断 Metux init 1$ pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //:成功返回0,失败返回错误号 metux lock and unlock 123int pthread_mutex_lock(pthread_mutex_t *mutex); // lockint pthread_mutex_trylock(pthread_mutex_t *mutex); // don't hang upint pthread_mutex_unlock(pthread_mutex_t *mutex); //unlock pthread _mutex_trylock 如果一个线程既想获得锁,又不想挂起等待 如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。 lock and unlock 互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。 unlock操作中唤醒等待线程 对Mutex变量的读取、判断和修改不是原子操作 为了实现互斥锁操作,大多数体系结构都提供了swap或exchange指令 避免死锁 A 挂起等待B的锁；B也挂起等待A的锁；造成死锁状态 尽量使用pthread_mutex_trylock调用代替pthread_mutex_lock调用,以免死锁。 Condition Variable 条件时间同步 通过条件变量(Condition Variable)来阻塞等待一个条件,或者唤醒等待这个条件的线程。 用pthread_cond_t 类型的变量表示 cond_init 1$ pthread_cond_t cond = PTHREAD_COND_INITIALIZER; //成功返回0,失败返回错误号。 cond_funcation 1234$ pthread_cond_timedwait() //可以设置超时时间$ pthread_cond_wait()$ pthread_cond_signal() // 唤醒在某个Condition Variable上等待的另一个线程$ pthread_cond_broadcast() //唤醒在这个Condition Variable上等待的所有线程。 一个Condition Variable总是和一个Mutex搭配使用的。 阻塞等待 code 节生产者-消费者的例子是基于链表的,其空间可以动态分配 Semaphore man sem_overview semaphore变量的类型为sem_t, Mutex and Semaphore Mutex ：变量是非0即1的，可看作一种资源的可用数量 0/1 Semaphore：可用资源的数量，和Mutex不同的是这个数量可以大于1。 semaphore funcation 12345$ int sem_init() // sem_init()初始化一个semaphore变量$ int sem_wait() // 调用sem_wait()可以获得资源,使 semaphore--$ int sem_trywait() // semaphore = 0；如果不希望挂起等待$ int sem_post() // 释放资源,semaphore++,同时唤醒挂起等待的线程。$ int sem_destory() // 销毁变量 code 现在基于固定大小的环形队列重写这个程序。 Other 线程冲突概念： 共享数据只读：那么各线程读到的数据应该总是一致的,不会出现访问冲突。 一个线程可以改写数据：就必须考虑线程间同步的问题。 读者写者锁(Reader-Writer Lock) Reader之间并不互斥,可以同时读共享数据 而Writer是独占的(exclusive) ,在Writer修改数据时其它Reader或Writer不能访问数据, 可见Reader-WriterLock比Mutex具有更好的并发性。 并发性 用挂起等待的方式解决访问冲突不见得是最好的办法,因为这样毕竟会影响系统的并发性 例如Linux内核的Seqlock、RCU(read-copy-update)等机制。 死锁问题 微秒级延时：加快仿真速度。 1$ usleep(3)]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RidingBicycle]]></title>
    <url>%2F2019%2F04%2F29%2FRidingBicycle%2F</url>
    <content type="text"><![CDATA[RidingBicycle骑行木兰草原骑行路程安排 日期 骑行目的 骑行公里 天气 住宿 5.1 hust - 黄陂 - S108 - 枫树驿站 97.1 多云 5.2 游玩 木兰天池 5.3 枫树驿站 - 锦里沟 15.12 5.4 锦里沟 - hust 110 花费 项目 花费 枫树客栈 218 衣物携带 物品 数量 用途 一套骑行的衣服裤子 1 只用来骑行 一套休闲的衣服– 木兰草原要走很多路 1 y用来木兰草原游玩 两双袜子和内衣裤 2 生活用品 物品 数量 用途 牙刷 1 宾馆不好用 急救用品 物品 数量 用途 创口贴 5 小伤口 云南白药 1 扭伤 修车工具 物品 数量 用途 内胎 2 换和补 链条油 1 润滑 修车工具包 1 急救]]></content>
      <categories>
        <category>RidingBicycle</category>
      </categories>
      <tags>
        <tag>RidingBicycle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DaemonControl]]></title>
    <url>%2F2019%2F04%2F28%2FDaemonControl%2F</url>
    <content type="text"><![CDATA[Daemon Control 作业控制：将进程放在前台或者后台执行 守护进程：即使关闭了terminal，进程也能继续执行 TerminalIntroduction 控制终端(Controlling Terminal) 用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端 控制终端是保存在PCB中的信息 每个进程的标准输入、标准输出和标准错误输出都指向控制终端 在控制终端输入一些特殊的控制键可以给前台进程发信号 例如 Ctrl-C表示SIGINT Ctrl-\ 表示SIGQUIT ttyname 函数 文件描述符查出对应的文件名 该文件描述符必须指向一个终端设备而不能是任意文件 1$ printf("fd 0 : %s\n", ttyname(0))； Terminal Login 登录用户模式，或者root模式 一台PC通常只有一套键盘和显示器,也就是只有一套终端设备/dev/tty0 虚拟终端(Virtual Terminal)：设备文件分别是/dev/tty1~ /dev/tty6 1$ Ctrl-Alt-F1 ~ Ctrl-Alt-F6 // 切换到6个字符终端 内核中处理终端设备的模块 包括硬件驱动程序 硬件驱动程序负责读写实际的硬件设备 线路规程(LineDiscipline) 线路规程像一个过滤器 某些特殊字符并不是让它直接通过，而是做特殊处理 终端设备有输入和输出队列缓冲区 命令行键入字符时,该字符不仅可以被程序读取,我们也可以同时在屏幕上看到该字符的回显。 Terminal Login 系统启动时，init进程根据配置文件确定需要打开哪些终端。 把文件描述符0、1、2都指向控制终端，然后提示用户输入帐号。 login 程序提示用户输入密码(输入密码期间关闭终端的回显),然后验证帐号密码的正确性。 Network Login 虚拟终端或串口终端的数目是有限的。 伪终端(Pseudo TTY) 实现：网络终端或图形终端窗口的数目却是不受限制的 一套伪终端由一个主设备(PTY Master)和一个从设备(PTY Slave)组成。 主设备在概念上相当于键盘和显示器,只不过它不是真正的硬件而是一个内核模块,操作它的也不是用户而是另外一个进程 从设备和上面介绍的/dev/tty1 这样的终端设备模块类似,只不过它的底层驱动程序不是访问硬件而是访问主设备。 Network Login 用户通过telnet客户端连接服务器；服务器监听连接请求是一个telnetd进程。 telnetd子进程打开一个伪终端设备,然后再经过fork 一分为二:父进程操作伪终端主设备,子进程将伪终端从设备作为它的控制终端 当用户输入命令时,telnet客户端将用户输入的字符通过网络发给telnetd 服务器,由telnetd 服务器代表用户将这些字符输入伪终端。 交互 我们每按一个键telnet客户端都会立刻把该字符发送给服务器 这个字符经过伪终端主设备和从设备之后被Shell进程读取，同时回显到伪终端从设备 回显的字符再经过伪终端主设备、telnetd服务器和网络发回给telnet 客户端,显示给用户看。 设备 ptyXX 是主设备,相对应的ttyXX 是从设备 Jobs ControlSession 和进程组 Shell分前后台来控制的不是进程而是作业(Job)或者进程组(Process Group)。 Jobs Control Shell可以同时运行一个前台作业和任意多个后台作业 12$ proc1 | proc2 &amp; //proc1 和proc2 属于同一个后台进程组$ proc3 | proc4 | proc5 //前台进程组 从Session和进程组的角度重新来看登录和执行命令的过程 Session Leader getty 或telnetd进程在打开终端设备之前调用setsid函数创建一个新的Session 该进程的id也是进程组的id。 命令 12$ ps -o pid,ppid,pgrp,session,tpgid,comm | cat$ ps -o pid,ppid,pgrp,session,tpgid,comm | cat &amp; 这个作业由ps和cat 两个进程组成，分别在前台和后台运行 与作业控制有关的信号 后台进程 不能读终端输入的, 因此终端有输入时，内核发SIGTTIN信号给进程； 该信号的默认处理动作是使进程停止。 jobs and fg 12345$ jobs // jobs 命令可以查看当前有哪些作业$ fg %1 // fg命令可以将某个作业提至前台运行，或者将停下的进程开启 // 参数%1表示将第1个作业提至前台运行。$ bg %1 // bg 命令可以让某个停止的作业在后台继续运行$ ps // 查看当前的控制信号 cat 1$ cat &amp; // 后台运行进程 Daemon Process 守护进程(Daemon) 用户关闭终端窗口或注销也不会影响守护进程的运行。 $ ps axj 查看系统中的进程 参数a 表示不仅列当前用户的进程,也列出所有其他用户的进程 参数x 表示不仅列有控制终端的进程,也列出所有无控制终端的进程 参数j表示列出与作业控制相关的信息。 进程信息 守护进程：没有控制终端的进程，TPGID = -1 守护进程：通常采用以d结尾的名字,表示Daemon。 内核线程Kernel：用[]括起来的名字，采用以k 开头的名字 创建守护进程 最关键的一步是调用setsid函数创建一个新的Session,并成为Session Leader。 调用这个函数之前,当前进程不允许是进程组的Leader,否则该函数返回-1。 要先fork 再调用setsid，保证当前进程不是Leader。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>Daemon</tag>
        <tag>Control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Signal]]></title>
    <url>%2F2019%2F04%2F26%2FLinuxCSignal%2F</url>
    <content type="text"><![CDATA[LinuxC Signal 进程在执行代码时，收到内核的Signal，使得进程终止 代码遇到一个问题：头文件包含函数，但是函数调用不成功 Signal 查询 1$ man 7 signal //详细说明 Ctrl-C产生的信号只能发给前台进程。 “wait和waitpid函数”中我们看到一个命令后面加个&amp; 可以放到后台运行 这样Shell不必等待进程结束就可以接受新的命令 信号： 使用该进程，执行用户空间代码时，执行到任何地方都有可能收到SIGINT信号终止进程。 信号相对于进程的控制流程来说是异步(Asynchronous)的。 ｛% asset_img signal_start.png %｝ 不想按默认动作处理信号 用户程序可以调用sigaction(2) 函数告诉内核如何处理某种信号 SIGINT的默认处理动作是终止进程 SIGQUIT的默认处理动作是终止进程并且CoreDump 产生信号通过终端按键产生信号 CoreDump (核心转存) 当一个进程要异常终止时,可以选择把进程的用户空间内存数据全部保存到磁盘上； 文件名通常是core，这叫做Core Dump 进程异常终止 有Bug,比如非法内存访问导致段错误； 事后可以用调试器检查core 文件以查清错误原因，做Post-mortem Debug。 Core 文件 一个进程允许产生多大的core 文件取决于进程的Resource Limit 默认是不允许产生core 文件的,因为core 文件中可能包含用户密码等敏感信息,不安全。 1$ ulimit -c 1024 // ulimit命令改变这个限制,允许产生core文件，最大值是1024 按键产生signal 123$ ./a.out // press ctrl+c $ ./a.out // press ctrl+\$ ls -l core //core dump 调用系统函数向进程发信号 后台运行程序 123$ ./a.out &amp; //首先在后台执行这个程序;数字代表进程的id$ kill -SIGSEGV 7940$ 再次回车 // ,Shell不希望Segmentation fault 信息和用户的输入交错在一起 以往遇到的段错误都是由非法内存访问产生的,而这个程序本身没错,给它发SIGSEGV 也能产生段错误。 也可以调用函数 12int kill(pid_t pid, int signo);int raise(int signo); abort函数 abort 函数使当前进程接收到SIGABRT 信号而异常终止。 就像exit 函数一样,abort 函数总是会成功的,所以没有返回值。 由软件条件产生信号 SIGPIPE是一种由软件条件产生的信号 alarm 和SIGALRM 信号 调用alarm 函数可以设定一个闹钟,也就是告诉内核在seconds秒之后给当前进程发SIGALRM 信号 该信号的默认处理动作是终止当前进程。 阻塞信号信号在内核中的表示 信号递达Delivery 而实际执行信号的处理动作 信号未决 Pending 信号从产生到递达之间的状态 阻塞Block：进程可以选择阻塞某个信号 被阻塞的信号产生时将保持在未决状态,直到进程解除对此信号的阻塞,才执行递达的动作。 忽略某个信号 只要信号被阻塞就不会递达,而忽略是在递达之后可选的一种处理动作。 每个信号包含三个要素 都有两个标志位：分别表示阻塞block和未决pending 还有一个函数指针sighandler表示处理动作。 信号产生时，内核在进程控制块中设置该信号的未决标志,直到信号递达才清除该标志。 sigset_t 称为信号集 sigset_t来存储：未决和阻塞标志 阻塞信号集中：“有效”和“无效”的含义是该信号是否被阻塞, 未决信号集中：“有效”和“无效”的含义是该信号是否处于未决状态。 阻塞信号集 也叫做当前进程的信号屏蔽字(Signal Mask) 信号集操作函数 sigset_t 类型对于每种信号用一个bit表示“有效”或“无效”状态 sigemptyset 初始化set 所指向的信号集,使其中所有信号的对应bit清零 在使用sigset_t 类型的变量之前,一定要调用sigemptyset或sigfillset 做初始化,使信号集处于确定的状态。 sigprocmask 调用函数sigprocmask可以读取或更改进程的信号屏蔽字。 如果调用sigprocmask解除了对当前若干个未决信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。 sigpending sigpending 读取当前进程的未决信号集,通过set参数传出。 捕捉信号内核捕捉信号 捕捉信号 如果信号的处理动作是用户自定义函数,在信号递达时就调用这个函数 用户注册SIGQUIT信号的处理函数：sighandler 内核捕捉函数 第一次进入内核：发生中断或异常切换到内核态。 第二次进入内核：中断处理完后，检查到有信号SIGQUIT递达，执行sighandler 函数；系统调用sigreturn 再次进入内核态。 如果没有新的信号要递达,这次再返回用户态就是恢复main 函数的上下文继续执行了。如果有信号递达，在执行（第二次进入内核） sigaction sigaction 函数可以读取和修改与指定信号相关联的处理动作 sigaction：两个参数指向 struct signaction 结构体 sa_sigaction 是实时信号的处理函数。 pause pause 函数使调用进程挂起直到有信号递达。 如果信号的处理动作是捕捉,则调用了信号处理函数之后pause 返回-1,errno 设置为EINTR ,所以pause 只有出错的返回值 如果信号的处理动作是终止进程,则进程终止,pause 函数没有机会返回; 可重入函数 引入了信号处理函数sighandler：使得一个进程具有多个控制流程。 重入函数： 如果一个函数只访问自己的局部变量或参数,则称为可重入(Reentrant )函数。 函数被不同的控制流程调用 有可能在第一次调用还没返回时就再次进入该函数(两次进内核函数) 不可重入函数： insert函数访问一个全局链表,有可能因为重入而造成错乱,像这样的函数称为不可重入函数, sig_atomic_t类型与volatile限定符 在使用sig_atomic_t类型时，加上volatile限定符 为了避免重入造成的链表错乱现象 线程会讲到如何保证一个代码段以原子操作完成。 在使用sig_atomic_t类型时，加上volatile限定符，也能保证原子操作 编译器无法识别 只能说编译器无法识别程序中存在多个执行流程。 比如sigaction 、pthread_create ,这些不是C语言本身的规范,不归编译器管,程序员应该自己处理这些问题 竞态条件 竞态条件(Race Condition): 由于异步事件在任何时候都有可能发生(这里的异步事件指出现更高优先级的进程) 如果我们写程序时考虑不周密,就可能由于时序问题而导致错误 sigsuspend 函数 要是“解除信号屏蔽”和“挂起等待信号”这两步能合并成一个原子操作的功能。 进程的信号屏蔽字由sigmask参数指定,可以通过指定sigmask来临时解除对某个信号的屏蔽,然后挂起等待 SIGCHLD 信号 为了避免僵尸程序的产生 子进程在终止时会给父进程发SIGCHLD信号 方法 父进程调用sigaction 将SIGCHLD 的处理动作置为SIG_IGN ,这样fork 出来的子进程在终止时会自动清理掉,不会产生僵尸进程,也不会通知父进程。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular_Expression]]></title>
    <url>%2F2019%2F04%2F25%2FRegular-Expression%2F</url>
    <content type="text"><![CDATA[Regular_Expression POSIX规定了正则表达式的C语言库函数,详见regex(3) 。 本章介绍了正则表达式在grep 、sed、awk 中的用法,学习要能够举一反三, 例如验证用户输入的IP地址或email地址格式是否正确。 正则表达式概念 概念 规定一些特殊语法表示字符类、数量限定符和位置关系,然后用这些特殊语法和普通字符一起表示一个模式,这就是正则表达式(Regular Expression)。 “正则表达式”就像“变量”，是一个广泛的概念，而不是某一种工具或编程语言的特性。 grep 用grep 在一个文件中找出包含某些字符串的行 找出符合某个模式(Pattern)的一类字符串 grep 模式包含信息 grep 搜索例子 email 正则表达式 1[a-zA-Z0-9_.-]+@[a-zA-Z0-9_.-]+\.[a-zA-Z0-9_.-]+ IP地址的正则表达式 1[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125; 搜索文本 textfile 中的IP 1$ egrep '[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;' testfile egrep 相当于grep -E,表示采用Extended正则表达式语法。 注意正则表达式参数用单引号括起来了 原封不动地传给grep 命令,而不会被Shell解释掉。 搜索结果 因为grep 找的是包含某一模式的行，这一行包含一个符合模式的字符串234.234.04.567。 grep 找的是包含某一模式的行,而不是完全匹配某一模式的行 grep 是一种查找过滤工具,正则表达式在grep 中用来查找符合模式的字符串。 其实正则表达式还有一个重要的应用是验证用户输入是否合法, email 地址验证 基本语法 以上介绍的是grep正则表达式的Extended规范； 如果用grep 而不是egrep ,并且不加-E参数,则应该遵照Basic规范来写正则表达式。 Basic规范也有这些语法； 只是字符?+{}|()应解释为普通字符 要表示上述特殊含义则需要加\ 转义。 概念 C的变量有各种类型，而Shell脚本变量都是字符串。 各种工具和编程语言所使用的正则表达式规范的语法并不相同,表达能力也各不相同。 egrep 正则表达式 man 7 regex 字符类 通过字符来限定表示的方式 数量限定符 字符表示：出现的次数 再次注意grep 找的是包含某一模式的行,而不是完全匹配某一模式的行 位置限定符 字符表示：匹配字符的位置 精确查找 1$ egrep '^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$' textfile 特殊字符​ Sed 流编辑器(Stream Editor) sed 意为流编辑器(Stream Editor),在Shell脚本和Makefile中作为过滤器使用非常普遍 把前一个程序的输出引入sed的输入，经过一系列编辑命令转换为另一种格式输出 sed命令行的基本格式 12sed option 'script' file1 file2 ... sed option -f scriptfile file1 file2 ... 命令行参数可以一次传入多个文件,sed 会依次处理 option : “-n”,这种用法相当于grep 命令，查找出相同的并打印 ‘script’：sed命令 scriptfile ：将sed命令写成脚本文件，然后用-f参数指定 常用的sed命令 使用p 命令需要注意,sed是把待处理文件的内容连同处理结果一起输出到标准输出的 sed 命令 不会修改原文件：删除命令只表示某些行不打印输出，而不是从原文件中删去。 修改原文件：查找替换命令时,可以把匹配pattern1 的字符串复制到pattern2中 awk sed 以行为单位处理文件,awk 比sed强的地方在于不仅能以行为单位还能以列为单位处理文件。 awk缺省的行分隔符是换行,缺省的列分隔符是连续的空格和Tab]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[system_process]]></title>
    <url>%2F2019%2F04%2F22%2Fsystem-process%2F</url>
    <content type="text"><![CDATA[System Process process：分为子进程和父进程； exec：子进程执行代码时，调用的函数 父进程和子进程的通信：pipe 模式 Process 每个进程：在内核中都有一个进程控制块(PCB Process control block)来维护进程相关的信息 Linux内核的进程控制块是task_struct结构体 结构体包含的信息 fork and exec fork 和exec 是本章要介绍的两个重要的系统调用。 fork : 根据一个现有的进程复制出一个新进程 父进程：parent process 子进程：child process exec : 在Shell下输入命令（终端）可以运行一个程序 Shell进程在读取用户输入的命令之后会调用fork 复制出一个新的Shell进程 然后新的Shell进程调用exec 执行新的程序。 父进程和子进程 子进程的PCB是根据父进程复制而来的,所以其中的umask 掩码也和父进程一样。 父进程在创建子进程时会复制一份环境变量给子进程,但此后二者的环境变量互不影响。 环境变量 exec 系统调用 exec 系统调用执行新程序时会把命令行参数和环境变量表传递给main 函数 和命令行参数argv类似,环境变量表也是一组字符串 全局变量 environ libc 中定义的全局变量environ指向环境变量表, environ 没有包含在任何头文件中,所以在使用时要用extern声明。 12345extern char **environ;int i;for(i=0; environ[i]!=NULL; i++) printf("%s\n", environ[i]); // 打印出环境变量return 0; 环境变量 ,环境变量字符串都是name=value 这样的形式, name 由大写字母加下划线组成，叫做环境变量 value：,value 的部分则是环境变量的值。 环境变量值含义 PATH 1$ echo $PATH // 查看环境变量的值: $xxx SHELL : 它的值通常是/bin/bash 。 gentenv 函数 查找某一个环境变量的值它对应的value ； sentenv 函数 修改环境变量可以用以下函数 进程控制fork 函数 pid = fork() 调用的返回结果 调用过程 父进程和子进程的PCB信息相同,用户态代码和数据也相同； 现在有两个一模一样的进程看起来都调用了fork 进入内核等待从内核返回，返回的先后顺序取决于内核的调度算法 fork函数 fork 函数的特点概括起来就是“调用一次,返回两次”,在父进程中调用一次,在父进程和子进程中各返回一次。 子进程中fork 的返回值是0,而父进程中fork 的返回值则是子进程的id gdb调试 gdb只能跟踪一个进程(默认是跟踪父进程)，而不能同时跟踪多个进程， 但可以设置gdb 在fork 之后跟踪父进程还是子进程 1$ (gdb) set follow-fork-mode child // gdb 跟踪子进程 exec 函数 子进程如何执行程序 用fork 创建子进程后执行的是和父进程相同的程序，子进程往往要调用一种exec 函数以执行另一个程序。 调用exec 并不创建新进程，以调用exec 前后该进程的id并未改变。 exec 函数族 如果调用出错则返回-1，所以exec 函数只有出错的返回值而没有成功的返回值。 不带字母p(表示path)的exec函数第一个参数必须是程序的相对路径或绝对路径 1/bin/ls or ./a.out 不能是 ls or a.out 于带字母p的函数: 如果参数中包含 / ，则将其视为路径名。 否则视为不带路径的程序名，在PATH环境变量的目录列表中搜索这个程序。 带有字母l(表示list)的exec函数 要求将新程序的每个命令行参数都当作一个参数传给它 命令行参数的个数是可变的 对于带有字母v(表示vector)的函数 则应该先构造一个指向各参数的指针数组,然后将该数组的首地址当作参数传给它,数组中的最后一个指针也应该是NULL 就像main 函数的argv参数或者环境变量表一样。 对于以e(表示environment)结尾的exec 函数 可以把一份新的环境变量表传给它,其他exec 函数仍使用当前的环境变量表执行新程序。 事实上,只有execve是真正的系统调用,其它五个函数最终都调用execve man 2 execve upper 函数 转换小写为大些 函数实现 123while((ch = getchar()) != EOF) &#123; putchar(toupper(ch)); &#125; she’ll的重定向功能 简单的标准输入输出重定向(&lt;和&gt;) 1234$ cat file.txtthis is the file, file.txt, it is all lower case.$ ./upper &lt; file.txtTHIS IS THE FILE, FILE.TXT, IT IS ALL LOWER CASE. wait and waitpid 函数 彻底清除进程 一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存； 内核在其中保存了一些关于进程是否正确退出 Shell是它的父进程,当它终止时Shell调用wait 或waitpid 得到它的退出状态同时彻底清除掉这个进程。 僵尸(Zombie)进程 如果一个进程已经终止,但是它的父进程尚未调用wait 或waitpid对它进行清理 自动调用函数，除非自己写函数进行查看。 12$ ps u // 查看进程状态STAT 为z时 -- 僵尸进程的状态 清除僵尸进程 调用函数 进程间通信IPC InterProcess Communication 进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到。 进程之间要交换数据必须通过内核，进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走。 Pipe 管道 函数 12#include &lt;unistd.h&gt;int pipe(int filedes[2]); 数组filedes[0] 指向管道的读端，filedes[1] 指向管道的写端(很好记,就像0是标准输入1是标准输出一样)。 管道单向通信 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。 父进程关闭管道读端,子进程关闭管道写端。 数据从写端流入从读端流出,这样就实现了进程间通信 管道通信的特殊情况 进程间通信必须通过内核提供的通道，两个进程通过一个管道只能实现单向通信 管道的读写端通过打开的文件描述符来传递； 通过fork 传递文件描述符使两个进程都能访问同一管道,它们才能通信。 其他 IPC 机制]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell_script]]></title>
    <url>%2F2019%2F04%2F22%2Fshell-script%2F</url>
    <content type="text"><![CDATA[Shell Script shell script 编写语法和执行 环境变量：变量值=文件所在的目录; Shell History Shell 用户的命令，用户输入一条命令，Shell就解释执行一条，不需要编译 Batch 批处理的方式，便是she’ll script Unix She’ll 本章只介绍bash 和sh的用法和相关语法,不介绍其它Shell。 切换其他的she’ll Shell 如何执行命令执行 用户在命令行输入命令后，一般情况下Shell会 并 该命令，但是Shell的内建命令例外。 内建命令 – 不创建新的进程 执行内建命令相当于调用Shell进程中的一个函数,并不创建新的进程。 凡是用which 命令查不到程序文件所在位置的命令都是内建命令 1$ man bash-builtins //查询内建命令 执行脚本 注释 用# 表示注释,相当于C语言的//注释 当#！作为开头，表示该脚本使用后面指定的解释器/bin/sh解释执行。 12$ chmod +x script.sh$ ./script.sh Shell会fork 一个子进程并调用exec 执行./script.sh这个程序 exec 系统调用应该把子进程的代码段替换成./script.sh程序的代码段，并从它的_start开始执行。 shript.sh 文本文件 文本文件根本没有代码段和_start函数,怎么办呢? 其实exec 还有另外一种机制： 如果要执行的是一个文本文件，并且第一行用Shebang指定了解释器 则用解释器程序的代码段替换当前进程,并且从解释器的_start开始执行,而这个文本文件被当作命令行参数传给解释器。 12345script.sh #! /bin/sh cd .. ls$ /bin/sh ./script.sh // exec 的另外一种机制： 执行脚本方法 – 创建了一个子进程 123$ ./script.sh ---&gt; $ (cd ..; ls -l)$ sh ./script.sh //cd ..命令改变的是子Shell的PWD ,而不会影响到交互式Shell(也就是不会影响到当前进程) 执行脚本方法 —- 直接在交互式Shell下逐行执行脚本中的命令 但是去掉（），这种方式也不会创建子Shell，而是直接在交互式Shell下逐行执行脚本中的命令。 123$ cd ..; ls -l --&gt; $ source ./script.sh--&gt; $ . ./script.sh 判断是否创建新的进程 建新的进程但执行结束后也会有一个状态码,也可以用特殊变量$?读出。 echo $? 通常也用0表示成功非零表示失败 Shell 语法变量 环境变量 环境变量可以从父进程传给子进程，进程调用 fork() 本地变量 只存在于当前Shell进程 12$ printenv // 显示当前Shell进程的环境变量。$ set //可以显示当前Shell进程中定义的所有变量(包括本地变量和环境变量)和函数。 环境变量是任何进程都有的概念,而本地变量是Shell特有的概念。 Shell 中变量的定义 环境变量、本地变量 ：变量的定义，等号两边都不能有空格 1234$ VARNAME=value // 变量的定义 $ export VARNAME // 用export命令可以把本地变量导出为环境变量 $ export VARNAME=value$ unset VARNAME // 可以删除已定义的环境变量或本地变量。 Shell 中变量的赋值 Shell变量的值都是字符串 12$ echo $SHELL // 查看变量$SHELL 的值$ echo $SHELL abc // 给$SHELL 变量赋值字符串 abc Shell变量不需要先定义后使用,如果对一个没有定义的变量取值,则值为空字符串。 文件名替换 这些用于匹配的字符称为通配符(Wildcard) Globbing所匹配的文件名是由Shell展开的,也就是说在参数还没传给程序之前已经展开 1$ ls /dev/ttyS* //匹配/dev/ttyS的所有文件 命令代换 由反引号括起来的也是一条命令 Shell先执行该命令, 然后将输出结果立刻代换到当前命令行中。 12$ DATE='date'$ echo $DATE --&gt; $DATE=$(date) 算数代换 $(()) $(()) 中的Shell变量取值将转换成整数 $(()) 中只能用+-*/和()运算符,并且只能做整数运算。 12$ VAR=45 // 变量的赋值$ echo $(($VRA +3)) 转义字符 \ \ 在Shell中被用作转义字符,用于去除紧跟其后的单个字符的特殊意义(回车除外) 在 \ 后面的字符取字面值 12$ echo $SHELL --&gt; /bin/bash$ echo \$SHELL --&gt; $SHELL 建立包含特殊字符的文件名 1$ touch \$\ \$\ // 创建一个文件名为“$ $”的文件 单引号 ‘ ‘ 和C语言不一样,Shell脚本中的单引号和双引号一样都是字符串的界定符,而不是字符的界定符 单引号用于保持引号内所有字符的字面值，即使引号内的\和回车也不例外, 1234$ echo '$SHELL' --&gt; $SHELL$ echo 'ABC\(回车) // 单引号需要配对，如果没有配对就输入回车&gt; DE'(再按一次回车结束命令) --&gt; ABC\ DE 双引号 “” 双引号用于保持引号内所有字符的字面值(回车也不例外) 有几种例外的情况，用到的时候在说 Bash 脚本 启动脚本是bash 启动时自动执行的脚本。 用户可以把一些环境变量的设置和alias 、umask 设置放在启动脚本中,这样每次启动Shell时这些设置都自动生效。 bash 在执行启动脚本时是以fork 子Shell方式执行的还是以source方式执行的? 交互登录Shell启动 交互Shell：是指用户在提示符下输命令的Shell而非执行脚本的Shell, 登录Shell：是在输入用户名和密码登录后得到的Shell 1/etc/profile // 用户设置都在这个脚本 Shell 脚本语法条件测试 命令test 或[ 可以测试一个条件是否成立 测试结果为真，Exit Status返回 0, 测试结果为假，Exit Status返回 1 1234$ VAR=2$ test $VAR -gt 1 --&gt; $ [ $VAR -gt 3 ] // 命令和参数要用空格隔开$ echo $? --&gt; $ echo $?0 --&gt; 1 测试命令 基本命令 与或非 作为一种好的Shell编程习惯，应该总是把变量取值放在双引号之中(展开为[ -d Desktop -a “” = ‘abc’ ]): 123456$ unset VAR$ [ -d Desktop -a $VAR = 'abc' ] bash: [: too many arguments$ [ -d Desktop -a "$VAR" = 'abc' ]$ echo $? 1 分支控制 在Shell中用if 、then 、elif 、else 、fi这几条命令实现分支控制 规则 如果两条命令写在同一行则需要用;号隔开，一行只写一条则不需要 要注意命令和各参数之间必须用空格隔开 [ a b ] Exit Status为0(表示真) Shell脚本没有{}括号,所以用fi 表示if 语句块的结束。 “ : “号 1234567#! /bin/shif [ -f /bin/bash ] // 一条命令占一行then echo "/bin/bash is a file"else echo "/bin/bash is NOT a file"fiif :; then echo "always true"; fi // 有分号隔开 :是一个特殊的命令,称为空命令,该命令不做任何事，但Exit Status总是真。 read 的read 命令的作用是等待用户输入一行字符串,将该字符串存到一个Shell变量中。 1read YES_OR_NO Shell还提供了&amp;&amp;和||语法 &amp;&amp;相当于“if…then…”,而 || 相当于“if not…then…” 而上面讲的-a和-o仅用于在测试表达式中的两个条件、 12test "$VAR" -gt 1 -a "$VAR" -lt 3 // -gt 大于； -lt 小于； -a 测试test "$VAR" -gt 1 &amp;&amp; test "$VAR" -lt 3 case/esac case 命令可类比C语言的switch/case 语句,esac 表示case 语句块的结束。 Shell脚本的case 可以匹配字符串和Wildcard 末尾必须以;;结束 执行时找到第一个匹配的分支并执行相应的命令,然后直接跳到esac 之后,不需要像C语言一样用break 跳出。 $1 是一个特殊变量, 123456case $1 in start) echo "" ;; stop) echo "" ;;esac $1 是一个特殊变量,在执行脚本时自动取值为第一个命令行参数,也就是start 命令行参数指定为stop 、reload或restart 可以进入其它分支执行停止服务、重新加载配置文件或重新启动服务的相关命令。 1$ sudo /etc/init.d/apache2 start // 传入start进行执行 for / do / done Shell脚本的for 循环结构和C语言很不一样,它类似于某些编程语言的foreach循环。 1$ for FILENAME in chap?; do mv $FILENAME $FILENAME~; done // 将文件chap 替换成chap~ while/do/done while 的用法和C语言类似。比如一个验证密码的脚本: 1234567#! /bin/shecho "Enter password:" # ""保留字面值read TRY # 读用户输入while [ "$TRY" != "secret" ]; do echo "Sorry, try again" read TRYdone 位置参数和特殊变量 Shell自动赋值的特殊变量 位置参数可以用shift 命令左移 比如shift 3 表示原来的$4 现在变成$1, 原来的$1、$2、$3 丢弃,$0不移动。(不够移动) 不带参数的shift 命令相当于shift 1 函数 规则 Shell中也有函数的概念,但是函数定义中没有返回值也没有参数列表。 函数体的左花括号：{ 和后面的命令之间必须有空格或换行 最后一条命令和右花括号 } 写在同一行，命令末尾必须有“ ; “号 1foo()&#123; echo "Function foo is called";&#125; # 不在同一行就不需要加 函数先定义，后使用； 函数调用，foo 后面不加（） Shell脚本中的函数必须先定义后调用,一般把函数定义都写在脚本的前面,把函数调用和其它命令写在脚本的最后 类似C语言中的main 函数,这才是整个脚本实际开始执行命令的地方 Shell函数没有参数列表并不表示不能传参数, 在函数内同样是用$0 、$1、$2 等变量来提取参数 函数中的位置参数相当于函数的局部变量,改变这些变量并不会影响函数外面的$0、$1 、$2等变量。 如果return后面跟一个数字则表示函数的Exit Status。 Shell 调试方法 调试脚本的选项 1$ sh -x ./script.sh 在脚本开头提供参数 1#! /bin/sh -x 在脚本中用set命令启用或禁用参数 set -x和set +x 分别表示启用和禁用 “-x参数” 这样可以只对脚本中的某一段进行跟踪调试。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Language_test]]></title>
    <url>%2F2019%2F04%2F19%2FLanguage-test%2F</url>
    <content type="text"><![CDATA[语文考试描写方法描写方法 描写方法：是用生动形象的语言把人物或景物具体描绘出来的一种手法。 按内容来分：描写有人物描写和景物描写两种。 人物描写的方法主要有六种，即概括描写、肖像描写、语言描写、行动描写 、心理描写、细节描写； 景物描写则包括静态与动态、客观与主观、反衬与对比三种。 按特征分类有： 白描，所谓“白描”是指抓住事物的主要特征，并以简洁的语言勾画出事物形象的一种写法，鲁迅 先生非常善于使用白描手法，如《藤野先生》中关于藤野先生的一段介绍：“其时进来的是一个黑瘦的先生，八字须，戴着眼镜，挟着一叠大大小小的书。一将书放在讲台上，便用了 缓慢而很有顿挫的声调，向学生介绍自己道：‘我就是叫作藤野严九郎的……。’”语言 简洁，印象深刻。 细描，细描是指对事物的一笔一画的精雕细刻，相对于白描，细描也可以称为工笔，如阿累的《一 面》写鲁迅就比鲁迅写藤野又细一些：“他的面孔黄黑带白，瘦得教人担心，好象大病新愈 的人，但是精神很好，没有一点颓唐的样子。头发约莫一寸长，显然好久没剪了，却一根一 根精神抖擞地直竖着。胡须很打眼，好象浓墨写的隶体‘一字’。”? 表达方式 表达方式：分为叙述、描写、说明、抒情、议论的表达方式的分类解释； 一篇文章可以以一种表达方式为主，兼用其它表达方式； 现在流行的话题作文的要求里也有相关表述——可任选一种表达方式为主并综合运用其它各种表达方式。 综合起来，“表达方式”应当为在用语言、艺术、音乐、行动把思想感情表示出来时所采取的方法和形式。 表现手法 托物言志 写景抒情 叙事抒情 直抒胸臆 顺叙 倒叙 插叙 对比 衬托 卒章显志 象征 衬托 想象 联想 照应 寓情于景 托物言志 反衬 烘托 托物起兴 美景衬哀情 渲染 虚实结合 侧面描写 正面描写 直接抒情 间接抒情等，数量不限 写作手法：写作手法属于艺术表现手法（即：艺术手法和表现手法，也含表达手法（技巧））， 常见的有：夸张，对比，比喻，拟人，悬念，照应，联想，想象，抑扬结合、点面结合、动静结合、叙议结合、情景交融、衬托对比、伏笔照应、托物言志、白描细描、铺垫悬念、正面侧面比喻象征、借古讽今、卒章显志、承上启下、开门见山，烘托、渲染、动静相衬、虚实相生，实写与虚写，托物寓意、咏物抒情等。 表达方式就是常见的叙述、描写、抒情、议论和说明。（其实也属于艺术表现手法）。 修辞手法 常见的修辞方法，高考规定为8种：比喻、比拟、借代、夸张、对偶、排比、设问、反问。 比喻：比喻的结构一般由本体、喻体和比喻词构成。比喻的本体和喻体必须是不同的事物，但相互之间有相似点。运用比喻可以化平淡为生动，化深奥为浅显，化抽象为具体。 比拟：包括拟人和拟物两类。拟人是把物当人来描写，赋予物以人的情感、意志、动作等；拟物是把人当物来描写，或把此物当彼物来描写。运用比拟，可使人或物色彩鲜明，描写生动，蕴含丰富。 借代：用借体代本体。它不直接说出所要表述的人或物，而用上其相关的事物来代替，可用部分代整体，以特征代本体，以专名代泛称等，如《药》中以“花白胡子”代人物，便是以特征代本体。比喻要求本体与喻体有相似点，借代要求借体与本体有相同处。借代可使表达具体形象。 夸张：包括对事物作合情合理的夸大或缩小。鲁迅《药》中写道：“……眼光正像两把刀，刺得老栓缩小了一半。”后一句使用了“缩小”的夸张。夸张要合情合理，其作用是烘托气氛，增强联想，给人启示，增强表达效果。 对偶：俗称“对对子”，诗歌中叫“对仗”。对偶有宽对、严对之别。一般来说，上下两句应字数相等、词性相对、结构相同、意义相关；可以是短语，也可以是句子。有正对、反对、流水对等类型。用对偶，句子整齐，表意凝练，抒情酣畅。 排比：由三个或三个以上结构相同或相似、内容相关、语气一致的短语或句子构成。其作用在加强语气、强调内容、加重感情。 设问：无疑而问，在自问自答中引人注意，启人思考。 反问：也是无疑而问，但答案就在问句中，即用肯定的形式表示否定的意思，用否定的形式表示肯定的意思。有强化语气、强化情感的作用。 修此语句的欣赏 大学 中庸 读后感中庸 中庸的高明之处在于有过之而无不及，是至高的道德境界。以“诚”为贵，诚者自诚也，而道自道也，诚者物之终始，不诚无物，故君子诚之为贵，至诚不息，不息则久。 真诚是多么可贵的品质，只有内心真诚了才能通情达理，懂得通情达理才能明辨是非，学会了明辨是非才能通过现象看本质区别，从而达到中和之效。 诚，天地之道，其为物不贰，则其生物不测，皆承载着万事万物。 和而不流，中立而不倚，要达到中庸之道的精微境界，圣人亦所不能焉，更别说此等普通人了，虽力所不能及也，但臻于至善。 人一能之己百之，人十能之己千之。果真此道矣，虽愚必明，虽柔必强。 别人看一遍的书，我估计要看十遍才看懂，好吧，相信勤能补拙，但愿天道酬勤。 好学近乎知，力行近乎仁，知耻近乎勇。知斯三者，则知所以修身。 大学 《大学》以修身为其核心。为什么说心的力量如此之大，因为心的执念会指引你往“仁”的方向前进，一个人内心的善念大于恶，为人处事待人接物的首要反应都是与善念息息相关，言其行，修身其修心，则其正。君子有诸己，而后求诸人；无诸己，而后非诸人。且慎独矣，务本，本立而道生。 海纳百川，有容乃大； 壁立千仞，无欲则刚。 苟日新，日日新，又日新 重复着的简单，简单重复了不简单，温故而知新，抱着新颖的态度去对待日复一日的的事情，追求更新的境界，便会获得不同的感悟，如果能够做到一天新，就应该保持每天新，新了还要更新，不求最新，只求更新一层，新新如也，故无所不用其极。早起，读书，每每坚持如此～与生活合二为一，成为不可或缺的一部分。 修身，齐家，治国的推己及人的絜矩之道 心正而后身修，身修而后家齐；家齐而后国治；国治而后天下平，层层递进，环环相扣。这正与社会主义核心价值观的本质具有一致性。 富强、民主、文明、和谐； 自由、平等、公正、法治； 爱国、敬业、诚信、友善； 看书是为了能更好地融入于生活，知识最终还是要潜移默化地应用到社会生活中。 史记 在中国这个物华天宝，人杰地灵的泱泱文明古国里，中华文化，源远流长，博大精深，先贤们留给我们浩如烟海的精神财富——古文典籍。其中，满天星辰中，《史记》是最为璀璨，最熠熠生辉的一颗。细细品读完《史记》，可以是人感到3000年前，群雄蜂起，英雄拼搏，帝王称霸的峥嵘岁月。 《史记》为西汉史学家、文学家司马迁所著。记载了上自中国上古传说中的黄帝时代，下至汉武帝元狩元年，共3000多年的历史，全书包括十二本纪、三十世家、七十列传、十表、八书，共一百三十篇，五十二万余字，司马迁以其“究天人之际，通古今之变，成一家之言”的史识，完成了中国第一部，也是最为著名的纪传体通史。 《史记》思想深邃、气势开阔、笔力雄放，对后世史学和文学的发展都产生了深远影响，其首创的纪传体通史方法为历代“正史”开创先河。其丰富的艺术价值被古代的小说、戏剧、传记、文学、散文所传承并不断发展。从鲁迅“史学之绝唱，无韵之离骚”的高度评价中就可看出它对后世的影响。读《史记》，使我认识了四面楚歌中，乌江自刎的项羽；生灵涂炭中，起兵反秦的陈胜吴广；紧急危难中，智勇双全的蔺相如；流亡在外，却终登皇位的重耳……历史风云，世间百态，一次次震撼着我的心灵，其中勾践卧薪尝胆的故事最为引人深思。 公元前494年，吴国进攻越国，越国军队几乎全军覆没，无奈勾践只得屈辱求和，按照吴王的要求。勾践得在吴国服苦役。三年里，他忍辱负重，一心复国。回国后，他又艰苦奋斗，励精图治，与百姓同甘共苦，最终，“苦心人，天不负，三千越甲吞掉吴！” 勾践卧薪尝胆，雪耻灭吴的佳话至今为人们代代相传，它也为我们这些“少年不识愁滋味”的后人多了许思考：生活在当今的竞争大潮中，应居安思危，励精图治，居存思亡，艰苦奋斗；如果不具有忧患意识，不把目光放长远，畏惧困难而贪图安逸，得过且过，那么，他就会被这个社会淘汰，结果只会像吴王一样死路一条！ 困难与挑战虽往往给人以挫折，却能催人奋进，给人以力量，而安逸与保守虽可以暂时保身，但却可以使人堕落而遭淘汰，所以，遇到挫折，就做一只同暴风雨抗击的海燕吧！只有这样，才能见到雨后的晴天！ 作为炎黄子孙的我们是荣幸的，这是一个有着优秀传统的神秘国度，这是一个物华天宝的泱泱大国，这是一个人杰地灵的文明古国。先贤给我们留下了浩如烟海的古文典籍，作为后世子孙的我们在茫茫书海中寻觅古贤人的踪迹，感慨曾经的惊心动魄，思量曾经的纷纷扰扰，而作为华夏儿女的我在品读《史记》之后，也真切地感受到3500多年历史中充塞的豪迈、悲壮与辛酸。不过在“少年不识愁滋味”的同时更体会到了中华文化的博大精深。 阅读《史记》，不是仅仅为了某种知识性的获得，不是为了记住几个烦琐的历史事件和历史人物，而是从中欣赏体验，汲取一种精神养料。当孩子们今后面对困境时，能从忍辱负重的司马迁处获得一种力量，这才是我们教育的最终目的。让学生从小结识这样一些精神大师，并与之交流，掌握一种做人、做学问、看世界的方法，这才是受益终身的东西。按照这一思路，五体中书、表可暂且搁置一旁，其他112篇人物传记，则可以任意选出一篇慢慢品味，或挑自己感兴趣的历史人物事迹来一睹为快，总之，不拘一格，因人而异。 史家之绝唱，无韵之离骚。《史记》会一直流传下去，给更多人以感慨与教育。 儒学 论语《论语》的真谛，就是告诉大家，怎么样才能过上我们心灵所需要的那种快乐的生活。 《论语》终极传递的是一种态度，是一种朴素的、温暖的生活态度。孔夫子正是以此来影响他的弟子。这种变化最终达到了一个境界，叫做“神于天，圣于地”。 这六个字其实是中国人的人格理想：既有一片理想主义的天空，可以自由翱翔，而不妥协于现实世界上很多的规则与障碍；又有脚踏实地的能力，能够在这个大地上去进行他行为的拓展。 孔夫子的这个形象身上，凝聚着他内心传导出来的一种饱和的力量。这种力量就是后来孟子所说的“浩然之气”。 只有当天地之气凝聚在一个人心中的时候，它才能够如此的强大。《论语》的思想精髓就在于把天之大，地之厚的精华融入人的内心，使天、地、人成为一个完美的整体，人的力量因而无比强大。人对自然万物，有一种敬畏，有一种顺应，有一种默契。 这是一种力量，我们如果学会了提取锻造这种力量，我们就能够获得孔夫子那样的心胸。我们看到，孔夫子的态度非常平和，而他的内心却十分庄严。因为其中有一种强大的力量，那是信念的力量。孔夫子是一个特别讲究信念的人。其实，一个人的视力本有两种功能：一个是向外去，无限宽广地拓展世界；另一个是向内来，无限深刻地去发现内心。 我们的眼睛，总是看外界太多，看心灵太少。《论语》的精华之一，就是告诉我们，如何用平和的心态来对待生活中的缺憾与苦难。人首先要能够正确面对人生的遗憾，要在最短的时间内接受下来。不要纠缠在里面，一遍一遍地问天问地，这样只能加重你的苦痛。 第二个态度是，要尽可能地用自己所可以做的事情去弥补这个遗憾。 承认现实生活中的不足之处，并通过自己的努力去弥补这种不足，这就是《论语》告诉我们对待生活缺憾的态度。当一个不幸降临了，最好的办法就是让它尽快过去，这样你才会腾出更多的时间去做更有价值的事情，你才会活得更有效率，更有好心情。而一个人的自信心来自哪里？它来自内心的淡定与坦然。要做到内心强大，一个前提是要看轻身外之物的得与失。 假如一个人真能做到一日“三省吾身”（《论语?学而》），真能“见贤思齐焉，见不贤而内自省也”（《论语?里仁》），就做到了约制。而能够反省到自己的错误并且勇于改正，这就是儒者所倡导的真正的勇敢。 君子因为有心态的平和、安定和勇敢，他的安详舒泰是由内而外的自然流露；小人表现出来的则是故作姿态，骄矜傲人，因为他内心多的是一股躁气，气度上便少了一份安闲。你要想做一个别人愿意和你交流，也可以和你交流的人，最关键的是你要有一个敞亮的心怀。这就是《论语》中所提倡的“坦荡荡”的心境。 君子的力量始自于人格与内心。他的内心完满、富足，先修缮了自我修养，而后表现出来一种从容不迫的风度。一个人反省自己的行为，而能够不后悔、不愧疚，这个标准说低也低，我们每个人都可以做到；说高就是个至高无上的标准，大家想想，要使自己做过的每件事都禁得住推敲，实在又是极不容易的事。所以孔子才把它作为君子的人格标准。 一个人有了一种仁义的大胸怀，他的内心无比仁厚、宽和，所以可以忽略很多细节不计较，可以不纠缠于小的得失。只有这样的人，才能真正做到内心安静、坦然。 我们无法左右外在的世界，只有让内心的选择能力更强大。当我们很明白如何取舍，那么那些烦恼也就没有了，这就是孔夫子所说的“知者不惑”。 那么在今天这个社会，怎样成为一个君子？我想不妨从倡导“恒心”开始。 我们现在这个社会有了多元选择，我们在兴奋、激情的驱使下，在众多选择中摇来摆去，难以决定。这是缺乏“恒心”的表现。君子还有第三个标准，就是“矜而不争，群而不党”（《论语?卫灵公》）。 就是说：君子是合群的，虽然他内心里庄重、庄严不可侵犯，但他在一大群人里头却从来不争。同时，他也决不拉帮结派，谋取私利。君子则胸怀坦荡，因为他坦然无私，所以能够平和，能够以善意跟所有人走到一起。 孔子说：“君子耻其言而过其行。”（《论语?宪问》）这在今天成为一个成语，叫“言过其行”。一个人说的多于他做的，是君子之耻。 无论你的理想是大是小，实现所有理想的基础，在于找到内心的真正感受。一个人内心的感受永远比他外在的业绩更加重要。在今天看来，一个人的发展，最重要的往往不在于终极的理想有多么高远，而在于眼前拥有一个什么样的起点。我们往往不缺乏宏图伟志，而缺少通向那个志愿的一步一步积累起来的切实的道路。 理想和行动的关系，就如同引线和风筝的关系。这个风筝能飞多远，关键在于你手中的线。而这条线，就是你的内心愿望。你的内心越淡定，越从容，你就越会舍弃那些激烈的，宏阔的，张扬的，外在的形式，而尊重安静的，内心的声音。这会使你走到社会角色中的时候，能够不失去自我，能够有担当，能够做到最好。孔子强调一个人的内心修养，决不是放弃对社会的责任，而是为了更好地为社会服务。 “君子居之，何陋之有？”这句话可以从两个角度来理解。第一个角度，是君子有天下使命，不管这个地方是奢华的还是简陋的，对他来讲只是一个外在环境而已；第二个角度，就是君子的内心有一种恒定的能量，他可以使得周边熠熠生辉，繁华似锦，他自己生命里面的气场可以去改变一个简陋的地方。内在的心灵标准衡定你的生命是否开始有了一种清明的内省，并且从容不迫，开始对你做的事情有了一种自信和坚定。 孔子说：“不怨天，不尤人，下学而上达。知我者其天乎？”（《论语?宪问》）皇侃对这段话的解释是：“下学，学人事；上达，达天命。我既学人事，人事有否有泰，故不尤人；上达天命，天命有穷有通，故我不怨天也。”可见，“知天命”关键在于一个“知”字，要能够了解什么是自己的天命。当自己能够客观认识命运中的穷与通，人世间的好与坏，知道这一切都很自然，那么你就能理性把握，平静应对。有一句谚语说得好：两朵云只有在同一高度相遇，才能成雨。 学习《论语》，学习任何经典，所有古圣先贤的经验最终只有一个真谛，就是使我们的生命在这些智慧光芒的照耀下，提升效率，缩短历程，使我们尽早建立一个君子仁爱情怀，能够符合社会道义标准，不论是对自己的心还是对于社会岗位，都有一种无愧的交待。 我想圣贤的意义就在于，他以简约的语言点出人生大道，而后世的子孙或蒙昧地，或自觉地，或痛楚地，或欢欣地，一一去实践，从而形成一个民族的灵魂。 让那种古典的精神力量在现代的规则下圆润地融合成为一种有效的成分，让我们每一个人真正建立起来有效率、有价值的人生，大概这就是《论语》给予我们的终极意义 《论语》是春秋时期孔子的言论辑录，当中蕴涵着丰富的人生哲理。而于丹教授却以她自己方式更通俗地为我们广大群众解读了这本著作，从而使得这本千百年来的著作能够更贴近我们的生活。 于丹教授在她谈《论语》心得时，开篇就讲到：宋代开国宰相赵普曾经标榜说，自己以半部《论语》治天下。可见《论语》在古代社会生活和政治生活中发挥的巨大作用以及古人对《论语》的推崇。于丹教授明确地阐述自己的心得：“《论语》告诉大家的东西，永远是最简单的。《论语》的真谛，就是告诉大家，怎么样才能过上我们心灵所需要的那种快乐的生活”。 于丹教授告诉我们《论语》中对交友有非常明确的标准，谓之，益者三友损者三友。也就是说，好朋友有三种，坏朋友也有三种。这三种好朋友的标准是什么，会给我们的生活事业带来什么样的帮助；而那三种坏朋友又是什么样的，会给我们的人生带来怎样的影响，我们又如何来分辨好朋友和好朋友呢？ 其实人这一生有什么样的朋友直接反映他是一个什么样的为人，好朋友就是一本书，他可以打开整个你的世界，也就是我们经常说的物以类聚人以群分。什么样的人你只要观察他的社交圈子，从这样一个外在环境是可以看到他自己内心价值取向的。那么论语中鼓励交什么样的朋友呢？很简单，孔子说：在这个世界上，益者三友，损者三友；友直、友谅、友多闻，益矣；友偏辟、友善柔、友便妄，损矣。 先说三种好朋友，所谓益者三友就是友直、友谅、友多闻，也就是第一这个朋友为人要正直，要坦荡要刚正不阿，一个人不能有谄媚之色，要有一种朗朗人格，在这个世界上顶天立地，这是一种好朋友。因为他的人格可以反映你的人格，他可以在你怯懦的时候给你勇气，他可以在你犹豫不前的时候给你一种果断，这是一种好朋友。 第二种是友谅，也就是宽容的朋友。其实宽容有的时候是一种美德，他是这个世界上最深沉的美德之一，我们会发现，当我们不小心犯了过错或者对他人造成伤害的时候，有时候过分的苛责还有一种批评，都不如宽容的力量来得恒久。其实有时候最让我们内心受不了的是一个人在忏悔的时候没有得到他人的怨气反而得到淡淡的一种包容，所以有一个好朋友，他会给我们内心增加一种自省的力量；宽容的朋友不会使我们堕落或者更多的放纵自己反而会让我们从他人的内心包容上找到自己的弊病，找到自己的缺失。所以有一个宽容的好朋友，他是一种做人的情怀，他是一种悲悯，他是在这个世界上对于一花一叶、一草一木关怀中所折射出来的光芒，这是第二种好朋友。 第三种叫做友多闻，在先秦那个时代，不像我们有电脑，有这么发达的资讯，有铺天盖地的媒体，那个时候人要想广视听怎么办呢，最简单的一个办法，交个好朋友,让你朋友所读的书，那些间接经验转化成你自己的直接经验系统。当你在这个社会上感到犹豫彷徨有所踌躇的时候，到朋友那里以他的广见博识为你做一个参考，来帮助自己做出选择。所以结交一个多闻的朋友就像翻开一本辞典一样，我们总能从他人的经验里面得到自己的一个借鉴系统，这就是孔夫子所说的三种好朋友，叫友直、友谅、友多闻。 《论语》中的益者三友就是正直的朋友，宽容的朋友，广见博识的朋友，这就是孔老夫子所称道的三种好朋友；那孔老夫子所说的三种坏朋友又是些什么样的人呢？ 什么是友偏辟，就是性情暴躁的朋友。那当然，每一个人的生活不一样遇到的情况也不一样，很有可能遇到一件事，你还迷茫的时候你的朋友先怒了，先告诉你这件事情不能这么做。 第二种叫做友善柔。这个正好反着，这个不是脾气特别暴躁的朋友，是脾气特别优柔寡断的朋友。我们发现，过分优柔寡断其实他在浪费你的生命能源，也可能你要去辞职了，你说有一个机会我要下海或者我要跳槽，你去问朋友，朋友说想想吧，你现在的地方也不错呀，你要是万一走了你什么什么就丢掉了。 至于的三种，所谓友便妄，是最坏的一种朋友。大家都知道佞臣之说，佞，就是那种心怀鬼胎的，有心计的，要以一种不择手段的方法去谋取个人利益的这种小人。他们是真正的小人，是那种心理阴暗的人，但是这种人往往会打扮出来一副善良的面孔。由于他内心有所企图所以他对人的热情比那些没有企图的人可能要高好几十倍，所以你一不小心要是被这种人利用的话，那么你的一生你就给自己套上了枷锁。如果你不付出惨痛的代价，这个朋友是不会放过你的。这其实在考验我们自己的眼光和知人论事的能力。 损者三友，益者三友，它告诉你，在这一辈子里面所做的所有事情，内心是应该以朋友作为一个坐标的，这种标准有可能是防微杜渐的，不见得这个朋友作出多么伤大雅的事情来，哪怕就是一个苗头，他可能就觉得说这个人做我的朋友以后可能是我的危险。 宋代开国宰相赵普曾经标榜说，自己以半部《论语》治天下。可见《论语》在古代社会生活和政治生活中发挥的巨大作用以及古人对《论语》的推崇。 那么，对于我们现代社会，现代人的生活，《论语》还有什么现实意义吗？ 《论语》的真谛，就是告诉大家，怎么样才能过上我们心灵所需要的那种快乐的生活。就是教给我们如何在现代生活中获取心灵快乐，适应日常秩序，找到个人坐标。 《论语》是两千五百多年前，孔子教学和生活中的点点滴滴，被学生片片断断记录下来的语录。这些以课堂笔记为主的记录由他的学生汇集编纂，后来就成了《论语》。 《论语》终极传递的是一种朴素的、温暖的生活态度。大家知道，孔子弟子三千，其中有七十二贤人。孔夫子正是以这种朴素的、温和的生活态度来影响他的弟子，他的弟子都是一粒种子，把那种生活的态度、生活的智慧广为传播。 作文生命 路 中美贸易1.中美贸易战是美国主动挑起、强加于中国的 美国总统特朗普3月22日签署总统备忘录，将对中国进口的商品大规模征收关税，并限制中国企业对美投资并购。这次中美争端，不是中国挑起的，不是中国愿意的，是美国特朗普政府不惜破坏国际规则，强行加到中国身上的。 美国单方面、主动挑起中美贸易战，有人认为是服务于选举需要，有人认为是遏制中国的谋略，动机众说纷纭。但有一点是清楚的：中国无处可退。幻想着绥靖就能换来“和平”，只能是自欺欺人。在利益面前，商人的欲壑永远是无法填满的。 2.中方做好了充分的准备，奉陪到底决非一句空话 从外交部、大使馆，再到商务部的反应和应对，不难看出中方对此贸易战已经做足了功课。从外交到经济，甚至到政治到军事，无论美方采取怎样的举措，中方都准备了相应的预案。 我们对美方打贸易战将奉陪到底决非一句空话，而是有大量实实在在能力的支持。23日，中国商务部公布反制清单，拟对自美进口部分产品加征关税，涉及美对华约30亿美元出口。中国正在研究第二批、第三批清单，比如飞机、芯片领域。 3.挑起贸易战背后是美国对于中国崛起的恐惧 美国之所以费尽心思地针对中国，其目的很明确，就是要限制和打压这个正在崛起的国家——这符合美国作为守成大国的心理，也是其在战争选项之外，必然会选取的手段。 中国通过非战争的方式与守成国家进行磨合，是国际秩序进行调整的一个相对理性的方式，也是一个后发国家必然要经历的过程。我们需要做好这个心理准备。 4.美国拉拢盟友联合向中国施压是一厢情愿 为拉拢盟友一起施压中国，特朗普在当地时间22日批准修正条款，宣布在5月1日前，暂停对澳大利亚、加拿大、欧盟和韩国的进口钢铁产品和铝产品征收高关税。 然而，德国《世界报》等媒体已警告，欧盟如果此次在贸易上向美国“示弱”，特朗普很可能在今后变本加厉，拿欧盟“单独开刀”，到时候欧盟各国只能“吃不了，兜着走”。 可以说，世界多数国家对美国的战略信任度很低，与中国又大都有良好的贸易关系，为了本国利益的最大化，它们决不会给美国当棋子、当枪使，主动关上与中国做生意的大门。换句话说，美国已无领导世界共同遏制中国的号召力，它也欠缺与中国打一场大规模贸易战的统筹力和操控力。 5.美国发起贸易战不仅仅针对中国，是对国际贸易规则的公然践踏 早在3月8号下午，特朗普其实就已经签署了一项法令，除了墨西哥和加拿大被暂时豁免外，对来自所有国家的钢铁和铝制品都征收进口关税。 美国本次主动扣动针对全球的关税计划扳机，可以说是对国际贸易规则的一次公然践踏，是主动损害其自身形象和信誉的自残之举，短期内或许于商业经济有利，但从长远来看，则是美利坚帝国继续陨落的标志。总想着仗着美军的强势，把世界财富往美国聚拢，这种模式注定难以持久。 6.美国贸易战害人终害己，必将付出巨大代价 不少美国媒体分析称，对华贸易战将会导致美国消费者的生活成本增高。日常开销花费比例更大的低收入家庭将受到更大影响。美国大企业也将因贸易战受损巨大。中国后续的反击政策将给这些跨国公司造成沉重打击。 分析人士普遍认为，中国实施反制措施之后，美国的制造业产值和就业、进出口贸易都会随着贸易战激化而进一步受损。有澳大利亚学者模拟发现，如果所有国家都展开报复，美国GDP将下降5.2个百分点，损失高达9332亿美元；如果中国不再资助美国的预算赤字，美国的经济地震将更剧烈。特朗普以为“贸易战是好事”，结果只会适得其反。 7.打贸易战，已让美国站到全世界的对立面 若特朗普政府执意开打贸易战，国际社会都将为这场“战争”进行买单。华盛顿智库布鲁金斯学会的研究显示，如果美国挑起全球小型贸易战，即关税增加10%，则大多数经济体国内生产总值将减少1%至4.5%；如果全球爆发严重贸易战，即关税增加40%，则全球经济将重现“大萧条”。 在美国决定对进口钢铝产品征收高关税后，欧盟、日本等均批评这一行径，并考虑采取反制行动，就连“暂免”征税的墨西哥和加拿大也表示会“居安思危”，做“两手准备”。 8.团结一心，胜利终将属于中国 针对美方发起的“贸易战”，中方会根据美方的动作，有针对性地进行反击，并且最终都会严格地按照国际法的相关规定进行操作，对美方的行为，也将积极地推动国际法律诉讼，用法律来维护中国的国家利益。这将是中方理性反击的底线所在。 当然，若美方疯狂到了超越理性，选择毁灭性的行为，那中国一定会有自己的应对，也必然能够应对。大规模的贸易战会同时伤及中美经济，但也会逼迫中国经济朝着更有利于释放本国潜力的方向转型。中国没有理由在美国的挑衅面前惧战。]]></content>
      <categories>
        <category>lanuage test</category>
      </categories>
      <tags>
        <tag>hust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file_system]]></title>
    <url>%2F2019%2F04%2F18%2Ffile-system%2F</url>
    <content type="text"><![CDATA[file_system 文件系统：目录管理结构 + 数据存储；便于访问和读写 ext2 文件系统磁盘分区划分 磁盘分区 格式化工具：mkfs 对每个分区进行格式化 目的：格式化为某种文件系统，才能存储文件 格式化过程：在磁盘写一些管理存储布局的信息。 文件系统 文件系统中存储的最小单位是块(Block)； Block size 12$ mke2fs -b 1024 / 2048 / 4096 //指定块的大小// 32位的每一页大小是4kb ext2文件系统 总体布局 Boot block : size : 1 kb 启动块是由PC标准规定的,用来存储磁盘分区信息和启动信息,任何文件系统都不能使用启动块。 ext2 文件系统：整个分区划成若干个同样大小的块组(Block Group) super block ： 功能：描述整个分区的文件系统信息,例如块大小、文件系统版本号、上次mount 的时间 损坏：损坏就会丢失整个分区的数据，所以超级块在每个块组的开头都有一份拷贝。 Grope Descriptor Table 功能：由很多块组描述符组成, 块组描述符：存储一个块组的描述信息，一旦块组描述符意外损坏就会丢失整个块组的数据 Block Bitmap size : one block 功能：块位图就是用来描述整个块组中哪些块已用哪些块空闲的,它本身占一个块, 1 表示占用； 0 表示空闲 12$ df // 用df命令统计整个磁盘的已用空间,直接查看block bitmap$ du //用du 命令查看一个较大目录的已用空间就非常慢,要搜遍整个目录的所有文件。 inode bitmap size : one block 功能：中每个bit表示一个inode是否空闲可用。 inode table 功能：存储文件的描述信息 1$ ls -l // 文件信息都保存在iNode中 构成：每个文件都有一个inode； 个块组中的所有inode组成了inode表。 size：一个块组有多少个8KB就分配多少个inode。 也可以近似认为数据块有多少个8KB就分配多少个inode, data block 目录：该目录下的所有文件名和目录名存储在数据块中 注意文件名保存在它所在目录的数据块中 :目录也是一种文件,是一种特殊类型的文件。 设备文件：FIFO和socket等特殊文件没有数据块,设备文件的主设备号和次设备号保存在inode中。 查看指令 home 目录下 1$ ls -l // 为什么各目录的大小都是4096的整数倍 zero 字符设备文件 1$ ls -l /dev // xconsole 文件的类型是p(表示pipe) 是一个FIFO文件,是一块内核缓冲区的标识, 不在磁盘上保存数据,因此没有数据块,文件大小是0。 zero 文件的类型是c，表示字符型设备文件 它代表内核中的一个设备驱动程序,也没有数据块,原本应该写文件大小的地方写了1, 5 这两个数字,表示主设备号和次设备号 访问该文件时,内核根据设备号找到相应的驱动程序 ln 符号链接 123$ touch hello // touch 文件权限 666$ ln -s ./hello halo // 符号链接halo 指向hello；halo文件保存./hello路进名$ ls -l ln 硬链接 12$ ln ./hello hello2$ ls -l hello2和hello 除了文件名不一样之外,别的属性都一模一样 硬链接数：ls -l 第二栏的数字 表示一个文件在文件系统中有几个名字 hello 和hello2是同一个文件在文件系统中的两个名字 硬链接数也保存在inode中 12345$ mkdir a // creat a file$ mkdir a/b // 在目录a 创建 b file$ ls -ld a // 硬链接数 是3$ ls -la a$ ls -la a/b 目录的硬链接 目录的硬链接只能通过 a/b 这种方式创建 用ln命令可以创建目录的符号链接,但不能创建目录的硬链接。 文件系统的实例格式化分区 创建一个1MB文件，并清零 1$ dd if=/dev/zero of=fs count=256 bs=4k dd 命令可以把一个文件的一部分拷贝成另一个文件。 到/dev/zero 是一个特殊的设备文件,它没有磁盘数据块,对它进行读操作传给设备号为1, 5的驱动程序. if和of 参数表示输入文件和输出文件,count 和bs 参数表示拷贝多少次,每次拷多少字节。 格式化并清零 123$ mke2fs fs // 格式化文件$ dumpe2fs fs // 查看这个分区的超级块和块组描述符表中的信息$ od -tx1 -Ax fs // 二进制文件的查看 mount 挂载 123$ sudo mount -o loop fs /mnt$ cd /mnt/$ ls -la 会出现三个目录 “.”表示当前目录, “..”表示上一级目录, lost+found 目录由e2fsck工具使用,如果在检查磁盘时发现错误,就把有错误的块挂在这个目录下 sudo unmount /mnt ：取消挂载 debugfs 工具 123$ debugfs fs // 它提供一个命令行界面,可以对文件系统做各种操作$ debugfs: help //$ debugfs: quit 例如查看信息、恢复数据、修正文件系统中的错误。 数据块寻址 数据块 通过inode中的索引项Blocks[0-14] 索引项一共有15个,从Blocks[0] 到Blocks[14] ,每个索引项占4字节。 索引项Blocks[12] 所指向的块并非数据块,而是称为间接寻址块(Indirect Block) 访问文件中的任意数据 只需要两次读盘操作,一次读inode(也就是读索引项)一次读数据块。 而访问大文件中的数据 则需要最多五次读盘操作:inode、一级间接寻址块、二级间接寻址块、三级间接寻址块、数据块 文件和目标操作的系统文件系统函数 stat stat(2)函数读取文件的inode 然后把inode中的各种文件属性填入一个struct stat 结构体传出给调用者。 access 函数 access(2) 函数检查执行当前进程的用户是否有权限访问某个文件 access函数取出文件inode中的st_mode 字段,比较一下访问权限，0/-1 chmod(2) 和fchmod(2) 函数 改变文件的访问权限,也就是修改inode中的st_mode字段 utime(2) 函数 改变文件的访问时间和修改时间, link(2)函数 创建硬链接,其原理是在目录的数据块中添加一条新记录,其中的inode号字段和原文件相同。 symlink(2) 函数创建一个符号链接,这需要创建一个新的inode,其中st_mode字段的文件类型是符号链接 unlink(2) 函数删除一个链接。 rename(2) 函数 改变文件名,需要修改目录数据块中的文件名记录, VFS (Virtual Filesystem)目录树 不同的磁盘分区、光盘或其它存储设备都有不同的文件系统格式,然而这些文件系统都可以mount 到某个目录下。 用ls命令看起来是一样的,读写操作用起来也都是一样的 VFS Linux 内核在各种不同的文件系统格式之上做了一个抽象层； 使得文件、目录、读写访问等概念成为抽象层的概念 因此各种文件系统看起来用起来都一样,这个抽象层称为虚拟文件系统 内核数据结构 每个进程的process control block 保存着一份文件描述符 已打开的文件在内核中用file 结构体表示,文件描述符表中的指针指向 file struct file struct 维护File Status Flag(file 结构体的成员f_flags) 和当前读写位置(file 结构体的成员f_pos ) f_count：表示引用计数(Reference Count) 例如有fd1和fd2 都引用同一个file 结构体，要close（d1）,close(d2)； 才会释放file struct file_operation 每个file 结构体都指向一个file_operations 结构体,,这个结构体的成员都是函数指针 指向实现各种文件操作的内核函数。 dentry 每个file 结构体都有一个指向dentry结构体的指针,“dentry”是directory entry(目录项)的缩写 为了减少读盘次数,内核缓存了目录的树状结构,称为dentry cache inode 每个dentry结构体都有一个指针指向inode 结构体。 inode 结构体保存着从磁盘inode读上来的信息。 super_block inode 结构体有一个指向super_block结构体的指针 super_block结构体保存着从磁盘分区的超级块读上来的信息, dup and dup2 函数 dup 和dup2 都可用来复制一个现存的文件描述符,使两个文件描述符指向同一个file 结构体。 dup2 12int dup(int oldfd);int dup2(int oldfd, int newfd);]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>file_system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file_and_IO]]></title>
    <url>%2F2019%2F04%2F13%2Ffile-and-IO%2F</url>
    <content type="text"><![CDATA[FIle and IO 本书中库函数和系统函数的区别和联系 库函数：对应的是C的标准库，针对符号的处理和I/O操作 函数操作的区域是：buffer 系统函数：内核提供给应用程序的接口 sys/xxx 函数操作的区域是：内核 本书中讲解的计算机的体系结构：好好学习x86平台 只讲Linux平台的特性，只讲Linux内核的工作原理， 涉及体系结构时只讲x86平台 汇编程序的Hello world 注意在C语言中字符串的末尾隐含有一个’\0’ ，而汇编指示.ascii定义的字符串末尾没有隐含的’\0’ 。 在汇编程序中用”. xxx”可以取出当前地址计数器的值,是一个常量。 C标准I/O库函数与Unbuffered I/O函数 对于C标准I/O库来说，打开的文件由FILE *指针标识； 而对于内核来说，打开的文件由文件描述符标识，文件描述符从open 系统调用获得； Unbuffered I/O 函数 Unbuffered I/O函数是UNIX标准的一部分 在所有支持C的平台上应该都可以用C标准库函数(除了有些平台的C编译器没有完全符合C标准之外) 而只有在UNIX平台上才能使用Unbuffered I/O函数 1#include &lt;unistd.h&gt; Man Page中的 COMFORMING TO部分可以看出来一个函数接口属于哪个平台。 我们知道UNIX的传统是Everything is a file，Unbuffered I/O的函数属于无缓存的函数,也就是直接写到设备。 关系 文件描述符 Linux Kernel 中 task_struct ：维护进程信息，Process Descriptor file_srtuct ：文件描述符表 每个表包含已打开的文件指针 用户程序不能直接访问内核中的文件描述符表,而只能使用文件描述符表的索引(即0、1、2、3这些数字),这些索引就称为文件描述符(File Descriptor) Open and CloseOpen 函数flags参数 open的flags参数 O_CREAT: 若此文件不存在则创建它。使用此选项时需要提供第三个参数mode ,表示该文件的访问权限。 O_TRUNC: 如果文件已存在,并且以只写或可读可写方式打开,则将其长度截断(Truncate)为0字节。 open and fopen 区别 创建新的文件，和文件追加内容那块有区别； open函数 mode参数 文件的权限 文件的权限由open 的mode参数和当前进程的umask 掩码共同决定。 几个权限值 Shell进程的umask 12$ umask // 权限值是 0022 //umask 掩码：就是取umask的反码 touch file 12$ touch file // 用touch 命令创建一个文件时,创建权限是0666$ ls -l file // 看到文件是 -rw; 而touch 进程继承了Shell进程的umask 掩码,所以最终的文件权限是0666 &amp; ~022=0644。 gcc 12$ gcc main.c // 用gcc 编译生成一个可执行文件时,创建权限是0777,$ ls -l a.out // 文件的权限 -rwxr 同样道理,用gcc 编译生成一个可执行文件时,创建权限是0777,而最终的文件权限是0777&amp;~022=0755。 close 由open 返回的文件描述符一定是该进程尚未使用的最小描述符。 可以利用这一点在标准输入、标准输出或标准错误输出上打开一个新文件,实现重定向的功能。 read and writeread and fgetc 读数据的过程 read : 读上来的数据保存在缓冲区buf 中，同时文件的当前读写位置向后移； 没有取完的数据继续保存在buf中 读写位置：记录在内核中的。 fgetc: getc 有可能从内核中预读1024个字节到I/O缓冲区中,再返回第一个字节, 这时该文件在内核中记录的读写位置是1024 而在FILE 结构体中记录的读写位置是1。 是ssize_t,表示有符号的size_t read and write 中的count 面对读写常规文件时：read / write 的返回值通常等于请求写的字节数count 面对的是终端设备Terminal：通常以行为单位,读到换行符就返回，不一定是count。 面对网络读写时：有不同的传输协议，不一定是count 阻塞 Block 现象 阻塞状态：针对终端设备和网络读取 Sleeping：当进程调用一个阻塞的系统函数时，该进程被置于睡眠(Sleep)状态，这时内核调度其它进程运行，直到该进程等待的事件发生。 Running： 正在都被调度执行： 就绪状态 已经准备好，处于排队中，随时准备被调用 按照优先级进行调用 Unblocking 如果在open 一个设备时指定了O_NONBLOCK 标志,read / write 就不会阻塞。 轮询（Poll）方式 表示本来应该阻塞在这里(would block,虚拟语气),事实上并没有阻塞而是直接返回错误,调用者应该试着再读一次(again)。 调用者只是查询一下，而不是阻塞在这里死等，这样可以同时监视多个设备: 通过 goto 无条件跳转函数，实现非阻塞读终端 lseek 移动当前的读写位置 lseek 和 标准I/O库的fseek 函数类似,可以移动当前读写位置(或者叫偏移量)。 参数offset和whence的含义和fseek 函数完全相同。只不过第一个参数换成了文件描述符。 fseek 成功时返回0失败时返回-1,要返回当前偏移量需调用ftell 而lseek 成功时返回当前偏移量失败时返回-1。 Fcntl 对已经打开的文件，重新设定其属性，新设置读、写、追加、非阻塞等标志 （file status flag） 优点：不用重新打开文件 像标准输入 stdin stdout stderr；这些标准输出文件，在开始运行的时候便已经打开； 或者其他已经打开的文件，需要重新设定其属性 Shell 的重定向功能 利用Shell的重定向功能在该描述符上打开文件 open打开的文件，返回的文件描述符一定是该进程尚未使用的最小描述符； 以利用这一点在标准输入、标准输出或标准错误输出上打开一个新文件,实现重定向的功能。 shell重定向语法 如果在&lt;、&gt;、&gt;&gt;、&lt;&gt;前面添一个数字，该数字就表示在哪个文件描述符上打开文件, file_and_io/fcntl/cmd_flag.c 123$ ./cmd.flag 0 &lt; /dev/tty //时将它的标准输入重定向到/dev/tty ,并且是只读的。// argv[0] 是"./a.out",argv[1] 是"0"//重定向由Shell解释,在启动程序时已经生效,程序在运行时并不知道标准输入被重定向了。 123$ ./a.out 1 &gt; temp.foo // 标准输出，重定向到文件temp.foo$ ./a.out 2 2&gt;&gt;temp.foo //,注意2和&gt;&gt;之间不能有空格,否则2就被解释成命令行参数了。$ ./a.out 5 5&lt;&gt;temp.foo /dev/null 设备文件 /dev/null 设备文件只有一个作用,往它里面写任何数据都被直接丢弃。 因此保证了该命令执行时屏幕上没有任何输出，既不打印正常信息也不打印错误信息，让命令安静地执行。 这种写法在Shell脚本中很常见。 1$ command &gt; /dev/null 2&gt;&amp;1 //文件描述符数字写在重定向符号右边需要加&amp;号,否则就被解释成文件名，二期不能有空格 ioctl ioctl 用于向设备发控制和配置命令,有些命令也需要读写一些数据,但这些数据是不能用read /write 读写的,称为Out-of-band数据。 read/ write 读写的数据是in-band数据,是I/O操作的主体。 而ioctl 命令传送的是控制信息,其中的数据是辅助的数据。 mmap 映射函数Introduction mmap 可以把磁盘文件的一部分直接映射到内存,这样文件中的位置直接就有对应的内存地址； 对文件的读写可以直接用指针来做而不需要read /write 函数。 strace command 1$ strace ./a.out]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>file and IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三极管和场效应管的工作原理]]></title>
    <url>%2F2019%2F04%2F08%2FAudionNPN%2F</url>
    <content type="text"><![CDATA[三极管的详解 Reference 电荷的判断 正电荷是不会移动的，只有负电荷（电子）才能移动； 负电荷的移动，形成了电势差； 电势差的产生，形成了电流，电流是正电荷。 特性 核心是“PN”结； 电流的流向是PN时，才是正向偏执 发射区：发射的是电子 溶度高的话，利于渗透 集电结面积大：集电区与发射区为同一性质的掺杂半导体，但集电区的掺杂浓度要低，面积要大，便于收集电子。 发射区高掺杂：为了便于发射结发射电子，发射区半导体掺浓度高于基区的掺杂浓度，且发射结的面积较小; 三极管不是两个PN结的间单拼凑，两个二极管是组成不了一个三极管的！ 电流控制原理 电流里面的是正离子，电子往相反方向流。 外加电压使发射结正向偏置，集电结反向偏置。 集/基/射电流关系： IE = IB + IC IC = β * IB 如果 IB = 0, 那么 IE = IC = 0 电压控制原理 集-射极电压UCE为某特定值时，基极电流IB与基-射电压UBE的关系曲线。 UBE&lt;UBER时，三极管高绝缘，UBE&gt;UBER时，三极管才会启动； UCE增大，特性曲线右移，但当UCE&gt;1.0V后，特性曲线几乎不再移动。 输出特性 基极电流IB一定时，集极IC与集-射电压UCE之间的关系曲线，是一组曲线。 当IB=0时, IC→0 ,称为三极管处于截止状态，相当于开关断开; 当IB&gt;0时, IB轻微的变化,会在上以几十甚至百多倍放大表现出来; 当IB很大时，IC变得很大，不能继续随IB的增大而增大，三极管失去放大功能，表现为开关导通。 三极管核心功能 放大功能：小电流微量变化，在大电流上放大表现出来。 开关功能：以小电流控制大电流的通断。 NPN and PNP区别 NPN 是用 B→E 的电流（IB）控制 C→E 的电流（IC），E极电位最低，且正常放大时通常C极电位最高，即 VC &gt; VB &gt; VE PNP 是用 E→B 的电流（IB）控制 E→C 的电流（IC），E极电位最高，且正常放大时通常C极电位最低，即 VC &lt; VB &lt; VE 电路接法 NPN的接法 PNP的接法 元器件的代表 PNP : s8550 NPN: s8050 场效应管 Reference Reference2 场效应管的划分 场效应管(FET)是场效应晶体管(field-effect transistor)的简称，即：在一定结构的半导体器件上，加上二氧化硅和金属，形成栅极。 所有的FET都有栅极g(gate)、漏极d(drain)、源极s(source)三个极 分别对应双极性晶体管的基极b(base)、集电极c(collector)和发射极e(emitter)。 P区与N区交界面形成耗尽层，而漏极d与源极s间的非耗尽层区域称为导电沟道。 MOS管工作原理–MOS管的特性MOS管的输入、输出特性 对于共源极接法的电路，源极和衬底之间被二氧化硅绝缘层隔离，所以栅极电流为0。 MOS管的导通特性 MOS管作为开关元件，同样是工作在截止或导通两种状态。由于MOS管是电压控制元件，所以主要由栅源电压uGS决定其工作状态。 NMOS的特性 Vgs大于一定的值就会导通，适合用于源极接地时的情况(低端驱动)，只要栅极电压达到4V或10V就可以了。 PMOS的特性， Vgs小于一定的值就会导通，适合用于源极接VCC时的情况(高端驱动)。 但是，虽然PMOS可以很方便地用作高端驱动，但由于导通电阻大，价格贵，替换种类少等原因，在高端驱动中，通常还是使用NMOS。 场效应管的工作原理 结型场效应管(JFET)因有两个PN结而得名 绝缘栅型场效应管(JGFET)则因栅极与其它电极完全绝缘而得名 为绝缘栅型场效应管的栅极为金属铝，故又称为MOS管。 分成耗尽型与增强型 耗尽型：当栅压为零时有较大漏极电流的称为 增强型：当栅压为零，漏极电流也为零，必须再加一定的栅压之后才有漏极电流的称为。 无论是结型场效应管还是绝缘栅型场效应管，无论是耗尽型场效应管或是增强型场效应管，都可分为N沟道和P沟道，其结构分别如下图所示 如何进行区分 结型场效应管–结型 N沟道结型场效应管—-结型 为保证能正常工作，应在其栅-源之间加负向电压(即uGS&lt;0),以保证耗尽层承受反向电压; 在漏-源之间加正向电压uDS，以形成漏极电流。 栅-源之间负向电压越大，PN结交界面所形成的耗尽区就越厚，导电沟道越窄，沟道电阻变大，漏极电流iD越小; 若栅-源之间负向电压越小，则耗尽区就越薄，导电沟道越宽，沟道电阻变小，漏极电流iD越大。 因此实现了场效应管的栅-源间负向电压对沟道电流的控制。 P沟道结型场效应管： 其栅-源之间加正向电压(即uGS&gt;0)才能保证其能能正常工作。 结型场效应管– 绝缘栅型 N沟道耗尽型MOS管为例+]]></content>
      <categories>
        <category>三极管</category>
        <category>场效应管</category>
      </categories>
      <tags>
        <tag>NPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Man Page]]></title>
    <url>%2F2019%2F04%2F02%2FManpage%2F</url>
    <content type="text"><![CDATA[LinuxC ManPage Man Page 是linux自带的文档 manual 手册 Command 列出某一个章节 12man passwd //这就是第一页man 5 passwd //指定第五页 列出可查询的章节 1234567man -aw printf //查询文档在第几章节result： /usr/share/man/man1/printf.1.gz // 在第一章和第三章 /usr/share/man/man3/printf.3.gzselect man 1 printf man 3 printf 一次性查阅所有章节 1man -a printf // 显示所有章节 看完第一章后，按下q退出，会让你选择继续查看还是退出 按下Enter便能继续阅读下一章节 在manual中搜索关键字 1man -k printf // 显示printf所在的章节 根据得到的结果，查询对应的章节 搜索函数名中含有其他关键字 1man -k "^s.*printf" //搜索含有s的printf 通过浏览器查看 12man -Hfirefox printf // 浏览器打开sudo apt-get install groff // Cannot open firefox 优化界面 给字体分配颜色：这个得加 1234567891011vi ~/.bashrc // 打开文件add code # Less Colors for Man Pages export LESS_TERMCAP_mb=$'\E[01;31m' # begin blinking export LESS_TERMCAP_md=$'\E[01;38;5;74m' # begin bold export LESS_TERMCAP_me=$'\E[0m' # end mode export LESS_TERMCAP_se=$'\E[0m' # end standout-mode export LESS_TERMCAP_so=$'\E[38;5;246m' # begin standout-mode - info box export LESS_TERMCAP_ue=$'\E[0m' # end underline export LESS_TERMCAP_us=$'\E[04;38;5;146m' # begin underline source ~/.bashrc]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Man Page</category>
      </categories>
      <tags>
        <tag>Man Page</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Standard Lib]]></title>
    <url>%2F2019%2F04%2F02%2FCStandardLib%2F</url>
    <content type="text"><![CDATA[C Standard Lib C标准主要由两部分组成，一部分描述C的语法，一部分描述C标准库。 平台支持C语言 实现C编译器 实现C标准库 函数文件的命名，以.c 为准 在 ’.c‘ file：void * 类型的数，做右值的时候会自动进行转换； 在 ’ .cpp ‘file：不会自动的转换 POSIX 是Unix系统的标准，不属于C标准库 String Funcation 程序按功能划分可分为数值运算、符号处理和I/O操作三类, 符号操作：由各种基本的字符串操作组成。 字符串的初始化、取长度、拷贝、连接、比较、搜索等基本操作。 字符串的操作中：’ \0 ‘ 的操作要注意。操作可能是including，excluding size_t size_t 是一种类型，表示的是操作系统的位数，32位和64位 memset 初始化字符串 12void *memset(void *s, int c, size_t n);// 将指针s指向的存储空间的 n 位数，用 c 代替；memset(buf, 0, 10); //将buf的前10位用0初始化 strlen 1size_t strlen(const char* s); 计算字符串长度 注意数组的越界 拷贝字符串 SCLib/memcpy strcpy and strncpy 拷贝以 ‘ \0 ‘结尾的字符串； 属于字符类型 以str开头的函数处理以’\0’ 结尾的字符串; 12char *strcpy(char *dest, const char *src);char *strncpy(char *dest, const char *src, size_t n); strn 不需要以 ‘\0’结尾，当source的前n个字节没有NULL（’\0’），那么dest不需要以NULL结尾 当source的字节数，少于n个字节，那么dest将填充足够的NULL（’\0’）直至满足n个字节 memcpy and memmove mem*：针对的是memory，存储单元 根据src指向的内存地址，拷贝n个字节（而不一定是字符串） 而以mem开头的函数则不关心’\0’ 字符,或者说这些函数并不把参数当字符串看待,因此参数的指针类型是void 而非char 12void *memcpy(void *dest, const void *src, size_t n);void *memmove(void *dest, const void *src, size_t n); memcpy的两个参数src 和dest 所指的内存区间如果重叠，则无法正常拷贝。 可以借助一个临时的缓存区，进行拷贝 在32位的x86平台上,每次拷贝1个字节需要一条指令,每次拷贝4个字节也只需要一条指令,memcpy函数的实现尽可能4个字节4个字节地拷贝,因而得到上述结果。 连接字符串 strcat and strncat 以str开头的函数处理以’\0’ 结尾的字符串; strncat strncat总是保证dest 缓冲区以’\0’ 结尾，这一点又和strncpy不同，strncpy并不保证dest缓冲区以’\0’结尾 dest至少含有的字节数：strlen(dest)+n+1个 比较字符串 memcmp memcmp - compare memory areas mem*：针对的是memory，存储单元 12int memcmp(const void *s1, const void *s2, size_t n);return 负值，0， 正值 memcmp从前到后逐个比较缓冲区s1和s2的前n个字节(不管里面有没有’\0’ ) strcmp and strncmp strcmp把s1和s2 当字符串比较,在其中一个字符串中遇到’\0’ 时结束; strncmp 遇到’\0’ 或者 比较完了n个字节，就结束。 搜索字符串 笔试估计会考，还有相应的算法。【算法导论】 strchr and strrchr 123locate character in stringchar *strchr(const char *s, int c); // 从前到后，找到第一次出现的C就返回char *strrchr(const char *s, int c);// 从后到前， 如果没有找到就返回 NULL 疑问：为什么character 是int型的而不是char类型？ strstr 12char *strstr(const char *haystack, const char *needle);返回值:如果找到子串,返回值指向子串的开头,如果找不到就返回NULL 堆haystack中找一根针needle ，按中文的说法叫大海捞针，显然haystack 是长字符串，needle 是要找的子串。 分割字符串 分隔符：符号是‘ ：’； 在编写Makefile 文件的时候； clean : 文件的编写，就需要加分隔符 分割符 很多文件格式或协议格式中会规定一些分隔符或者叫界定符(Delimiter),例如/etc/passwd文件中保存着系统的帐号信息。 strtok C标准库提供的strtok函数可以很方便地完成分割字符串的操作。 tok是Token的缩写,分割出来的每一段字符串称为一个Token 123#include &lt;string.h&gt;char *strtok(char *str, const char *delim);char *strtok_r(char *str, const char *delim, char **saveptr); 每次都是改写的str 第一次调用时把字符串传给strtok,以后每次调用时第一个参数只要传NULL 就可以了,strtok函数自己会记住上次处理到字符串的什么位置(显然这是通过strtok 函数中的一个静态指针变量记住的)。 标准I/O库函数文件的基本概念 用C标准库对文件进行读写操作,对文件的读写也属于I/O操作的一种 十六进制数，十六进制的ASCII值 12十六进制数 十六进制的ASCII值 5 32 ASCII 码值 0 - 127 : 128位的ASCII码值 有33位不能显示出来，只能显示95个 文本文件（Text file） Text file –&gt; Source file 文本文件是用来保存字符的 文件中的字节都是字符的某种编码(例如ASCII或UTF-8) 编写和查看 vi : 进行编辑 cat : 查看里面的内容 查看text file的长度 1$ ls -l textfile /* 查看文本的长度，vi会自动在文件末尾加一个换行符 */ od Command -tx1：将文件中的字节以十六进制码的形式列出来 -tc : 将文件中的ASCII码以字符形式列出来。 -Ax : 要求以十六进制显示文件中的地址。（类似于hexdump） 1234$ od -tx1 -tc -Ax textfile 000000 35 36 37 38 0a // 十六进制的ASCII码值 5 6 7 8 \n // 十六进制数000005 // 地址 123hexdump textfile 0000000 3635 3837 000a 0000005 二进制文件 Binary file Binary file 目标文件，库文件和可执行文件 有些字节表示各Section和Segment在文件中的位置,有些字节表示各Segment的加载地址。 查看 hexdump command :进行查看 fopen / fclose fopen : 就是在操作系统中分配一些资源用于保存该文件的状态信息，并得到该文件的标识。 fclose: man fopen 1FILE *fopen(const char *path, const char *mode); 指针类型：FILE * 返回值做判断：在代码中对返回值进行判断 12345if ( (fp = fopen("/tmp/file1", "r")) == NULL) /*绝对路径*/&#123; printf("error open file /tmp/file1!\n"); exit(1);&#125; mode “a” : 只能在文件末尾追加数据,如果文件不存在则创建 “a+”: 允许读和追加数据,如果文件不存在则创建 “w”: 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节再重新写,也就是替换掉原来的文件内容 “r”: 只读,文件必须已存在 路径的介绍 Shell 提示符显示当前目录 12~$ //当前工作目录是主目录/etc$ //当前工作目录是 /etc 绝对路径：不同进程下的工作目录 1fp = fopen("/tmp/file1", "w") 相对路径： 相对路径是相对于当前工作目录(Current Working Directory)的路径 每个进程都有自己的当前工作目录 Shell进程的当前工作目录可以用pwd 命令查看 123fp = fopen("file.a", "r"); //在当前工作目录下打开文件fp = fopen("../a.out", "r"); //只读打开当前工作目录下上一层目录下的文件fp = fopen("Desktop/file3", "w"); //当前工作目录下的子目录Desktop stdin/stdout/stderr 终端操作：人机交互的设备，此时的I/O是对设备的操作。 设备和文件占时不做区分 I/O设备的操作，printf 和scanf 不用打开就可以操作设备 c程序启动是会自动把终端设备打开三次, 分别赋给三个FILE *指针stdin 、stdout和stderr ， 这三个文件指针是libc 中定义的全局变量, 函数的操作 printf：向stdout中写； scanf：从stdin中读 stderr：打印标准错误，所以fopen的标准错误代码 12345if ( (fp = fopen("/tmp/file1", "r")) == NULL) /*绝对路径*/&#123; printf("error open file /tmp/file1!\n"); exit(1);&#125; errno / perror errno 很多系统函数在错误返回时将错误原因记录在libc 定义的全局变量errno 中 每个错误原因对因一个错误码。 所有错误码都是正整数。 perror 对错误码errno的整数进行解读：解释成字符串再打印 可以添加附加信息：方便定位错误 123456789int main(void)&#123; FILE *fp = fopen("abcde", "r"); if (fp == NULL) &#123; perror("Open file abcde"); // 添加的额外信息Open file abcde： exit(1); &#125; return 0;&#125; strerror strerror 函数可以根据错误号返回错误原因字符串。 以后学线程库时我们会看到,有些函数的错误码并不保存在errno 中,而是通过返回值返回。就不能调用perror打印错误原因了，这时strerror就需要使用strerror 1fputs(strerror(n), stderr); 以字节为单位的I/O函数 CSlib/fgetc.c fgetc(stdin) 从指定的文件中读一个字节 fgetc 读到文件末尾时返回EOF ，只是用这个返回值表示已读到文件末尾,并不是说每个文件末尾都有一个字节是EOF (根据上面的分析,EOF并不是一个字节)。 getchar 从标准输入读一个字节 调用getchar() 相当于调用fgetc(stdin) 1234#include &lt;stdio.h&gt;int fgetc(FILE *stream);int getchar(void);返回值:成功返回读到的字节,出错或者读到文件末尾时返回EOF fputs 向指定的文件写一个字节 每调用一次fputc ,读写位置向后移动一个字节,因此可以连续多次调用fputc 函数依次写入多个字节 putchar(c) 向标准输出写入一个字节 调用putchar，相当于调用fputc( c, stdout ) 从终端输入时有两种方法表示文件结束 直接输入 ctrl + D 利用Shell 的Heredoc语法 &lt;&lt;END 表示从下一行开始是标准输入,直到某一行开头出现END时结束。 &lt;&lt; 后面的结束符可以任意指定,不一定得是END ,只要和输入的内容能区分开就行。 123456$ ./a.out &lt;&lt;END&gt; hello&gt; hey&gt; ENDhellohey 操作读写位置的函数 三个函数 1234#include &lt;stdio.h&gt;int fseek(FILE *stream, long offset, int whence); //返回值:成功返回0,出错返回-1并设置errnolong ftell(FILE *stream); //返回值:成功返回当前读写位置,出错返回-1并设置errnovoid rewind(FILE *stream); //把读写位置移到文件开头 fseek(FILE *stream, long offset, int whence) offset ：可正可负 负值表示向前(向文件开头的方向)移动,正值表示向后(向文件末尾的方向)移动, 如果向前移动的字节数超过了文件开头则出错返回 如果向后移动的字节数超过了文件末尾,再次写入时将增大文件尺寸,,从原来的文件末尾到fseek 移动之后的读写位置之间的字节都是0. whence ：何时 SEEK_SET：从文件开头移动offset个字节 SEEK_CUR（current）从当前位置移动offset个字节 SEEK_END 从文件末尾移动offset个字节 以字符串位单位的I/O函数 fgets : 从指定的文件中读一行字符到调用者提供的缓冲区中供的缓冲区中。 1char *fgets(char *s, int size, FILE *stream); // s--指向buffer;size--读取长度；stream--原始文件 该函数从stream 所指的文件中读取以’\n’结尾的一行(包括’\n’ 在内)存到缓冲区s中 如果文件中的一行太长,fgets 从文件中读了size-1个字符还没有读到’\n’ 则将size-1个字符和‘\0’添加到buffer，剩下的下一次调用 并且在该行末尾添加一个’\0’ ，组成完整的字符串。 fgets 对于 ‘\n’ 和 ‘\0’ 对于fgets 来说,’\n’是一个特别的字符,而’\0’ 并无任何特别之处 如果读到’\0’ 就当作普通字符读入。 fgets 只适合读文本文件而不适合读二进制文件, fputs : 向指定的文件写入一个字符串,puts向标准输出写入一个字符串。 12int fputs(const char *s, FILE *stream);int puts(const char *s); 缓冲区s中保存的是以’\0’ 结尾的字符串，fputs 将该字符串写入文件stream，但并不写入结尾的’\0’； fputs 并不关心的字符串中的’\n’ 字符,字符串中可以有’\n’也可没有’\n’ puts将字符串s写到标准输出(不包括结尾的’\0’ ),然后自动写一个’\n’ 到标准输出。 以记录为单位的I/O文件 /CSlib/fread_and_fwrite/ fread / fwrite 用于读写记录，这里的记录是指一串固定长度的字节,比如一个int、一个结构体或者一个定长数组。 12345size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE*stream);返回值:读或写的记录数,成功时返回的记录数等于nmemb,出错或读到文件末尾时返回的记录数小于nmemb,也可能返回0 该程序生成的recfile 文件是二进制文件而非文本文件,因为其中不仅保存着字符型数据,还保存着整型数据24和28((在od命令的输出中以八进制显示为030和034) 注意,直接在文件中读写结构体的程序是不可移植的 结果输出不一定相同 因为不同平台的大小端可能不同(因而对整型数据的存储方式不同) ,结构体的填充方式也可能不同(因而同一个结构体所占的字节数可能不同） 格式化的I/O函数 格式化的I/O函数：以特定的格式进行输入和输出 printf and scanf /IO/print/print.c printf 格式化打印到标准输出 关于printf的函数：很多种分类 printf 转换说明的可选项 “%#x ” ：指定输出类型是0x 十六进制 “ %#X ” : 输出大写字符 “-%10d-”： 长度为10，格式化后的内容居左,右边可以留空格。 “ % . d ”：打印输出的%6.4—长度位6，精度位4 “ %hhd ” ：对于整型参数可以指定字长,hh、h 、l 、ll 分别表示char 、short 、long、long long 的字长 “ %p ” : 打印main函数的首地址 “%f ”: double型参数格式化，精度=小数点后6位 “ %e/E ” : 取double型参数格式化为，转化为指数模式 “ %g/G “ : 精度指有效数字，默认是6位有效数字，多余的就抹去 “%%” ： 格式化输出一个 % printf并不知道实际参数的类型，只能按转换说明指出的参数类型从栈帧上取参数， 所以如果实际参数和转换说明的类型不符,结果可能会有些意外。 scanf scanf 从标准输入读字符,按格式化字符串format中的转换说明解释这些字符 转换后赋给后面的参数,后面的参数都是传出参数,因此必须传地址而不能传值。 scanf 用输入的字符去匹配，格式化字符串中的字符和转换说明 如果成功匹配一个转换说明,就给一个参数赋值 或者如果遇到和格式化字符串不匹配的地方就停止。 scanf的转换字符还得注意一点 对于整型参数可以指定字长,有hh 、h、l、ll(也可以写成一个L),含义和printf相同。 但l和L还有一层含义,当转换字符是e、f、g时, 表示赋值参数的类型是float 而非double 这一点跟printf不同,这时前面加上l或L表示double 或long double 型。 scanf 字符转换 scanf(%d, &amp;i); // 传的是地址，不能传值 “%d”：匹配十进制整数(开头可以有负号),赋值参数的类型是int * 。 “% i ”: 匹配整数(开头可以有负号),赋值参数的类型是int * 以0x或0X开头，则匹配十六进制整数 以0开头则匹配八进制整数 “%o , %u, %x”: 匹配无符号八进制、十进制、十六进制整数，赋值参数类型是usigned int * “ %c “ : 匹配一串字符,字符的个数由宽度指定,缺省宽度是1,赋值参数的类型char * 末尾不会添加’\0’ 。 如果输入字符的开头有空白字符,这些空白字符并不被忽略,而是保存到参数中, 要想跳过开头的空白字符,可以在格式化字符串中用一个空格去匹配。 “%s”: 匹配一串非空白字符 从输入字符中的第一个非空白字符开始匹配到下一个空白字符之前,或者匹配到指定的宽度,赋值参数的类型是char *, 莫为自动添加‘\0’ “%e, %f, %g” : 匹配浮点数(开头可以有负号),赋值参数的类型是float * 可以指定double 或long double 的字长。 C标准库的I/O缓存 用户程序调用C标准I/O库函数读写文件或设备， 库函数要通过系统调用把读写请求传给内核 由内核驱动磁盘或设备完成I/O操作 内核写回设备的操作是Flush操作； 库函数是fflush fclose函数在关闭文件之前也会做Flush操作。 分配一个I/O缓冲区以加速读写操作 缓冲区分为三类 printf 标准的输出，分配的是行缓冲； 每次遇到 \n ；换行符，便进行flush操作； 写回内核，输入到设备 数值字符串转换函数 将一串字符中能识别成某种进制的数，转换为int or double 1234#include &lt;stdlib.h&gt;int atoi(const char *nptr); // 把一个字符串开头可以识别成十进制整数的部分转换成int 型,double atof(const char *nptr); // atof 把一个字符串开头可以识别成浮点数的部分转换成double型返回值:转换结果 开头没有可识别的进制数，则返回0 strtol and strtod 能控制识别的进制数（8,10,16） 能区分返回值error and 0 123long int strtol(const char *nptr, char **endptr, int base);double strtod(const char *nptr, char **endptr);返回值:转换结果,出错时设置errno 分配内存函数 在堆空间分配内存的函数 calloc 分配nmemb 个元素的内存空间,每个元素占size 字节 calloc负责把这块内存空间用字节0填充,而malloc 并不负责把分配的内存空间清零。 realloc 候用malloc 或calloc分配的内存空间使用了一段时间之后需要改变它的大小 把原内存空间的指针ptr传给realloc,通过参数size 指定新的大小(字节数) realloc返回新内存空间的首地址,并释放原内存空间。 综合练习日志文件中添加记录 获取当前的系统时间需要调用time(2)函数,返回的结果是一个time_t 类型； 其实就是一个大整数，其值表示从UTC(Coordinated Universal Time)时间1970年1月1日00:00:00(称为UNIX系统的Epoch时间)到当前时刻的秒数。 然后调用localtime(3)将time_t所表示的UTC时间转换为本地时间(我们是+8区,比UTC多8个小时)并转成struct tm 类型 该类型的各数据成员分别表示年月日时分秒 调用sleep(3) 函数可以指定程序睡眠多少秒。 INI and XML files INI文件：是Initialization File的缩写，即初始化文件，系统配置文件所采用的存储格式 文件扩展名：配置文件 . ini 格式：由节，键，值组成 节： [ section ] 键 = 值 ：name = value 注释：注解使用分号表示（;）。在分号后面的文字，直到该行结尾都全部为注解。 12345example： ; exp ini file [port] portname=COM4 port=4 XML文件：同样是一个配置文件的格式 两者区别 xml,对于描述复杂的数据结构非常的方便，缺点相对ini使用麻烦一点。 而且因为它有比较严格的格式审查机制，容错性也不是特别好,在手写时容易出现错误。 抛开配置的功能，作为存储传输数据的手段，xml还有个缺点就是它的处理和存储的效率非常低下，解析速度慢，占用更多的存储空间。 INI ：通常用于对软件的参数进行配置和记录。 优点是使用方便，嵌入程序也容易，几个接口就够了，很容易掌握。 配置文件更小巧，手工配置也更容易。 缺点是它的结构只有2层，对于复杂类型数据描绘就显得比较无力了。 另外ini文件有64kb的大小限制。 转换ini 为xml]]></content>
      <categories>
        <category>LinuxC</category>
        <category>standard lib</category>
      </categories>
      <tags>
        <tag>standard lib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mail]]></title>
    <url>%2F2019%2F03%2F31%2FMail%2F</url>
    <content type="text"><![CDATA[Mail 考虑到以后邮箱的问题，在考虑使用重邮的学生账号 还是谷歌的gmail账号 两个都面临着改用户别名 我总觉得邮箱：就应该简单实用就好。 github github的账号邮箱申请是QQ邮箱 QQ邮箱不能注销 关联了其他的两个邮箱]]></content>
      <categories>
        <category>mail</category>
      </categories>
      <tags>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP32 Feature]]></title>
    <url>%2F2019%2F03%2F30%2FESP32Feature%2F</url>
    <content type="text"><![CDATA[Esp32 Feature基本特性 蓝牙和WiFi的特性 分双核和单核DE模组 淘宝上买的板子估计是自己生产的，不是乐鑫的(以后买板子，先查查正品`是哪些，在进行购买) ESP32-WROOM-32 模组 ESP32-WROOM-32D语音编码、音频流和 MP3 解码 ESP32 硬件特性 其他绘制也可参考 SCH_PCB的审查规则查看 电源和地SCH Check 睡眠电流小于 5 μA，适用于电池供电的可穿戴电子设备。 外部供电电源电压及供电电流是否满足需求（500mA 及以上）。 芯片设计唯一接地的管脚在芯片下方，绘制原理图注意是否有添加并连接至地。 PCB Check 电源输入接口的 ESD 管是否有靠近端口放置。 电源走线进入芯片之前是否有添加 10uF 去耦电容。情况允许，可搭配 0.1uF 电容一起使用。 芯片底部的 Ground PAD 是否有至少通过 9 个地孔(CC2540的就需要)连接到地平面。 射频SCH 是否有预留 π 型匹配网络（推荐优先采用 CLC 结构）用于外部天线的阻抗匹配。 RF 测试点添加的位置是否合适（建议添加在第一个 π 匹配电路之后） PCB RF 走线线宽是否有突变。是否存在分支走线。是否有采用 135°走线或圆弧走线。RF 走线两侧是否有密集地孔进行屏蔽。RF 走线需尽量短。 芯片到天线的 RF 走线是否有过孔，天线需与芯片在同一层。 RF 走线附近不能有高频信号线。RF 上的天线必须远离所有传输高频信号的器件，比如晶振，DDR，一些高频时钟（SDIO_CLK 等）。USB 端口、USB 转串口信号的芯片、UART 信号线（包括走线、过孔、测试点、插针引脚等）都必须尽可能地远离天线。且 UART 信号线做包地处理，周围加地孔屏蔽。 复位 复位功能 睡眠和唤醒​ 通过控制某几个GPIO口的引脚进行控制状态 检测一种状态：BT模式下进行 BT模式下进行​ 为了通过Wi-Fi或BT源唤醒芯片，芯片将在Active、Modem-sleep和Light-sleep之间进行切换，CPU、Wi-Fi、Bluetooth和射频模块均将在预设间隔中唤醒，保证Wi-Fi/蓝牙的正常连接。 Light_sleep Light_sleep 但是esp_sleep.h 的头文件中唤醒模式没有BT DatasheetPin Mode EN : Module-enable signal. Active high. Software can read the values of these five bits from register ”GPIO_STRAPPING”. MTDI – &gt; gpio12 MTDO –&gt; gpio15 GPIO0 首先长按Boot键，同时按 reset键，系统将会进入下载模式，然后 make flash 长按boot键，就是将其拉低。 Download 通过CP2102 USB to TTL ESP32 通过串口进行下载]]></content>
      <categories>
        <category>Esp32</category>
        <category>Feature</category>
      </categories>
      <tags>
        <tag>esp32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Funcation Interface]]></title>
    <url>%2F2019%2F03%2F25%2FFuncationInterface%2F</url>
    <content type="text"><![CDATA[Funcation Interface 我们讲过void *类型 和任何指针类型之间可以相互隐式转换。 函数接口的定义 函数的调用者和函数的实现者之间订立了一个契约 调用函数之前：调用者要为实现者提供某些条件 函数返回时：实现者要对调用者尽到某些义务。 首先靠函数接口来描述 即函数名,参数,返回值,只要函数和参数的名字起得合理 参数和返回值的类型定得准确 函数接口并不能表达函数的全部语义 这时文档就起了重要的补充作用，怎么写Man Page Online man page command line –&gt; man strcpy strcpy and strncpy man page 命令行输入：man strncpy dest: Destination（目的） src: Source(源) n : 看下面的文档 注意dest的空间一定要足够大 否则：发生越界 像buf 这种由调用者分配并传给函数读或写的一段内存通常称为缓冲区(Buffer) 缓冲区写越界的错误称为缓冲区溢出(Buffer Overflow) Bug : 数组的长度必须固定，所以strncp容易造成越界； char buf[n+1] = {} ; // 虽然保证buf 是以 ‘\n’结尾，但是仍然不够灵活 动态内存分配 malloc and free C的标准函数，都是可以直接用的，对吧。（在C中定义好了） malloc malloc 12void *malloc(size_t size); /* void *类型 和任何指针类型之间可以相互隐式转换。 */ 对每次的调用malloc，进行判断函数调用是成功，还是失败。 1234if (p == NULL) &#123; printf("out of memory\n"); /* 对每次的调用malloc，判断函数成功/失败的返回值 */ exit(1); &#125; free 每一次调用malloc，都需要free，对指针内存和地址进行释放 内存泄漏（Memory leak）:分配完了又不释放,就会慢慢耗尽系统内存 内存泄漏的Bug很难找到,因为它不会像访问越界一样导致程序运行错误 特殊情况 free : 只要不是释放野指针就没问题 12malloc(0); return 非NULL的指针free(NULL); 合法的 free 产生错误 123malloc(p);free(p);free(p); //第二次释放的时候，找不到指针，到这里会报错 正确的free过程 123free(p-&gt;msg);free(p);p = NULL; 传入参数和传出参数 parameter code 传入参数：把指针所指向的数据传给函数使用； 传出参数：由函数填充指针所指的内存空间，传回给调用者使用 如果传入参数是NULL表示取缺省值,也可能表示不做特别处理。 如果传出参数是NULL 表示调用者不需要传出值,例如time(2) 的参数。 函数123void func(const unit_t *p) //传入参数void func(unit_t *p) //传出参数void func(unit_t *p); //Value-result参数示例: 两层指针 TwoPointer 两层指针的内存分配 两层指针和单层指针 两层指针只能作为传出参数，两种情况 传出的指针指向静态内存,或者指向已分配的动态内存； 在函数中动态分配内存，然后传出的指针指向这块内存空间,这种情况下调用者应该在使用内存之后调用释放内存的函数。 12void alloc_unit(unit_t **pp); //分配内存void free_unit(unit_t *p); //释放内存 参数分配内存则需要两层指针 返回值是指针的情况返回指向已分配内存的指针示例 FuncationInterface / ReturnPointer unit_t *func(void) 动态分配内存并返回指针 FuncationInterface / ReturnPointer / Return 12unit *alloc_unit(void);void free_unit(unit *p); 通过返回值分配内存就只需要一层返回指针； 参数分配内存则需要两层指针 回调函数 利用函数指针的方法进行调用]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Funcation Interface</category>
      </categories>
      <tags>
        <tag>Funcation Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Piano]]></title>
    <url>%2F2019%2F03%2F25%2FPiano%2F</url>
    <content type="text"><![CDATA[Piano 电子琴项目VS + QT 实现一个钢琴的输入界面 MPU6050 读取每一次晃动的最大值，并进行次数的统计]]></content>
      <categories>
        <category>CBIB ITEM</category>
        <category>Piano</category>
      </categories>
      <tags>
        <tag>Piano</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里AI安全讲座]]></title>
    <url>%2F2019%2F03%2F22%2FWork%2F</url>
    <content type="text"><![CDATA[阿里AI安全讲座 工作和学习的建议 主讲人：张荣 个人的工作经历 第一阶段的工作：快速成长 跳出生活的舒适区，刚毕业对生活的节奏很新鲜，工资翻倍，小生活滋润 需要有鞭策，寻找新视野，更上工作的步伐，为后续的转行做准备 第二阶段的工作：拒绝吃老本行 跳出工作的舒适区，适应工作环境和工作节奏之后的状态 学习新的知识，寻找新的方向和平台 第三阶段的工作：止跌回升 找到大平台，资源； 为自己的方向而打拼 用计算机的思维去思考问题 第四阶段的工作：行业内寻找新方向 在行业中寻找新的方向 选择 行业～进入快速发展的行业 企业～进入前途远大的企业 业务～进入成长性的业务 老板～跟上有雄心壮志的老板 行业 科技发展的2个主线：能量和信息 5G : 基础设施，超高速传输，广覆盖 IoT：万物互联 感知 – 认知 企业 巨头：资源过剩，平台大，优秀的人多，不容易脱颖而出 二线：发展的机会欠缺，不利于成长 超新星：国家和政府扶持，目前最需要的 初创：不关注个人成长，只是让你完成任务 企业面试看中什么？ 校招和社招不同 校招～为未来投资，面向未来，技能总会过时 阿里校招的需求 基础品质 完整的项目经历，项目落地的经历 基础知识 技术文档：英语写作能力，口头交流能力 编程基础 学生到职场人 做决定和承担的能力 有自己的想法和idea 自我驱动和发展 公司需要的能力 从公司的规模来看： 完成 – 完善 – 对外推广 从公司的结构 网状：上下连接，生产实现，推销 Leader：不应该是团队的技术核心，应该是一个连接者，组建一个由长板构成的团队 面试和笔试 基础必须好： 数据结构题目的刷人，时间复杂度，空间复杂度是多少 编程问题：基础能力必须牢固 想面试阿里：用一个钉钉客户端，里面有阿里邮箱 AI 安全技术相关]]></content>
      <categories>
        <category>work</category>
        <category>AI cathedra</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pointer]]></title>
    <url>%2F2019%2F03%2F22%2FPointer%2F</url>
    <content type="text"><![CDATA[Pointer (指针)指针的基本操作理解指针 堆栈和队列 堆栈有栈顶指针，队列有头指针和尾指针 这种指针本质：是一个整数，是数组的索引 指针概念 把一个变量所在的内存单元的地址 保存在另外一个内存单元 此内存单元 称为指针 12345int i;int *pi = &amp;i; /*全局变量的赋值：右边必须是常量表达式*/ /* 定义一个指向int型的指针变量pi,并用i的地址来初始化pi */char c;char *pc = &amp;c; /*32位的虚拟机，他们的内存单元都是4 byte*/ 指针变量 pi 和pc 指向不同类型的指针变量，但内存单元都占4 byte； 32 bit 的平台：占4byte； 64 bit 的平台：占8byte； 根据指针知找到变量 指针的关系 &amp;运算符的操作数必须是左值,因为只有左值（变量）才表示一个内存单元,才会有地址, 表达式E可以做左值（变量），*&amp;E = E E是指针类型，&amp;*E = E 123int *p; /*定义指针类型p*/p = &amp;i; /*此时p保存的是i的地址*/int j = *p; /*此时 *p = *&amp;i; 也就是i的值*/ 指针间的赋值 12int *ptri;ptri = pi; /*是把变量pi所保存的地址值赋给变量ptri*/ 保证ptri 和 pi是同一种类型，否则需要强制转化 指针很容易指向错误的地址，访问这样的地址可能导致段错误 空指针和野指针 定义局部类型的指针变量，却没有赋值 – 野指针(Unbound Pointer)（局部变量定义却不赋值） 避免野指针，定义指针变量因该赋值，货值初始化NULL 123int *p = NULL;#define NULL ((void *)0) /*将地址0转换为指针类型*//*任何对地址0的访问都会立刻产生段错误*/ void * 类型 void *指针与其它类型的指针之间可以隐式转换,而不必用类型转换运算符。 只能定义void *指针，而不能定义void 型的变量。 因为void *指针和别的指针一样都占4个字节，void型的变量就不清楚了 void *指针不能直接Dereference,而必须先转换成别的类型的指针再做Dereference。 指针类型的参数和返回值12345int *swap(int *px, int *py) /*指针类型的形参*/&#123; ... return px; /*如果需要指针类型的返回值，需要定义指针类型的函数*/&#125; 指针和数组 关系 地址之间的关系： int 型元素占4个字节，pa++使pa指向的地址加4，不是加1 指针与变量之间的关系 指针保存变量的地址 指针和数组的关系 右值：在赋值符号“ = ”，右边的常量表达式，相当于要存储的值 数组名做右值使用时,自动转换成指向数组首元素的指针。 字符串字面值还有一点和数组名类似,做右值使用时自动转换成指向首元素的指针。 12a[2] 能取到数组的第三个元素，相当于 *（a+2）*(pa+2) --&gt; pa[2]; //做右值的时候自动转化为指针 指针指向数组 a[0] 的首地址 123int a[10];int *pa = &amp;a[0]; /*后缀运算符优先级高于单目运算符*/pa++; 由于数组a做右值使用时和 &amp;a[0]是一样的 表达式pa[-1] 是合法的,它和a[0] 表示同一个元素。 12int *pa = &amp;a[0]; 等价于 ：int *pa = a; 指针的比较运算 只有指向同一数组的指针，作比较才有意义 指针的比较比的是地址 指针的相减运算 相减：表示两个指针间，相差的元素个数 12pa - a = ?pa - 1 = a; pa - a = 1 函数的参数是数组时，等价于参数是指针的形式 12void func(int a[10])等价于 ： void func(int *a) 指针与const限定符 const : 将不允许修改的内存单元保护起来； 看 const 离哪个比较近，则保护的便是它 指向const int 型的指针 代码方式 12const int *a;or int const *a; /* 将 const 后面的(*a)看成一个整体，这个整体不允许修改的 */ 代表含义 a 是一个指向const int 型的指针； a 指向的内存单元是不能修改的。（a 代表地址的内存单元） （*a）++ 不允许 （值）；a++允许（地址） 只能读指针a 指向的元素 指向int 型的 const 指针 代码方式： 1int * const a; 代表含义 *a是可以改写的,内容的值可以修改 a不允许改写，地址不能修改 指向const int 型的 const 指针 代码方式： 12const int * const a;or int const * const a; 代表含义 因此*a 和a都不允许改写。 结论 指向非const 变量的指针或者非const 变量的地址可以传给指向const 变量的指针,编译器可以做隐式类型转换,例如: 12char c = 'a';const char *pc = &amp;c; // c 的值是不会改变的 const 使用 字符串字面值通常分配在.rodata段 .rodata：不允许改写，但编译器不会报错，在运行时会出现段错误。 指针与结构体 定义结构体类型 typedef：相当于一个命名，将struct unit 命名为了unit 好处：在定义struct unit 类型的变量时：可以只写unit 123456struct unit&#123; --&gt; typedef struct&#123; char c; --&gt; char c; int num; --&gt; int num;&#125;; --&gt; &#125;unit;struct unit u; --&gt; unit u;struct unit *p = &amp;u; --&gt; unit *p = &amp;u 指针访问结构体元素 12way1 ： (*p).c ，(*p).num;way2 : p-&gt;c , p-&gt;num 指向指针的指针与指针数组指向指针变量的指针 指针可以指向基本类型，也可以指向复合类型，因此也可以指向另外的指针变量 代码类型 12345char c;char *pc = &amp;c;int i;int *pi = &amp;i; // pi 保存的是 i 的地址int **ppi = &amp;pi; // *ppi = &amp;pi: ppi保存pi的地址; *ppi保存的是i的地址 如何进行参数的传递呢？ 1234void insert(int **ppi, int value); /* 形式参数 */int *pi = null;insert(&amp;pi, 5); /* 指向指针的指针，使用和指向int 型的指针类似，换的只不过是类型而已 */ 指针数组 指针数组的定义 12int a[10]; --&gt; int *a[10];int *pa = &amp;a; --&gt; int **pa = &amp;a[0]; //指向指针数组的首元素 &amp;a[0] 表示数组a的首元素的首地址；而&amp;a 表示数组a 的首地址； 显然这两个地址的数值相同，但这两个表达式的类型是两种不同的指针类型,前者的类型是int ,而后者的类型是int ( )[10] 则pa[0] 和a[0]取的是同一个元素; 唯一比原来复杂的地方在于这个元素是一个int * 指针，不是基本类型 main的标准原型 [main code] main的原型 1int main(int argc, char *argv[]); argc : 命令行参数的个数 而argv 是一个指向指针的指针,为什么不是指针数组呢? 函数原型中的[ ]表示指针而不表示数组，等价于char **argv 那为什么要写成char *argv[]而不写成char **argv 呢？ argv 不是指向单个指针,而是指向一个指针数组的首元素。 数组中每个元素都是char *指针,指向一个命令行参数字符串。 main 原型的代码结构 指向数组的指针与多维数组指向数组的指针 代码定义： 12345int *a[10] --&gt; int (*a)[10]; /*********************Equivalent to:**********************/typedef int *t; --&gt; typedef int t[10];t a[10]; --&gt; t *a;// a是一个数组，元素的类型是int *型 可以认为 后缀运算符 [ ]，优先级高于 单目运算符 * int a[10]：a和[]先结合，a[10]表示数组指针，指向 int 类型， 数组元素是10个 int *型 的数 int (a)[10]：a和 先结合，a表示指针，指向含有10 个int 型的数组 指针数组使用 指针数组 和 指向数组的指针 123指针数组： --&gt; 指向数组的指针int *a[10] --&gt; int a[10]; int (*pa)[10] = &amp;a; *pa：表示pa指向的数组a； 12a[0] --&gt; (*pa)[0]; (*pa) --&gt; pa[0]; 数组做右值的时候，自动转化为首元素指针所以引入二维数组： (*pa)[0] == pa[0][0] 多维数组 通过指向数组的指针，表示二维数组； 实现数组的自增和赋值作用 多维数组的引用 123int a[5][10]; --&gt; int a[10];int (*pa)[10] = &amp;a[0] --&gt; int (*pa)[10] = &amp;a;//则pa[0] 和a[0]取的是同一个元素 多维数组的优势 pa 比a用起来更灵活，数组名不支持赋值、自增等运算； 而指针可以支持，pa++ 使 pa 跳过二维数组的一行(40个字节)，指向a[1] 的首地址。 函数类型和函数指针类型定义 指针变量：内存单元存放一个地址值； 函数指针：存放的就是函数的入口地址(位于.text 段) 123void func(const char *p)&#123; --&gt; void (*func)(const char *p)&#123; ...函数 --&gt; ... 函数指针&#125; --&gt; &#125; 而函数类型和数组类型类似,做右值使用时，自动转换成函数指针类型，所以可以直接赋值 12345678void say_hello(const char *str)&#123; printf("hello %s\n", str)&#125;int main(void)&#123; void (*func)(const char *) = say_hello; --&gt; void (*func)(const char *) = &amp;say_hello; f("Guys"); --&gt; (*f)("Guys") or say_hello("Guys") return 0;&#125; 函数调用运算符() 要求操作数是函数指针,所以f(“Guys”) 是最直接的写法; 而say_hello(“Guys”)或(*f)(“Guys”)则是把函数类型自动转换成函数指针然后做函数调用。 高级指针 指向指针的指针： 间接访问：传递的都是变量的地址； 每一层间接访问，就对应一层地址传递 高级声明 优先级的高低 1最低优先级：* &lt; () or [] 函数 type f ( ) : 这个()是函数的调用操作符;type 是返回值的类型 123int *f(); // 首先结合 f()-函数；再结合 * -- 函数返回值是指向int型的指针int (*f)(); // 首先结合 (*f)-聚合为一个指针；再结合()--(*f)()是一个函数指针；函数返回整形值int *(*f)(); // (*f)()指针函数； [(*f)()]组合 * 后称为一个指针，指向int型 数组 type g[ ] 123int f[]; // 数组int *f[]; // 首先结合 f[] 成为数组，元素类型是指向 int 型的指针；int (*f[])(); // f[]是一个数组；数组元素类型是函数指针；返回值是整形值 函数指针 — 回调函数的实际应用 函数指针的初始化 1int (*pf)(int value) = &amp;f; // 函数指针的定义和初始化，f也是函数； 做左值的时候：等价的 &amp;f –&gt; f 回调函数的应用 功能函数能执行不同类型的工作，或者执行只能右函数调用者定义的工作； 许多窗口系统，使用回调函数连接多个动作；]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Pointer</category>
      </categories>
      <tags>
        <tag>pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile]]></title>
    <url>%2F2019%2F03%2F21%2FMakefiles%2F</url>
    <content type="text"><![CDATA[Makefile 基础 Link code – Makefiles 注释是 “#” Makefile 基本规则Makefile 例子 12345678main: main.o stack.o maze.o gcc main.o stack.o maze.o -o mainmain.o: main.c main.h stack.h maze.h gcc -c main.cstack.o: stack.c stack.h main.h gcc -c stack.cmaze.o: maze.c maze.h main.h gcc -c maze.c Makefile 由一组规则 rule组成 1234target ... : prerequisites ... command1 command2 ... 目标和条件之间的关系是：欲更新目标，必须首先更新它的所有条件; 所有条件中只要有一个条件被更新了，目标也必须随之被更新。 所谓“更新”就是执行一遍规则中的命令列表；命令列表中的每条命令必须以一个Tab开头；（注意不能是空格） 对于Makefile中的每个以Tab开头的命令,make 会创建一个Shell进程去执行它。 make 编译 make 会自动选择那些受影响的源文件重新编译，不受影响的源文件则不重新编译。 make clean123456clean: @echo "cleanning project" -rm main *.o @echo "clean completed".PHONY: clean /* 声明clean为一个伪目标 */ clean 目标不依赖于任何条件,并且执行它的命令列表不会生成 clean文件 rm and mkdir 命令前面加 “ - ” 即使这条命令出错，也会继续执行后面的命令 因为rm 要删除的文件可能不存在,mkdir 要创建的目录可能已存在 在命令前加 @ 加了命令在前面，不显示命令本身 而只显示它的结果; .PHONY: clean 声明clean为一个伪目标 为了将clean 当做特殊的名字使用 类似于clean的目标名字​ Makefile 隐含规则和模式规则​ 变量 符号 作用 “ := ” y := $(x) bar make 遇到变量定义的时候：立即展开 nullstring :=space := $(nullstring) # end of the line 为了定义变量的值为空格；注释前面是有空格 “ ?= ” foo ?= $(bar) 相当于 “ = ”，定义foo的值为$(bar) “ += ” 保持了“ := ”的特性 特殊变量 可以减少书写错误 特殊变量：替代makefile中的规则，简写 特殊变量的使用 “ $? “的使用 用于生成静态、共享库 123libsome.a: foo.o bar.o lose.o win.o ar r libsome.a $? ranlib libsome.a 变量的缺省值 自动处理头文件的依赖关系 省去了手动敲命令 命令12$ gcc -M main.c /* 找出所有的依赖头文件 */$ gcc -MM main.c /* 排除系统头文件 */ Make命令选项想通过命令行传参数或者缺省参数设置 前提条件： 需要通过隐式规则编写Makefile 将gcc编译省去 在Makefile 文件理添加缺省命令 123456789101112all: main # 按照惯例,用all 做缺省目标。main: main.o gcc $^ -o $@main.o: main.cCFLAGS = -gclean: @echo "cleanning project" -rm main *.o @echo "cleanning compile".PHONY:clean 通过命令行传递缺省参数 1make CFLAGS=-g /*在编译中增加调试选项*/ Makefile 文件 从主目录到子目录中都存在 总的Makefile ： make -C 执行每个子目录下的Makefile 1234$ make -n /*只打印要执行的命令，而不是直接执行；检查makefile是否正确*/$ make -C testmake /* 切换到目录testmake下，编译 */$ make -C /*执行每个子目录下的Makefile*/$ make CFLAGS=-g /*在编译中增加调试选项*/ GNU make GNU Make 编写Makefile文件进行大项目的管理； 概念Why Use 明确搜索位置 减少项目的编译时间 只针对改动的项目进行编译 从很多目标文件生成一个程序包 (Library)比从一个单一的大目标文件生成要好的多 使用 gcc/ld (一个 GNU C 编译／连接器) 把一个程序包连接到一个程序时； 在连接的过程中，它将不去连接没有使用到的部分。 程序是很模块化的，文件之间的共享部分被减到最少 When Use 如果你需要开发一个相当大的项目，在开始前，应该考虑一下你将如何实现它，并且生成几个文件（用适当的名字）来放你的代码。 当然，在你的项目开发的过程中，你可以建立新的文件，但如果你这么做的话，说明你可能改变了当初的想法，你应该想想是否需要对整体结构也进行相应的调整。 How Use 不要用一个 header 文件指向多个源码文件; 如果可以的话，完全可以用超过一个的 header 文件来指向同一个源码文件。 不要在多个 header 文件中重复定义信息。 关键字“static”：要防止一个符号在它被定义的源文件以外被看到 header 不要在 header 档里定义变量，只能用作声明变量和函数。 你只需要在 header 档里声明，然后在适当的Ｃ源码文件（只在 #include header）里定义一次。 声明和定义 声明：告诉编译器其所声明的符号应该存在，并且要有所指定的类型。但是，它并不会使编译器分配贮存空间。 定义：要求编译器分配贮存空间。 防止出现重复声明 1234#ifndef FILENAME_H#define FILENAME_H...#endif GUN Make Tools GNU Make 的主要工作是读进一个文本文件–makefile 。 搜索其中的Target and dependencies； 检查磁盘上的文件和目标文件的时间戳； 进而进行目标文件的更新。 Makefile 变量 如何编写，引用Makefile变量 和变量的赋值规则相似 变量：用大写的字母 引用：通过 “$( CC )” “$(CFLAGS)” 123OBJS = main.o #变量 = 变量的值CC = gccCFLAGS = -Wall -O -g #-Wall 打印所有的警告信息； -O 编译器的优化； -g gdb调试的编译 三个特殊的变量 “$@” ：扩展成当前规则的目的文件名 “$&lt;” : 扩展成依靠列表中的第一个依靠文件 “$^” : 扩展成整个依靠的列表（除掉了里面所有重复的文件名） Makefile 文件编写 1234567891011121314151617# 编译条件OBJS = main.o CC = gccCFLAGS = -Wall -O -g# 目标文件all: main # 按照惯例,用all 做缺省目标。# 编译条件main : $(OBJS) $(CC) $^ -o $@main.o : main.c main.h $(CC) $(CFLAGS) -c $&lt; -o $@ # 类似于 gcc -c main.c# cleanclean: @echo "cleanning project" -rm main *.o @echo "cleanning compile".PHONY:clean 隐含规则 Rule 变量CC 做为编译器 传递变量 CFLAGS 给 C 编译器（C++ 编译器用 CXXFLAGS ） CPPFLAGS （ C 预处理器旗标） TARGET_ARCH （现在不用考虑这个） 加入旗标 ‘-c’ ，后面跟变量 $&lt; （第一个依靠名），然后是旗标 ‘-o’ 跟变量 $@ （目的文件名） 1$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c $&lt; -o $@ 假想可执行文件 为了通过一个Makefile生成多个可执行文件 12在Makefile开始时输入 all: main mymain 多目录下的Makefile 文件编写在文件夹下包含一个Makefile 文件目录 子目录下的Makefile 编译该子目录下的文件，并保存到一个函数库中，再将该库文件复制到上一级主目录当中。 12345678910111213141516171819202122# 编译条件CC = gccINCLUDE = -I. # 子目录下的Makefile文件编译CFLAGS = -g -Wall# 要使用Tab键: 将文件定义为lib.a库array_malloc_queue = array_malloc_queue.a$(array_malloc_queue): $(array_malloc_queue)(array_malloc_queue.o) (cp $(array_malloc_queue) ../) (cp $(linkQueueInterface) ../array_queue_interface/) # 复制到不同目录################# .o 文件编译################array_malloc_queue.o: array_malloc_queue.c array_queue_interface.h $(CC) $(CFLAGS) -c $(INCLUDE) $&lt; -o $@clean: @echo "cleaning project" -rm $(array_malloc_queue) -rm *.o @echo "cleaning complie".PHONY: clean 调用函数的目录 Makefile 123456789101112131415161718192021222324252627#Objsall: array_queue############编译条件################CC = gccCFLAGS = -g -WallINCLUDE = -I. -Iarray # 不同目录下文件array_malloc_queue = array_malloc_queue.a # 子目录下最后生成的文件名################# OBjs目标文件的编译################array_queue: main.o $(array_malloc_queue) $(CC) $^ -o $@################# 目标.o 文件的编译################$(array_malloc_queue): # 子目录下Make编译文件 (cd array;$(MAKE))# 不用加array_queue_interface.h文件，我们在生成目标文件时进行链接main.o: main.c $(CC) $(CFLAGS) -c $(INCLUDE) $&lt; -o $@#cleanclean: @echo "cleaning project" -rm array_queue $(array_malloc_queue) -rm *.o @echo "cleaning complie".PHONY: clean 执行编译过程 1$ make // 在调用函数的目录下执行 123$ make clean // 在主目录下执行，不能clean子目录的；$ cd array // 进入子目录；$ make clean // 子目录下的clean 问题： 每次子节点目录下文件的改变，需要进入目录去修改； 并且重新生成]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Preprocessing]]></title>
    <url>%2F2019%2F03%2F21%2FPretreatment%2F</url>
    <content type="text"><![CDATA[Preprocessing预处理步骤 经过以下步骤之后，把空白字符丢掉，把Token交给C编译器做语法解析 Token：通过分隔符将字符串，分成一个个的子块 换行符 Windows平台的文本文件用 \r \n 做行分隔符，而Linux平台用 \n 做行分隔符； C编译器要能处理差别 把用 “ \ ” 字符续行的多行代码连成一行 把注释都替换为一个空格 Token 然后预处理器把逻辑代码行划分成Token和空白字符, 这时的Token称为预处理Token：包括标识符、整数常量、浮点数常量、字符常量、字符串、运算符和其它符号 include and define 在Token过程中，遇到 #include 预处理指示：则把相应的源文件包含进来 宏定义：。如果遇到宏定义则做宏展开。 宏定义 较大的项目都会用大量的宏定义来组织代码，宏定义很常用。 看起来宏展开就是做个替换（展开替换）而已,其实里面有比较复杂的规则, 函数式宏定义 变量式宏定义（Object-like Macro） 12#define N 20#define STR "hello, world" 函数式宏定义 12#define MAX(a, b) ((a)&gt;(b)?(a):(b)) // 不加括号，展开后会报优先级错误k = MAX(i&amp;0x0f, j&amp;0x0f) 函数式宏定义不建议使用 内联函数 关键词：inline 用于定义内联函数 inline funcation inline关键字告诉编译器,这个函数的调用要尽可能快,可以当普通的函数调用实现,也可以用宏展开的办法实现。 “# and ## 运算符”和可变参数 # 运算符用于创建字符串，运算符后面应该跟一个形参（中间可能有Tab） 1#define STR #s //#的用法 ## 运算符将两个字符连接在一起 宏展开时前后两个#号被这个运算符连接在一起。 而根据定义## 运算符用于连接前后两个预处理Token,不能出现在宏定义的开头或末尾,所以会报错。 条件预处理提示Header Guard1234#ifndef HEADER_FILENAME //如果没有定义HEADER_FILENAME，则执行后面的语句#define HEADER_FILENAME/* body of header */#endif #ifdef 或 #if 可以嵌套使用,但预处理指示通常都顶头写不缩进,为了区分嵌套的层次 预处理过程 先处理defined运算符 12#if defined x 相当于 #ifdef x#if !defined x 相当于 #ifndef x 展开所有的宏定义 把没有定义的宏换成 0 把得到的表达式 ，像C表达式一样求值 其他预处理特性 _ FILE _ ：展开为当前源文件的文件名,是一个字符串, _ LINE _ ：展开为当前代码行的行号,是一个整数。 _ func _ : 特殊的标识符，打印所在函数的名字 assert.h 实现 #undef assert 确保前面对assert的定义 然后分另种情况：]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Preprocessing</category>
      </categories>
      <tags>
        <tag>Pretreatment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Link lib]]></title>
    <url>%2F2019%2F03%2F19%2FLinklib%2F</url>
    <content type="text"><![CDATA[Link lib Code link – Link 多目标文件链接 编译查看命令 12$ gcc main.c -o main //编译可执行文件$ readelf -a main //查看符号表 global and local 目的： 能查看到跟函数的段定义 Data Segment 后面的一些Segment，主要是调试信息 为什么要声明函数 为什么编译器在处理函数，调用代码时需要知道函数原型? 因为必须知道参数的类型和个数以及返回值的类型，才知道生成什么样的指令。 定义和声明 凡是被多次声明的变量或函数： 必须有且只有一个声明是定义 如果有多个定义，或者一个定义都没有,链接器就无法完成链接。 变量和函数的声明不同 函数的声明：extern，可有可无 变量的声明：extern，必须要有 extern int top extern 和 static 直接包含 .c 文件 — 直接包含// #include “stack.cpp” ，错误的想法 12345#include &lt;stdio.h&gt;extern void push(char);extern char pop(void);extern int is_empty(void); extern : 表示关键字具有 External Linkage 链接之后是同一个GLOBAL符号,代表同一个地址。 static ： 表示一个Internal Linkage的属性 有些模块不希望被外界访问到，声明为内部的 头文件 .h 将变量和函数的声明放在一个 .h 的文件中 在每次调用函数的时候，只需要包含 . h 的头文件； 不需要在函数中对每一个函数进行声明 预处理关键词 1234#ifndef STACK_H /* 预处理的关键词 */ if not define STACK_H, so define STACK_H; if have define STACK_H, it is NULL.#define STACK_H...#endif #include &lt;&gt; and #inlclude “” &lt;&gt; ：gcc编译的时候首先查找 -I 选项指定的目录，然后查找系统的头文件目录(/usr/include) “ ”：gcc首先查找包含头文件的.c 文件所在的目录，然后查找 - I 选项指定的目录，然后查找系统的头文件目录。 1gcc -c main.c -Istack //用-I选项告诉gcc 头文件要到子目录stack里找;stack是一个子目录 直接包含 .c 文件 – – 错误的 为什么不在 main.c 中直接包含 stack.c 文件？？ 假如又有一个foo.c 也要使用stack.c这个模块。如果在foo.c 里面也包含头文件#include “stack.c” 就相当于push 、pop 、is_empty 这三个函数在main.c和foo.c 中都有定义，那么main.c和foo.c 就不能链接在一起了。 如果采用包含头文件的办法,那么这三个函数只在stack.c中定义了一次,最后可以把main.c、stack.c、foo.c 链接在一起。 头文件中的函数和变量声明一定不能是定义 如果头文件中出现变量或函数定义，这个头文件又被多个.c 文件包含,那么这些.c 文件就不能链接在一起了。 定义声明的详细规则 有相应的作用域和作用范围 三个关键字 Storage Class 静态库 将一组代码编译成一个库 链接器只会取出静态库中：有用的那部分代码。 代码结构 代码目录的区别：编译的时候需要指定目录 便以为目标文件 12$ gcc -c stack/stack.c stack/push.c stack/pop.c stack/is_empty.c// 生成 .o 文件 打包成静态库 库文件命名：libxxx; 静态库 ： .a为后缀 12$ ar rs libstack.a stack.o push.o pop.o is_empty.oar: creating libstack.a 链接主函数 main.c 和 libstack.a -L 选项告诉编译器去哪里找需要的库文件：-L . 表示在当前目录找 -lstack ：告诉编译器链接 libstack库 -Istack：告诉编译器寻找头文件 1$ gcc main.c -L. -lstack -Istack -o main 查看编译器会查询的目录 1$ gcc -print-search-dirs 共享库编译，链接，运行 编译 12$ gcc -c -fPIC stack/stack.c stack/push.c stack/pop.cstack/is_empty.c // -f 编译选项；PIC 是其中一种 生成共享库 使用了PIC：共享库的各段加载地址没有定死，可以加载到任意位置 12$ gcc -shared -o libstack.so stack.o push.o pop.o is_empty.o$ objdump -dS libstack.so //反汇编查看共享库 链接库 1$ gcc main.c -g -L. -lstack -Istack -o main 运行出错 12$ ./main // 运行的时候：找不到动态链接库 libstack.so??$ ldd main //ldd查看main函数依赖哪些共享库 添加动态库的路径 pwd : 得到 .so 的绝对路径 vi etc/ld.so.conf ：每个路径一行，添加 sudo ldconfig -v 共享库的命名 按照共享库的命名惯例,每个共享库有三个文件名:real name、soname和linker name。 指定库的名字 1$ gcc -shared -Wl,-soname,libstack.so.1 -o libstack.so.1.0 stack.o push.o pop.o is_empty.o 虚拟内存管理查看命令12345$ ps //查看当前终端下的进程// bash 进程的 id 是 3279$ cat /proc/3279/maps //查看它的虚拟空间地址// proc 是内核虚拟出来的文件系统// 当前系统中运行的每个进程在/proc 下都有一个子目录,目录名就是进程的id 进程地址空间 进程空间是独立的：每个进程都有各自的VA 和 PA 系统中可分配的内存总量 = 物理内存的大小 + 交换设备的大小]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linklib</category>
      </categories>
      <tags>
        <tag>Linklib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Assembly And C]]></title>
    <url>%2F2019%2F03%2F18%2FComplationAndC%2F</url>
    <content type="text"><![CDATA[Assembly And C汇编代码生成C和汇编穿插显示12gcc -g main.c -o main -Wall // 生成可执行文件.outobjdump -dS main // 把C代码和汇编代码穿插起来显示 只生成汇编1gcc -S main.c //只生成汇编代码main.s,而不生成二进制的目标文件。 汇编调试12345(gdb) disassemble //可以反汇编当前函数或者指定的函数(gdb) si //step 命令可以一行代码一行代码地单步调试,而这里用到的si命令可以一条指令一条指令地单步调试。(gdb) info registers //可以显示所有寄存器的当前值。(gdb) p $esp //打印esp寄存器的值,// 在上例中esp 寄存器的值是0xbff1c3f4,所以x/20 $esp 命令查看内存中从0xbff1c3f4地址开始的20个32位数。 数据的存储 在执行程序时,操作系统为进程分配一块栈空间来存储函数栈帧 esp 寄存器总是指向栈顶，ebp指向栈底 esp 随着压栈和出栈操作随时变化，ebp保持不变 有高地址想低地址增长 函数的参数和局部变量都是通过ebp 的值加上一个偏移量来访问的 程序入口 -o ：作用 –&gt; 只是为了取名字，而不是其他的作用 编译的作用：翻译高级语言为可执行的二进制语言。 汇编程序入口函数：_start；C程序的入口是：main() 汇编函数编译 12$ as hello.s -o hello.o //翻译为汇编代码$ ld hello.o -o hello //ld进行链接库 C程序的编译 123$ gcc -S main.c -o main.s //生成汇编代码$ gcc -c main.s -o main.o //生成目标文件 $ gcc main.o -o main //生成可执行文件 汇编代码： 可以直接命名为 xxx.s ；进行编写 通过as进行编译，ld进行链接。 可以通过 xxx.c 生成 通过 gcc -S 生成 .s汇编代码 C程序链接库的过程 链接和显示 12$ gcc -v main.c -o main //了解详细的编译过程$ objdump -d main //通过反汇编查看各目标文件所定义的符号 C链接的过程 变量的存储布局 查看命令 12$ gcc -g main.c -o main // gdb 调试文件生成$ readelf -a main //查看符号表 global and local 关键字修饰变量 通过一些关键字修饰变量：const 、static、register const 修饰的变量 全局的变量 GLOBAL 变量只读，不可修改 const 变量在定义时必须初始化。因为只有初始化时才有机会给它一个值。 一旦定义之后就不能再改写了,也就是不能再赋值了。 static 修饰的变量 static 修饰的变量，LOCAL LOCAL 的符号只能在某一个目标文件中定义和使用,而不能定义在一个目标文件中却在另一个目标文件中使用。 标识符的作用域（Scope） 关键字：时用来修饰标识符和变量的。 用来定义他们的作用范围 标识符：作用域适合于所有的标识符，而不仅仅是变量。 命名空间 （Name Space）的重名标识符 对于重名标识符，内层作用域的标识符将覆盖外层作用域的标识符。 标识符的链接属性 Linkage 外部链接（External Linkage） 标识符在任意程序文件中即使声明多次也都代表同一个变量或函数,则这个标识符具有External Linkage。 具有External Linkage的标识符编译后在符号表中是GLOBAL的符号。 内部链接（Internal Linkage） 如果一个标识符在某个程序文件中即使声明多次也都代表同一个变量或函数,则这个标识符具有Internal Linkage。 具有Internal Linkage的标识符编译后在符号表中是LOCAL的符号 无链接(No Linkage)。 除以上情况之外的标识符都属于No Linkage的 例如函数的局部变量，以及不表示变量和函数的其它标识符。 存储类型修饰符–关键字（Storage Class Specifier） typedef ，static，extern 修饰一个变量的声明 结构体和联合体存储 栈：是从高地址向低地址增长的； 结构体成员：从低地址向高地址排列，这一点和数组类似。但有一点和数组不同，结构体的各成员并不是一个紧挨一个排列的，中间有空隙，称为填充。 C和内联汇编 内联汇编：为了提高Ｃ的执行效率。因为Ｃ的代码是由编译器进行翻译的。 内联方式 内联格式 1_asm_(assembler code) C中的内联汇编，需要和Ｃ的变量建立关联 12345__asm__(assembler template : output operands /* optional */ : input operands /* optional */ : list of clobbered registers /* optional */); Volatile 限定符 编译器优化对寄存器代码产生的影响 在为调试而编译时不要指定优化选项,否则可能无法一步步跟踪源代码的执行过程。 编译器优化 指令形式 12gcc main.c -g -O -o main // -o 对生成的文件进行命名； // -O 制定优化选项 -O 优化寄存器代码，造成了错误 设备寄存器中的数据不需要改写就可以自己发生变化,每次读上来的值都可能不一样 连续多次向设备寄存器中写数据并不是在做无用功,而是有特殊意义的。 如何防止编译器优化造成的影响 加上限定符volatile 123/* artificial device registers */volatile unsigned char recv; // 仿照寄存器设备volatile unsigned char send; Volatile 有了volatile 限定符,是可以防止编译器优化对设备寄存器的访问。 当一个全局变量被同一进程中的多个控制流程访问时也要用volatile限定,比如信号处理函数和多线程。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Complation</category>
      </categories>
      <tags>
        <tag>complation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CC2540]]></title>
    <url>%2F2019%2F03%2F17%2FCC2540%2F</url>
    <content type="text"><![CDATA[CC2540核心板电路图阿莫电子 正常工作：CC2540工常工作的晶振是32M,休眠晶振是32.768K。 IT 官网 RESET 引脚：接了一个电阻 复位键：加了一个下拉电阻。（通过一个电阻减小电流对reset pin 造成的影响） CC2540 连接不上仿真器外部晶振不工作 原来CC2540为了降低功耗：设置了几种不同的工作模式，在没有程序运行的情况下，默认是关闭外部的晶振的，所以在新片子刚焊上时，晶振当然也就不起振了。 两端的匹配电容大小要合适，不然导致无法起振； 选择的电容的值越大单片机的耗电能力也就越强，而且易造成不起振的情况。减小晶振的电容值 PCB 焊接错误 参考蓝牙 底部是需要进行焊接的：之前焊接的时候都是有意避开底部，不上焊锡。 电压检查 Bias 引脚 错误原因排除 32 M 晶振的是适配电容用12 pF; PCB板子的底部应该是打孔 3*3 cc2540内部集成了上电的复位电路，我们没有，应该加上电复位Reset TI 建议在RESET 上连接RC 滤波电路，这样增加系统的可靠性，其实也可以直连RESET。 CC-debugger 板子的2脚反馈电压不正常，板子的供电不正常。– 排除 开发手册 参考教程]]></content>
      <categories>
        <category>cc2540</category>
        <category>Electronic</category>
      </categories>
      <tags>
        <tag>cc2540</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crystal Oscillator]]></title>
    <url>%2F2019%2F03%2F17%2FCrystalOscillator%2F</url>
    <content type="text"><![CDATA[Oscillator and Crystal有源晶振 oscillator（振荡器） 有源晶振是右石英晶体组成的。 石英晶片：可以当为振荡器使用，是基于它的压电效应：在晶片的两个极上加一电场，会使晶体产生机械变形； 四脚晶振 有源的四脚晶振：有个点标记的为1脚，按逆时针（管脚向下）分别为2、3、4 有源晶振通常的用法：一脚悬空，二脚接地，三脚接输出，四脚接电压。 配置电路 有源晶振不需要DSP的内部振荡器，信号质量好，比较稳定，而且连接方式相对简单。 电源滤波：通常使用一个电容和电感构成的PI型滤波网络， 三脚输出端：用一个小阻值的电阻过滤信号。 无源晶振 Crystal 仅由阻容元件组成 起振需求 无源晶振是有2个引脚的无极性元件，需要借助于时钟电路才能产生振荡信号，自身无法振荡起来。 两端的匹配电容大小要合适，不然导致无法起振。 晶振是否起振测量示波器测量 通电的情况下，测量双脚： 脚1和脚3是通电的，电流从脚1流入、脚3流出。 正接脚1，负接3； 以探头最好打到衰减档进行测试，探头测试晶振管脚有固定正确频率的正弦波信号输出即可。 通电的情况下，测量单脚： 用示波器连接任意一个引脚与地线， 观测到震荡波形且频率与晶振频率相符（频率不对的话是干扰信号）就说明已经起振。 原因分析焊接 晶振的温度范围 -50 – 85。 焊接时烙铁的温度200 度左右。 PCB 工艺问题 电容值不匹配，电容值大小和晶振起振相反。 降低电容值，看是否起振 选择的电容的值越大单片机的耗电能力也就越强。而且易造成不起振的情况。 晶振两脚之间有走线 晶振电路的走线过长]]></content>
      <categories>
        <category>Oscillator</category>
        <category>Electronic</category>
      </categories>
      <tags>
        <tag>Oscillator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[post]]></title>
    <url>%2F2019%2F03%2F17%2Fpost%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[x86Programe]]></title>
    <url>%2F2019%2F03%2F14%2Fx86Programe%2F</url>
    <content type="text"><![CDATA[x86 Programe 确实没怎么看懂 X86的寄存器 x86的通用寄存器有eax 、ebx 、ecx、edx 、edi 、esi 前面加 %eax 汇编语句的编译执行 文件命名：.s 代码解读 .globl name : 需用连接器 ld 知道的名字 edi / ebx / eax ELF 文件 ELF Header 目标文件布局]]></content>
      <categories>
        <category>LinuxC</category>
        <category>x86 Programe</category>
      </categories>
      <tags>
        <tag>LinuxC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CBIB Item]]></title>
    <url>%2F2019%2F03%2F14%2FAutoCADxbox%2F</url>
    <content type="text"><![CDATA[CBIB ItemAutoCAD Xbox autocad 制作盒子给kinect KinectXobx xbox.pdf 尺寸图 类别尺寸 mm 长 宽 高 平板尺寸图 303 188 11 Xbox 284 39 62 Xbox 云台 82 20 73 类别尺寸 长 宽 高 俯视图外层 305 200 俯视图内部虚线 Kinect [2019.4.8] 语音上的修改 在Qt上弹出一个设置：语音播放测量结果，是否可以进行选择 语音播放后界面的测量时间太长。 加一个Qt 设置的界面 可选择是否显示文字；（防止语音出问题） 可选择是否通过语音播放； 测量值，身高的差别太大了，能不能在测出的结果下截取一定的值 三轴传感器实现音乐的播放实现目的 实现简单的音乐简谱：从最简单低音，中音，高音 ，实现 do re mi fa so la xi 七个音符 ； 对音乐的简谱有一个了解; 电脑的beep，可以实现； 通过读取三轴传感器的数据，控制电脑播放某一个音节； 电脑读取：USB三轴传感器的数据； 数据进而控制简谱的播放：对应的关系。 先检测晃动的轻重：能够控制低音，中音，高音； 检测晃动的频率：能控制播放的节拍 电脑能够记录弹奏者 用户自己输入一遍音符 ：只保证正确，不需要匹配速率； 当播放用户的文件时 加速度传感器：控制用户播放音符的节奏 通过检测晃动的频率 用户输入音符：记录用户输入的轻重节奏 当播放用户的文件时 加速度传感器：控制音符的低音，中音，高音； 最后能够实现 制作一个指挥棒； 指挥棒能完成一首音乐演奏的指挥任务 平台搭建 先使用USB的三轴传感器，进行功能的实现； 后期ESP32 的蓝牙 + 三轴传感器；实现远程的控制 血压检测仪–飞机上使用开发型的资料 Code交接 代码的基本注释 代码的整体流程图 硬件文档 硬件整体的设计，制作，生产文档 硬件输入以及输出 硬件的基本接口 硬件的PCB和原理图 二次开发资料 开发的资料和网站 调试文档 经常遇到的Bug，尽量提供解决方案 生产型的资料 程序下载文档 程序的烧写 读取ESP32的MAC地址，生成二维码 产品组装文档 传感器+主控+供电模块：如何连接 遇到过的问题有哪些？ 呼吸暂停检测硬件模块搭建供电模块 锂电池供电，1500mah； mirco_usb 进行充电； 报警模式 蜂鸣器模块报警 震动模块报警 远程APP传送指令 传感器检测形式 传感器形式 模拟式传感器 – 透射式检测 数字式传感器 – 反射式 检测位置 手指检测（占时不考虑） 手腕检测 整体封装 电路盒 + 护腕带 臂带]]></content>
      <categories>
        <category>CBIB Item</category>
      </categories>
      <tags>
        <tag>cbib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Architecture]]></title>
    <url>%2F2019%2F03%2F14%2FComputerArchitecture%2F</url>
    <content type="text"><![CDATA[Computer Architecture Von Neumann 体系结构主要由CPU(processor) + Memory ( data + fetch ) 数据的存储，访问和管理 操作系统 程序运行流程 fetch（取址）– decode（解码） – excuse（执行） 操作系统作用：确保系统易于使用且高效运行； 如何高效运行：虚拟化 将物理资源虚拟化，好像有多个备用资源；(内存管理机制) 虚拟化CPU: 决定执行哪个程序； 虚拟化内存：数据结构的保存； 并发 在同一个内存空间中：运行的多个函数； 每次都有多个线程处于活动状态； 持久性 通过文件系统，对数据进行持久的保存 操作系统设计的目标 建立抽象：方便系统的调用； 高效性能：减少开销 提供保护：在应用程序之间，以及OS和应用程序之间提供保护 使用的方法：隔离 内存和地址 地址 CPU通过address找到存储单元，每个存储单元只能存一个byte，将数据放入存储单元中。 内存 内存的大小：却绝育CPU的地址空间； 32位：0x0000 0000 - 0xffff ffff 找存储位置，进行读 / 写操作。 CPU CPU总是周而复始地做同一件事 : 从内存取指令,然后解释执行它,然后再取下一条指令,再解释执行 CPU 包含功能单元 Register ： 是CPU内部的高速存储器，像内存一样可以存取数据，速度更快。 程序计数器 保存CPU取指令的地址，CPU读到地址后，按照地址去内存中取指令； 取完本次指令后，指向内存中的下一条指令 是CPU的特殊寄存器 指令解码器 算数逻辑单元 ALU 地址和数据总线 32位处理器有32条地址线和32条数据线 可以表示一个32位的数 设备 CPU除了访问内存外，还要访问很多Device 总线 总线：正因为地址线和数据线上可以挂多个设备和内存芯片所以才叫“总线”,但不同的设备和内存应该占不同的地址范围。 加载：操作系统在执行程序时，从硬盘拷贝到内存，这样CPU才可以取指令执行。 进程：程序加载到内存后，成为操作系统调度执行的一个任务。 中断：为了提供设备发送主动请求。 中断处理的步骤：先判断哪个设备引发的中断，然后调用该设备驱动程序提供中断处理函数。 Linux内核源代码：绝大部分是设备驱动程序。 设备驱动程序：是操作系统内核里的一组函数,主要是通过对设备寄存器的读写实现对设备的初始化、读、写等操作，有些设备还要提供一个中断处理函数供ISR调用。 CPU访问的类别 Memory Device 访问方式 按地址进行读写 按地址进行读写 访问操作 a按地址找到存储单元，进行读写 给设备发一个命令，数据不一定保存 集成在处理器的芯片访问方式 内存映射I/O，端口I/O 数据 只保存数据 产生新的数据 请求 被动等待读和写 主动发送请求 Memory Management Unit虚拟内存管理 VIrtual Memory Management 操作系统需要用VMM ：需要MMU的支持。 物理地址：处理器没有MMU，CPU执行单元发送的内存地址将直接传到芯片引脚，被内存芯片（物理内存）接受。 虚拟地址：CPU发送的内存地址被MMU捕获，从CPU到MMU的地址。 物理地址和虚拟地址 32位的CPU：指CPU的寄存器是32位，数据总线是32位，虚拟地址空间是32位。 物理地址的范围：取决于处理器芯片上的芯片引脚有多少条地址线， 虚拟地址映射带物理地址：MMU进行管理分配，具体细节就不聊了。 MMU 内存保护机制 MMU除了做地址转换（虚拟–物理）之外，还提供内存保护机制。 内存保护机制：操作系统设置的访问权限。 操作系统将虚拟地址空间划分为：用户空间和内核空间。 中断：从用户空间切换到内核空间，处理异常。（用户空间的切换，必须有中断发起） Memory Hierachy 计算机的存储器分为若干等级，按照离CPU的远近依次是： 寄存器，Cache，内存中的数据都是掉电易丢失； 寄存器访问：由程序指令直接控制之外；其他的存储器都不是由指令直接控制的。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Operate System</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu for ESP32 select development environment]]></title>
    <url>%2F2019%2F03%2F12%2FEsp32%2F</url>
    <content type="text"><![CDATA[ESP32开发环境的选择ESP-IDF for ESP32 通过gcc交叉编译进行开发 Esp32，开发类似于ESP8266，乐鑫官方提供相应的开发教程。 ESP32的SDK的编程指南，ESP-IDF编程指南 开发环境搭建 在Ubuntu下搭建ESP32开发环境 编译依赖工具 ESP32 的编译开发主要依赖两大核心工具，一个是乐鑫官方提供的ESP32交叉编译工具链，另外一个是python2.7。 配置工程，开始编译 有一个Bug，每次都要重新指定，ESPIDF的实际路径 1export IDF_PATH=/home/quronghui/HustFiles/Esp32/sources/esp-idf Arduino IDE for ESP32 arduino-esp32 主要是在Arduino IDE 中加载 Esp32 的core; PlatformIO for ESP32环境搭建 VS Code 中加载组件platform。 在platform 中加载ESP32的库。 基于ESP-IDF开发 使用ESP-IDF进行开发 例子的参考 espressif/esp-idf 基于Arduino 开发 开发平台选择arduino，这样就可以直接开发了 开发平台比较 在Ubuntu下进行开发 类别 ESP-IDF for ESP32 Arduino IDE for ESP32 PlatformIO for ESP32 环境搭建 有明确的文档 github有说明 直接加载平台就行 编译 编写makefile，指定IDF_PATH 平台操作 平台操作 下载 命令行 平台操作 平台操作 开发难度 目前来说有点难（make指令） 加载库 加载库 开发界面 vs code 不友好 vs code 选择 platformio]]></content>
      <categories>
        <category>Esp32</category>
        <category>Ubuntu Vs Code</category>
      </categories>
      <tags>
        <tag>Esp32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu for Arduino]]></title>
    <url>%2F2019%2F03%2F12%2FArduinoInUbuntu%2F</url>
    <content type="text"><![CDATA[Ubuntu for Arduino 将嵌入式设备的开发从Windows，迁移到了Linux下 Ubuntu + Vs Code + PlatfromIO Port Permission denied 问题：下载程序到arduino时，端口权限报错。 12Auto-detected: /dev/ttyACM0*** [upload] could not open port /dev/ttyACM0: [Errno 13] Permission denied: '/dev/ttyACM0' 重启后权限消失 12给端口权限sudo chmod 666 /dev/ttyACM0 永久权限 12sudo gedit /etc/udev/rules.d/70-ttyacm.rules // 添加权限文件KERNEL=="ttyACM[0-9]*",MODE="0666" // 添加权限文件 串口显示问题 问题：串口一直不能输出 解决：代码错误 1Serial.print("hello\n"); // 不是 printf("")]]></content>
      <categories>
        <category>Arduino</category>
        <category>PlatformIO</category>
      </categories>
      <tags>
        <tag>arduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Operator]]></title>
    <url>%2F2019%2F03%2F12%2FLinuxCoperator%2F</url>
    <content type="text"><![CDATA[LinuxC Operator 主要是介绍位运算符，通过位运算对整数进行操作。 位运算按位与、或、异或、取反 要进行数据类型的转换：Data Type 123unsigned char c = 0xfc;unsigned int i = ~c;result : ffffff03 先进行类型的提升，在进行转换。 移位运算 移位运算符(Bitwise Shift)包括 左移 &lt;&lt; 和 右移 &gt;&gt; 无符号的移位 左移将一个整数的各二进制位全部左移若干位 有符号的移位 不建议使用，减少出错 正数的高位移入0 移位运算中：不同进制数 和 不同的类型之间的区别 不同的进制数：同一个数用不同的方式进行表示 不同的类型：存储一个数所能提供的空间（位） 同一个数在不同的类型转换中，会发生溢出现象 掩码 对一个整数的某些位进行操作 1define ： mask = 0x0000ff00; //(定义一个32的存储类型int)对一个数的8-15位进行操作 其他运算符复合赋值运算符 在赋值的同时做一次运算 对于有 Side Effect 的表达式，影响是不同的。 Sizeof and typedef sizeof 是一个特殊的运算符：sizeof 表达式和 sizeof(类型名) sizeof(表达式)： （表达式）不进行求值计算，将（表达式）类型所占的字节数，作为整个sizeof(表达式)的值 sizeof（表达式）的值 = 是size_t类型的 size_t 类型名 C明确规定：sizeof 的值是无符号整形 1typedef unsigned long size_t; // 为了不同平台，规定size_t的类型 typedef 用于给一个类型取名字 12typedef unsigned long size_t; // size_t是一个类型，代表unsigned long的类型unsigned long size_t; // size_t是一个变量，变量的类型是unsigned long 123typedef char array_t[10];array_t a;// 定义了一个 char类型的 a[10] Side Effect and Sequence Point 造成的后果：结果出现Undefined Side effect : 针对函数调用过程中，先后顺序不确定，造成结果的Undefined. Sequence Point：调用一个函数时,在所有准备工作做完之后、函数调用开始之前。 1foo( f(), g()); //调用函数f(),g()的Side Effect发生的顺序不一定；等所有的Side Effect调用完了，才调用foo() short-circuit : 简写 &amp;&amp; || 的逻辑表达式 12a &amp;&amp; b // &amp;&amp;：a为真才调用b，写成if(a) b; a || b // ||: a为假才调用b, 写成 if(!a) b; Sequence Point 哪些地方是一个Sequence Point（序列点） 一个完整的操作前后都可以称之为Sequence Point； 完整的声明；完整表达式的末尾； “ ； ” 像printf 、scanf 这种带转换说明的输入/输出库函数,在处理完每一个转换说明相关的输/输出操作时是一个Sequence Point。 定义规则 在两个Sequence Point之间,同一个变量的值只允许被改变一次。 如果在两个Sequence Point之间既要读一个变量的值又要改它的值,只有在读写顺序确定的情况下才可以这么写。 错误示例 12int a=0;a = (++a)+(++a)+(++a)+(++a); //对变量a有5次Side Effect 1a[i++] = i; // 变量i的读写顺序不能确定 运算符总结 运算符的规则：也就是优先级 Bug 查错的规则：优先级的先后顺序 算数 &gt; 移位 &gt; 关系 &gt; 相等性 &gt; 按位操作 &gt; 逻辑操作 &gt; 条件运算符 &gt; 赋值 &gt; 逗号 左值和右值 左值的判断 在等号左边的表达式，并且能表示一个可以存储结果值的地点，通过左值表达式可以访问 12a = b + 25; //a就是一个左值，能保存表达式 b+25的值b+25 = a; // (b+25) 不能成为左值，虽然（b+25）表示一个值，但是不知道存储在某个角落 右值的判断]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>LinuxC Operator</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataType]]></title>
    <url>%2F2019%2F03%2F12%2FDataType%2F</url>
    <content type="text"><![CDATA[DataType整形 计算机的最小存储单位：Byte(不是bit) 1 Byte = 8 bits char 占一个 Byte 代码的可移植性 编译器规定 有无符号类型 C 规定的Implementation Defined C语言和平台和编译器密不可分的； ASCII 的取值范围是 0-127 这时候char存储一个ASCII，不必写明signed和unsigned 如果char表示8位的整数 为了可移植性就必须写明是signed还是unsigned 2’s Complement : 表示的是补码 Implementation-defined、Unspecified和Undefined implementation Unspecified C标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中； 这样即使用同一个编译器的不同版本来编译也可能得到不同的结果 因为编译器没有在文档中明确写它会怎么处理,那么不同版本的编译器就可以选择不同的处理方式。 Undefined C标准规定 除了char类型需要表明 signed 和 unsigned 其他整形不明确表明signed 和 unsigned，都表示有符号(-127-128)的数 容易造成访问越界的问题 整形数据需要表明有无符号 C规定用八进制和十六进制常量，代替二进制常量。 除了char是C明确规定占一个字节，其他的几个字节都是implementation 浮点型 float 型通常是32位，double型通常是64位。 浮点型的后缀和类型 double : 没有后缀 float : f / F 的后缀 long double : l / L的后缀 类型转换 C语法中最复杂的一部分 Integer Promotion char，short，Bit-field：提升为整形int表示，或者unsigned int 12unsigned char c1 = 255, c2 = 2;int n = c1 + c2; 最后结果是257，而unsigned char 范围是0-255; 是先把c1 和c2提升为int类型，然后相加得到的 Usual Arithmetic Conversion 两边运算的类型不同，低的类型往高的类型转换 赋值类型的转换 右边的类型转换为左边的类型，在进行赋值 编译器的类型转换处理 规则不用用来记的，而是用来排错误 数据转换最大的问题便是：造成越界或者溢出]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Data Type</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Number Of Computer]]></title>
    <url>%2F2019%2F03%2F12%2FNumberOfComputer%2F</url>
    <content type="text"><![CDATA[Number Of Computer进制间的转换 最高位和最低位 十进制转二进制 除二取余 余数倒着写便是 小数转换 十进制转换为二进制 乘二取整，顺序排列。 整数的加减运算 负数的加减运算 减法运算：取被减数的补码（取反加一） 采用补码做加减运算时总是忽略MSB的进位？、 判断溢出的办法是这样的:在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出,否则就说明产生了溢出。 带符号数和不带符号数 用8个bit既表示正数又表示负数,则能够表示的范围是-128~127, 8个bit全部表示正数,则能够表示的范围是0~255,前者称为有符号数(Signed Number), 后者称为无符号数。 浮点数 数的表示：模型的三部分 符号位 指数部分（表示2的多少次方） 尾数部分（只表示小数点后面的数字）–（需要将有效数字全部移到小数点后面） 尾数部分如何表示？ 尾数的规定 尾数必须以 0.1 开头]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Number of computer</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Stack And Queue]]></title>
    <url>%2F2019%2F03%2F07%2FLinuxCStackAndQueue%2F</url>
    <content type="text"><![CDATA[Code link, Stack and Queue LinuxC Stack And Queue数据结构 数据结构(Data Structure)：是数据的组织方式。 程序中用到的数据都不是孤立的，而是有相互联系的，根据访问数据的需求不同，同样的数据可以有多种不同的组织方式。 把同一类型的数据组织成数组，或者把描述同一对象的各成员组织成结构体。 数据的组织方式 包含：存储方式和访问方式 数组的各元素是一个挨一个存储的，并且每个元素的大小相同，因此数组可以提供按下标访问的方式。 结构体的各成员也是一个挨一个存储的，但是每个成员的大小不同，所以只能用.运算符加成员名来访问,而不能按下标访问。 数据的存储方式和访问方式，决定了解决问题可以采用什么样的算法。 设计相应的数据结构来支持这种算法 [算法+数据结构=程序] Algorithms + Data Structures = Programs. Niklaus Wirth. Link 堆栈概念 堆栈：是一组元素的集合，类似于数组 数组可以按照下标访问元素； 堆栈被限制为Push(入)，Pop(出) 只能访问栈顶元素而不能访问其他元素 所有元素类型相同 堆栈的存储：可以用数组实现 访问操作：通过函数接口提供 数组stack 是堆栈的存储空间 top 用作数组stack 的索引， 注意top总是指向栈顶元素的下一个元素, 可以把它称为指针(Pointer)。 算法设计 代码 Assert 测试 前提条件 ：注意top总是指向栈顶元素的下一个元素 putchar函数的作用是把一个字符打印到屏幕上,和printf的%c作用 队列 Queue概念 队列也是一组元素的集合，也提供两种基本操作: Enqueue(入队)将元素添加到队尾 Dequeue(出队)从队头取出元素并返回。 FIFO(First In First Out,先进先出) 队列的索引 变量head、tail 就像前两节用来表示栈顶的top一样 是queue数组的索引或者叫指针,分别指向队头和队尾。 每个点的predecessor成员也是一个指针,指向它的前趋在queue数组中的位置。 算法设计 1234* (1) 广度优先是一种步步为营的策略,每次都从各个方向探索一步,将前线推进一步,* (2) 队列中的元素总是由前线的点组成的* (3) 广度优先搜索还有一个特点是可以找到从起点到终点的最短路径* (4)而深度优先搜索找到的不一定是最短路径 堆栈 VS 队列 堆栈 栈操作的top指针在Push（入）时增大 Pop（出）时减小 栈空间是可以重复利用的 队列 队列的head、tail指针都在一直增大； 虽然前面的元素已经出队了,但它所占的存储空间却不能重复利用 为了解决队列的问题 引入环形队列 从head到tail之间是队列的有效元素,从tail到head之间是空的存储位置, head追上tail就表示队列空了；tail追上head就表示队列的存储空间满了。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Stack And Queue</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Assert]]></title>
    <url>%2F2019%2F03%2F07%2FLinuxCAssert%2F</url>
    <content type="text"><![CDATA[LinuxC AssertAssert Code Precondition : 代码的前提条件的测试； Maintenance：代码主要功能函数的测试； Postcondition：代码结果是否超过范围的测试 测试函数：简单的代码方式测试，主要是测试条件/结果是否为真 Shut Assert 测试代码只在开发和调试时有用，如果已经发布(Release)的软件还要运行这些测试代码就会严重影响性能了。 所以C语言规定,如果在包含assert.h 之前定义一个NDEBUG宏(表示NoDebug) 就可以禁用assert.h中的assert宏定义，代码中的assert就不起任何作用了: Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 折半查找* 项目1介绍：* (1)折半查找的前提是数组已经排序好；* （2）提供assert代码测试的思想*/#define NDEBUG /* 取消assert代码的相关测试 */#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#define LEN 8int a[LEN] = &#123;1, 3, 3, 3, 9, 5, 6, 7&#125;;int is_sorted()&#123; int i, sorted = 1; for (i = 1; i &lt; LEN; i++) sorted = sorted &amp;&amp; a[i-1] &lt;= a[i]; /* 保证序列是一个排序好的 */ return sorted;&#125;int mustbe(int start, int end, int number)&#123; int i; for (i = 0; i &lt; LEN; i++)&#123; if (i &gt;= start &amp;&amp; i &lt;= end) continue; if (a[i] == number) return 0; &#125; return 1;&#125;int binarysearch(int number)&#123; int mid, start = 0, end = LEN - 1; assert(is_sorted()); /* Precondition 前提条件测试 */ while(start &lt;= end)&#123; assert(mustbe(start, end, number)); /* Maintenance 主要函数测试 */ mid = (start + end) / 2; if(a[mid] &lt; number) start = mid + 1; else if (a[mid] &gt; number) end = mid - 1; else return mid; &#125; assert(mustbe(start, end, number)); /* Postcondition 测试最终的结果*/ return -1; &#125;int main(void)&#123; printf("where the element %d\n", binarysearch(3)); return 0;&#125;]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Assert</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Order And Finding]]></title>
    <url>%2F2019%2F03%2F06%2FOrderAndFind%2F</url>
    <content type="text"><![CDATA[LinuxC Order And Finding Order code [order files] 算法的概念 算法（algorithm） 将一组输入转化成一组输出的一系列计算步骤,其中每个步骤必须能在有限时间内完成。 用来解决一类计算问题的，而不是一个特定的问题 。 最有解和正确算法 对于某个问题求解最优算法很困难，但是某个不正确的算法可以再有限时间内终止，将误差控制在一定范围内； 这样的算法也是有意义的。 插入排序 理解循环结构体的算法 满足三条准则，便是 Loop Invariant 递归和循环 等价 和证明递归程序的思想一样 第一条便是递归的 Base Case 第二条便是递归的递推关系。 时间复杂度 分析算法的时间复杂度 最坏情况和平均情况的复杂度都是 O(n^2) 时间复杂度有小到大排序 归并排序 区别： 插入排序策略：每次添加一个到已排序的子序列中，时间复杂度是 O(n^2) 归并排序：将时间复杂度降到 O(nlgn)。 递归的思想看代码 递归：如果定义一个概念（函数），需要用到概念（函数）本身，则称之为递归 Gdb: 展开的方式看递归（这样很笨） – 单步加断点的方式调试程序的每步结果。 捉住 Base Case 和 递推关系来理解，不能展开来看，这样就很乱了。 时间复杂度计算 设计不同时间复杂度的算法 这个就是算法的初步体现 通过不同的数据结构，体现算法的效能 折半查找 折半查找提供了一种代码测试的思想 assert.h 函数进行测试]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Order</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Gdb]]></title>
    <url>%2F2019%2F03%2F04%2FLinuxCGdb%2F</url>
    <content type="text"><![CDATA[LinuxC Gdb Code link – Gdb的相关代码 Gdb调试方式 程序中除了一目了然的Bug之外都需要一定的调试手段来分析到底错在哪 根据程序执行时的出错现象假设错误原因,然后在代码中适当的位置插入printf , 强大的调试工具gdb,可以完全操控程序的运行。 调试思想 分析现象 –&gt; 假设错误原因 –&gt; 产生新的现象去验证假设 单步执行和跟踪函数调用开始调试 gdb -g 编译 123456/** -g选项的作用是在目标文件中加入源代码的信息,比如目标文件中第几条机器指令对应源代码的第几行；* 但并不是把整个源文件嵌入到目标文件中,所以在调试时目标文件时必须保证gdb也能找到源文件。*/$ gcc -g main.cpp -o main -Wall $ gdb main gdb 命令help 12$ (gdb)help // gdb提供一个类似shell下输入help,可以查看命令的类别:$ (gdb)help files // 可以进一步查看某一类别中有哪些命令,例如查看files类别下有哪些命令可以用 列出源码 123$(gdb) list 1 //从第一行开始列出源代码，一次只能10行$(gdb) 回车 // 重复上一条命令$(gdb) l add_range // list命令可以用 l 来表示，列出一个函数的源代码 gdb quit 退出Gdb 调试环境 单步调试 next 主函数的调试 1234$ gdb main$ (gdb) start //开始执行程序$ (gdb) next //控制主函数的语句，一条条的执行（enter--重复上次命令）// 错误不在main()函数，而在功能函数里面 step 功能函数的调试 1234$ (gdb) start //开始执行程序$ (gdb) step //进入函数中执行$ (gdb) bt(backtrace) //查看函数调用的栈针$ (gdb) i locals // 查看功能函数，局部变量的值； main函数传进来的参数； main函数的栈帧编号为1，功能函数add_range 的栈帧编号为0 123456789101112zhi/*查看 main函数当前的局部变量的值*/$ (gdb) f(frame) 1 //选择1号栈帧，然后在查看局部变量$ (gdb) i locals // 查看主函数，局部变量的值；/*在step,跟几步看看*/$ (gdb) step //除了主函数，还有其他功能函数的值$ (gdb) finish //finish 一直运行到当前函数返回为止,得出当前的结果$ (gdb) p result //查看数组result的值，相当于print/*修改变量值，看还有没有其他bug*/$ (gdb) set var sum=0 //修改变量的值$ (gdb) finish 调试命令{% asset_img GdbCommand.png 调试命令汇总 %} 总结 i locals 查看当前的局部变量，这个是最有用的。 查询功能函数的变量是否初始化。 通过条件语句来设置终端，这个挺好用的。 step 和 next 区别 step 用于调到功能函数； next 在调到功能函数的时候，单步执行 断点字符型和整形 字符型转化为整形： 整形＝字符型 － ‘０’的ASCII值 ASCII码值：’0’＝48; ‘\0’ = 0 断点加单步 单词断点流程 12345678$ gcc -g main.c -o main$ gbd main$ display sum //我们可以用display命令使得每次停下来的时候都显示当前sum值 //每输入一次print sum ; 打印一次当前的sum值，$ break 9 //break命令的参数也可以是函数名,(在第９行设置一个断点)$ continue //连续运行而非单步运行,程序到达断点会自动停下来,这样就可以停在下一次循环的开头。$ next //单步调试，深入内容 多个断点的设置 123456$ break 12 //设置另外一个断点$ i breakpoints //一次调试可以设置多个断点,用info命令可以查看已经设置的断点$ delete breakpoints 1 //删除编号为１的断点$ disable breakpoints 1 //通过禁用，而不用删除$ enable breakpoints 1 //enable 启用断点１ 条件断点 123$ break 9 if sum != 0 //在循环开头设置断点,但是仅当sum不等于0时才中断$ run //然后用run命令,重新从程序开头连续执行:$ continue //连续执行到断点的时候停止 调试Bug Bug: 数组的末位含有一个 ‘\0’字符，printf打印的时候遇到’\0’就停止打印。 观察点 调试代码Breakpoint.cpp的代码一；数组越界的问题 代码逻辑 1234$ watch input[5] //设置input[5]为观察点$ info watchpoints //查看当前设置的观察点$ x/7b input //打印数组input才存储器的内容 //打印的是字符对应的十六进制ASCII的值 段错误 文章一直在强调，“scanf”函数是一个十分凶险的函数； 用户输入的值是不确定的； 造成数组的越界；’\0’的越界 造成段错误: Segmentation fault 运行逻辑 12$ run //运行代码，当出现错误的时候会自动停止运行$ bt //查看那个函数调用产生的错误 反汇编C和汇编穿插显示12gcc -g main.c -o main -Wall // 生成可执行文件objdump -dS main // 把C代码和汇编代码穿插起来显示 只生成汇编1gcc -S main.c //只生成汇编代码main.s,而不生成二进制的目标文件。 汇编调试12345(gdb) disassemble //可以反汇编当前函数或者指定的函数(gdb) si //step 命令可以一行代码一行代码地单步调试,而这里用到的si命令可以一条指令一条指令地单步调试。(gdb) info registers //可以显示所有寄存器的当前值。(gdb) p $esp //打印esp寄存器的值,// 在上例中esp 寄存器的值是0xbff1c3f4,所以x/20 $esp 命令查看内存中从0xbff1c3f4地址开始的20个32位数。 总结 学C语言不可能不去了解底层计算机体系结构和操作系统的原理，不了解底层原理连一个scanf函数都没办法用好，更没有办法保证写出正确的程序。 工具二: valgrind 查找程序中内存泄露和其他隐藏的内存问题;]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Gdb</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Coding Style]]></title>
    <url>%2F2019%2F03%2F04%2FLinuxCCodingStyle%2F</url>
    <content type="text"><![CDATA[LinuxC Coding Style Linux kernel Coding Style Thus, programs must be written for people to read, and only incidentally for machines to execute. 缩进和空白 双目运算符的两侧插入一个空格分隔,单目运算符和操作数之间不加空格, 1i = i + 1、++i 、!(i &lt; 1)、-x、&amp;a[1] ... ‘, ‘ 号和 ‘;’ 号之后要加空格, 这是英文的书写习惯 1for (i = 1; i &lt; 10; i++) 、foo(arg1, arg2) ... switch 的语句块 注释 顶头源文件的注释 整个源文件的顶部注释。说明此模块的相关信息,例如文件名、作者和版本历史等,顶头写不缩进。例如内核源代码kernel/sched.c的开头: 相对独立的语句注释 用 / hello / 注释尽量少用 标识符命名 .小写 内核风格规定变量、函数和类型采用全小写 加下划线的方式命名, 1上面举例的函数名radix_tree_insert、类型名struct radix_tree_root 大写 常量(宏定义和枚举常量enum)采用全大写加下划线的方式命名。 1常量名RADIX_TREE_MAP_SHIFT 全局变量和全局函数命名 全局变量和全局函数的命名一定要详细,不惜多用几个单词多写几个下划线 因为它们在整个项目的许多源文件中都会用到,必须让使用者明确这个变量或函数是干什么用的。 函数 执行函数： 执行函数就是执行一个动作,函数名通常应包含动词,例 如get_current、radix_tree_insert。 分割函数 多个.c的文件 功能函数 C语言中的功能函数包含动词 字母加下划线的方式进行。void insertion_sort() Indent Tools Indent Tools 将代码格式化为某种风格 12indent -kr -i8 main.c /* -kr 表示K&amp;R 的风格；-i8 表示TAB键缩进8个空格的长度 */cat main.c]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Array]]></title>
    <url>%2F2019%2F03%2F04%2FLinuxCArray%2F</url>
    <content type="text"><![CDATA[LinuxC ArrayCode link – Array 的相关代码 数组的基本操作 数组的定义和赋值 Bug 数组不可以相互赋值。 12int a[10], b[10];a = b; //这种赋值是错误的 也不能用数组类型作为函数的参数或者返回值，用的是指针传参。 数组应用 随机数的概念: 计算机执行每一条指令的结果都是确定的,没有一条指令产生的是随机数,调用C标准库。 得到的随机数其实是伪随机(Pseudorandom)数,是用数学公式算出来的确定的数,只不过这些数看起来很随机,并且从统计意义上也很接近均匀分布(Uniform Distribution)的随机数。 123$ int x = rand() % upper_bound; // upper_bound 表示生成的随机数的最大上边界// 以后定义随机数的上边界最大值是多少 编译器的工作原理 先是预处理 Preprocess; 然后才是 编译。编译的作用：翻译高级语言为可执行的二进制语言。 1gcc -E main.c 预处理 CPP C preprocessor 像 #include 和 #define 以#号开头的与法院诉称为预处理指示 C 标准库允许我们指定初值 1srand(time(NULL)); //srand 函数指定一个seed,调用当前系统时间距离1970年1月1日00:00:00的秒钟数，然后传给srand. 字符串 字符串可以看作一个数组,它的元素是字符型的。 字符串的打印和数组的打印不同。 字符串的最后一位，必须包含一个 ‘\0’ 这里的’ ‘\0’ 是ASCII码的八进制表示. 12char str[] = "hello,world.\n";printf("string: %s \n", str); Bug printf会从数组str 的开头一直打印到’\0’字符为止(‘\0’本身不打印)。 这其实是一个危险的信号:如果数组str 中没有’\0’,那么printf就会打印出界,后果和前面讲的数组访问越界一样诡异:有时候打印出乱码,有时候看起来没错误,有时候引起程序崩溃。 多维数组 多维数组 类似于结构体的嵌套； 一个数组的元素可以是另外一个数组 多维字符数组 通过下标访问字符串组成的数组可以代替一堆case分支判断,这样就可以把每个case 里重复的代码(printf 调用)提取出来,从而又一次达到了“提取公因式”的效果。 这种方法称为数据驱动的编程(Data-driven Programming): 写代码最重要的是选择正确的数据结构来组织信息,设计控制流程和算法尚在其次,只要数据结构选择得正确,其它代码自然而然就变得容易理解和维护了]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vsiual Studio]]></title>
    <url>%2F2019%2F03%2F01%2FVisiualStudio%2F</url>
    <content type="text"><![CDATA[Visual Studio 2017 for User快捷键的使用多行注释12注释多行：先按 Ctrl - K 组合键，再按 Ctrl - C 组合键取消注释多行：先按 Ctrl - K 组合键，再按 Ctrl - U 组合键]]></content>
      <categories>
        <category>Visiual Studio</category>
      </categories>
      <tags>
        <tag>Vs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QtAndVs]]></title>
    <url>%2F2019%2F03%2F01%2FQtAndVs%2F</url>
    <content type="text"><![CDATA[Qt and Visiual Studio 通过创建Qt GUI 的程序，实现按键的点击和事件的响应。 安装Qt并且关联Vs Vs 创建Qt 工程 创建例程 Qt Gui 文件的类型介绍。 （1）是Qt设计师文件，双击可以打开Qt可视化设计 （2）Qt界面的代码文件，Qt设计师设计的界面以代码的形式存储在这里，比如Button的位置，大小，名字。 （3）Widget类的头文件，定义一些字段和函数声明，包括最重要的slots（槽）函数的声明，以及界面ui句柄，以便通过“ui.***”的方式访问到界面的各个控件，比如访问界面的Label控件里的文字可以这样：ui.label-&gt;text();就是字面意思，很容易理解。 （4）资源文件，相当于AndroidStudio里面的rcs文件夹，里面存放需要用到的.ico图标或者图片。 （5）主函数文件，程序的入口，不必解释，其实一般不会在这个里面修改什么。 （6）Widget类完成的主要文件，在widget.h里面定义之后的字段以及函数声明，以及槽的实现，都是在这里，Qt的逻辑功能设计主要是修改这个文件。 添加事件发现的函数 – 槽函数 发生事件的方式（Click()） 槽函数：接收函数 他们之间的连接 1234567891011Widget::Widget(QWidget *parent) : QWidget(parent)&#123; ui.setupUi(this); connect(ui.checkBox,SIGNAL(clicked()),this,SLOT(on_checkBox_clicked())); connect(ui.checkBox_2, SIGNAL(clicked()), this, SLOT(on_checkBox_2_clicked())); connect(ui.pushButton, SIGNAL(clicked()), this, SLOT(on_pushButton_clicked()));&#125;// ui.checkBox : ui控件// SIGNAL(clicked()) : 发生事件的方式（Click()）// SLOT(on_checkBox_clicked()))：槽函数，响应事件的方式 Qt Gui 窗口大小 Qt Gui窗口大小的设置方式 1this-&gt;setWindowState(Qt::WindowMaximized); Vs and Qt 实现语音功能 Qt to speech 问题 无法打开QtTextToSpeech文件 在VC++ 中添加目录 1C:\Qt\Qt5.12.1\5.12.1\msvc2017_64\include\QtTextToSpeech 出现LNK2019 首先添加Qt的依赖库 和 lib文件目录 然后根据错误定位到QVoice，添加相关的头文件 不允许定义静态数据成员 dllimport 12代码使用：Qt 官方代码Qt使用导出类报错：error C2491: “QTextToSpeech::staticMetaObject”: 不允许 dllimport 静态数据成员 的定义:]]></content>
      <categories>
        <category>Qt Ui</category>
        <category>Visiual Studio</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect Sdk SkeletonStream]]></title>
    <url>%2F2019%2F03%2F01%2FKinectSdkSkeletonStream%2F</url>
    <content type="text"><![CDATA[Kinect Sdk SkeletonStream 网上的知识点 骨骼追踪技术通过处理景深数据来建立人体各个关节的坐标,骨骼追踪能够确定人体的各个部分。 骨骼追踪产生X,Y,Z的三维数据，从而确定这些骨骼点的坐标。 Gain Skeleton Data 骨骼数据来自：SkeletonStream KinectSensor对象有一个名为SkeletonFrameReady事件。 当SkeletonStream中有新的骨骼数据产生时就会触发该事件。 SkeletonStream产生的每一帧数据Frame，都是一个骨骼对象集合。 Kinect SDK在SkeletonStream对象 Kinect能够追踪到的骨骼数量是一个常量。 定义了一个能够追踪到的骨骼个数常量FrameSkeletonArrayLength，使用这个常量可以方便的对数组进行初始化。 SkeletonFrameReady事件的响应方法 每一次事件被激发时，通过调用事件参数的OpenSkeletonFrame方法就能够获取当前的骨骼数据帧。 剩余的代码遍历骨骼数据帧的Skeleton数组frameSkeletons，在UI界面通过关节点将骨骼连接起来，用一条直线代表一根骨骼。 骨骼数据的检测 使用Skeleton对象的 TrackingState 属性来判断，只有骨骼追踪引擎追踪到的骨骼我们才进行绘制。 Kinect能够探测到6个游戏者，但是同时只能够追踪到2个游戏者的骨骼关节位置信息。、、 绘制骨骼直线 CreateFigure方法为每一根骨骼绘制一条直线。 GetJointPoint方法以关节点的三维坐标作为参数，然后调用 KinectSensor 对象的MapSkeletonPointToDepth 方法将骨骼坐标转换到 深度影像坐标上去。 骨骼坐标系和深度坐标及彩色影像坐标系不一样，甚至和UI界面上的坐标系不一样。 三维数据处理 骨骼关节点的三维坐标中我们舍弃了Z值，只用了X,Y值。 可以发现图像的大小是和Z值(深度)成反的。深度值越小，图像越大，即人物离Kinect越近，骨骼数据越大。 Skeleton 对象模型 对象模型有四个最主要的对象，他们是SkeletonStream，SkeletonFrame，Skeleton和Joint。 SkeletonStream对象 Enable SkeletonStream对象，才能产生数据SkeletonFrame。 骨骼数据处理是很耗费计算性能的操作。打开骨骼追踪是可以观察的到CPU的占用率明显增加。当不需要骨骼数据时，关闭骨骼追踪很有必要。 骨骼关节点帧与帧之间的位置差异。 Enable SkeletonStream对象时，调用重载的方法传入一个TransformSmoothParameters参数。 SkeletonStream对象有两个与平滑有关只读属性：IsSmoothingEnabled和SmoothParameters。 SmoothParameters属性用来存储定义平滑参数。 骨骼追踪对象选择 默认情况下，骨骼追踪引擎会对视野内的所有活动的游戏者进行追踪。但只会选择两个可能的游戏者产生骨骼数据。 如果要自己选择追踪对象，需要使用AppChoosesSkeletons属性和ChooseSkeletons方法。 要手动选择追踪者，需要将AppChoosesSkeleton设置为true，并调用ChooseSkeletons方法，传入TrackingIDs已表明需要追踪那个对象。 SkeletonFrame SkeletonStream产生SkeletonFrame对象,使用事件模型从事件参数中调用OpenSkeletonFrame方法来获取SkeletonFrame对象. 调用SkeletonFrame 对象的 CopySkeletonDataTo方法将其保存的数据拷贝到骨骼对象数组. SkeletonFrame对象有一个SkeletonArrayLength的属性，这个属性表示追踪到的骨骼信息的个数。 时间标记字段 SkeletonFrame的FrameNumber和Timestamp字段表示当前记录中的帧序列信息。 FrameNumber和Timestamp这两个字段在分析处理帧序列数据时很重要 FrameNumber 是景深数据帧中的用来产生骨骼数据帧的帧编号。帧编号通常是不连续的，但是之后的帧编号一定比之前的要大。 FrameNumber是一个32位的整型 Timestap字段记录字Kinect传感器初始化以来经过的累计毫秒时间。 imestamp是64位整型 在未来SDK中加入手势引擎之前，我们需要自己编写算法来对帧时间序列进行处理来识别手势，这样就会大量依赖这两个字段。 Frame 描述信息 FloorClipPlane字段是一个有四个元素的元组Tuple&lt;int,int,int,int&gt;，每一个都是Ax+By+Cz+D=0地面平面(floor plane)表达式里面的系数项。 D 通常为负数，是Kinect距离地面高度。 Skeleton Skeleton类定义了一系列字段来描述骨骼信息，包括描述骨骼的位置以及骨骼中关节可能的位置信息。 骨骼数据可以通过调用SkeletonFrame对象的CopySkeletonDataTo方法获得Skeleton数组。 TrackingID 骨骼追踪引擎对于每一个追踪到的游戏者的骨骼信息都有一个唯一编号。 应用程序使用TrackingID来指定需要骨骼追踪引擎追踪那个游戏者。 这个值是整型，他会随着新的追踪到的游戏者的产生添加增长。(不连续的) Kinect追踪到了一个新的游戏者，他会为其分配一个新的唯一编号。 编号值为0表示这个骨骼信息不是游戏者的，他在集合中仅仅是一个占位符。 调用SkeletonStream对象的ChooseSkeleton能以初始化对指定游戏者的追踪。 TrackingState 该字段表示当前的骨骼数据的状态。 Position Position一个SkeletonPoint类型的字段，代表所有骨骼的中间点。 该字段提供了一个最快且最简单的所有视野范围内的游戏者位置的信息，而不管其是否在追踪状态中。 例如，应用程序可能需要追踪距离Kinect最近的且处于追踪状态的游戏者，那么该字段就可以用来过滤掉其他的游戏者。 ClippedEdges ClippedEdges字段用来描述追踪者的身体哪部分位于Kinect的视野范围外，提供了一个追踪这的位置信息。 该字段类型为FrameEdges，他是一个枚举并且有一个FlagsAtrribute自定义属性修饰。 FrameEdges 值 Kinect底座上面有一个小的马达能够调整Kinect的俯仰角度。 俯仰角度可以通过更改KinectSensor对象的ElevationAnagle属性来进行调整。 如果应用程序对于游戏者脚部动作比较关注，那么通过程序调整Kinect的俯仰角能够决绝脚部超出视场下界的情况。 KinectSensor的MaxElevationAngle和MinElevationAngle确定了可以调整角度的上下界。 任何将ElevationAngle设置超出上下界的操作将会掏出ArgumentOutOfRangeExcepthion异常。 微软建议不要过于频繁重复的调整俯仰角以免损坏马达。 Joints 该字段是一个JointsCollection类型，它存储了一些列的Joint结构来描述骨骼中可追踪的关节点(如head,hands,elbow等等) 应用程序使用JointsCollection索引获取特定的关节点，并通过节点的JointType枚举来过滤指定的关节点。 骨骼追踪引擎能够跟踪和获取每个用户的近20个点或者关节点信息。 关节点 都有类型为SkeletonPoint的Position属性， 他通过X,Y,Z三个值来描述关节点的控件位置。 X,Y值是相对于骨骼平面空间的位置，他和深度影像，彩色影像的空间坐标系不一样。 最后每一个Skeleton对象还有一个JointTrackingState属性]]></content>
      <categories>
        <category>Kinect SDK</category>
        <category>Kinect</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BluetoothANT]]></title>
    <url>%2F2019%2F02%2F28%2FBluetoothANT%2F</url>
    <content type="text"><![CDATA[Bluetooth ANT 蓝牙天线的设计使用，需要注意的一些事情。 无线传感技术 蓝牙技术：要求通讯灵敏度，还需要小型化，更需要低功耗，更重要的是要低成本。 硬件天线设计：IPEX接口外接天线和PCB板载天线。 天线 天线是一种用来发射或者接收电磁波的元器件，本质上可以说是一个能量转换器。 发射天线：将发射机的高频电流能量，有效地转换成空间的电磁能量； 接收天线：将空间中的电磁能量，转化为电流能量。 IPEX接口天线​ 信号的方向指向性好，效率高，抗干扰能力强; 能远离主板上的干扰 不用过多的进行调试匹配 PCB板载天线 PCB天线容易受到主板上的干扰，效率相对较低，牺牲性能。 因为近距离数据传输本身就比较稳定，所以蓝牙模块上的天线其实在近处时的效果是差不多的。但是距离远了，外置天线会有明显的优势。 倒F型天线 特点 状或者片状，当使用介电常数较高的绝缘材料时还可以缩小蓝牙天线尺寸 天线一般放置在PCB顶层，铺地一般放在顶层并位于天线附近，但天线周围务必不能放置地，周围应是净空区。 具体尺寸 曲流型天线设计 曲流型天线的长度比较难确定。长度一般比四分之一波长稍长，其长度由其几何拓扑空间及敷地区决定。 天线一般放置在PCB顶层，铺地一般放在顶层并位于天线附近，但天线周围务必不能放置地，周围应是净空区。 具体尺寸 陶瓷天线设计 陶瓷天线是另外一种适合于蓝牙装置使用的小型化天线。 陶瓷本身介电常数较PCB电路板高，所以使用陶瓷天线能有效缩小天线尺寸，在介电损耗方面，陶瓷介质也比PCB电路板的介电损失小，所以非常适合低耗电率的的蓝牙模块中使用。 在 PCB设计时，天线周围要净空就可以了，特别注意不能敷铜。 2.4G棒状天线设计 2.4G棒状蓝牙天线体积大，但传输距离要强于其他天线。在PCB设计时，天线周围也和上述的三种天线设计一样要净空。 蓝牙天线设计 天线的信号（频率大于400MHz以上）容易受到衰减，因此天线与附近的地的距离至少要大于三倍的线宽。 1GHz=1000MHz 1MHz=1000kHz 1kHz=1000Hz 过孔会产生寄生电感，高频信号对此会产生非常大的衰减，所以走射频线的时候尽量不要有过孔。 PCB 布线问题ANT 和 GND 相连 出现一种现象：RF射频线和GND相连报错。 因为这是RF信号，也就是微波。微波就不能当一般的数字，模拟信号来对待了。虽然用万用表量，这个天线与地是短路的。而对微波，其实这整个天线铜皮其实是相当于包括了很多电阻，电容，电感等组成的等效电路。 · ANT 天线没有盖油 如何查看是否盖油 Altium Design – &gt; 只显示 Top Sloder / Bottom Sloder 原因：CC2540 的元件，绘制的时候加了 top sloder 层，导致PCB生成Gerber文件的时候默认为开窗 如何解决： 找到对应天线的元件库，删除top sloder绘制的Track]]></content>
      <categories>
        <category>Bluetooth ANT</category>
      </categories>
      <tags>
        <tag>ANT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows SDK]]></title>
    <url>%2F2019%2F02%2F28%2FWindowsSDK%2F</url>
    <content type="text"><![CDATA[Windows SDK 参考的csdn上相关的知识 了解一些关于SDK开发的一些相关的知识 Windows程序分类 Windows控制台程序 C语言编写第一个“hello world”时，当时的程序就是控制台程序。 他的本质是DOS程序，没有自己的窗口， 你看到的输出Hello world的窗口是程序本身借用了操作系统的DOS窗口 windows窗口程序 123456int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) &#123;...&#125; // APIENTRY wWinMain windos窗口程序的入口 动态链接库dll 12345BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123;...&#125; Visual studio 下的工具 所在目录：C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin 1). 编译器 CL.exe ：将源代码翻译成目标代码。 2). 连接器 LINK.exe : 将目标代码、库连接生成最终文件。 3). 资源编译器RC.exe : 将资源编译，最终通过连接器存入最终文件 Visual studio 下的 lib 库 Kernel32. dll : 提供了线程、进程、内存管理等核心的API user32.dll : 提供了窗口、消息等API gdi32.dll : 提供了绘图的API]]></content>
      <categories>
        <category>Windows SDK</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Struct]]></title>
    <url>%2F2019%2F02%2F27%2FStruct%2F</url>
    <content type="text"><![CDATA[Code link – struct 的相关代码 LinuxC Struct 学习一门语言要注意的三点 本节将以结构体为例来讲解数据类型的组合和抽象。 结构体 代码链接 结构体定义 过程抽象：将一组语句通过函数名封装Tag，当做整体调用 结构体 12345结构体：complex_struct不表示变量，而是表示类型,类似于int的符合类型 struct complex_struct &#123; double x, y; /* data */ &#125;z; 结构体的变量使用 12345678910结构体变量的初始化和使用（1）Ways1 double x = 3.0; // 不等同于Tag的z.x； z.x = x; // 变量访问成员，通过z.x z.y = 4.0; (2) Ways:定义的时候直接初始化 struct complex_struct z = &#123; 3.0, 4.0 &#125;; (3)错误的初始化 struct complex_struct z1; z1 = &#123; 3.0, 4.0 &#125;; 结构体当做函数的参数使用 123456789103. 项目描述：将结构体当做函数的参数和返回值来传递（1）结构体当做函数的参数，比如 int main,中的int(2) struct complex_struct 当做函数 add_complex的参数struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2)&#123; z1.x = z1.x + z2.x; z1.y = z1.y + z2.y; return z1; &#125; Data Abstraction (数据抽象) ​ gcc编译时提示对‘sqrt’未定义的引用 1gcc -*.c -lm // 需要链接 libm.so 库 将复数运算的代码分成块的时候，报错 代码还没有解决。DataAbstraction.cpp ​ 解决成功 123456为了避免其他文件引用DataAbstraction.h，造成重复定义的问题： add code: #ifndef _TEST_H_ #define _TEST_H_ &#123; ... &#125; #endif 数据类型的标志 也就是设立 flag （0/1）标志位 Enum 标志位 12345// 枚举类型：枚举类型的成员和变量名在同一个空间，不能定义成同样的名字。enum coordinate_type // 类似于Struct的Tag,enum代表的是枚举类型&#123; // 代表常量Rectangular（直角坐标） == 0 ； Rectangular, Polar // 代表常量Polar(极坐标) == 1&#125;; 还没有实现如何结合struct Tag 一起使用 Enum 可以实现递增赋值的Tag 1enum Month &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a,b; 结构体的嵌套 结构体有数据类型定义，结构体本身便是一种数据类型，可以进行嵌套。 1234567struct Segment&#123; struct complex_struct start; struct complex_struct end;&#125;;struct complex_struct&#123; double x,y;&#125;; 访问结构体的成员应该用多个 . 运算符 12s.start.x = 1.0;s.start.y = 2.0;]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect SDK for DepthImageStream]]></title>
    <url>%2F2019%2F02%2F27%2FKinectSDKDepthImageStream%2F</url>
    <content type="text"><![CDATA[Kinect SDK for DepthImageStream 网上的知识点 KinectSensor的最主要功能之一就是能够产生三维数据，它有红外发射器和红外摄像头。 介绍了Kinect红外传感器，景深数据格式，景深图像的获取与展示，景深图像的增强处理 ColorImageStream 数据流的获取 DepthImageStream和ColorImageStream都继承自ImageStream 景深影像数据从DepthImageFrame产生，它由DepthImageStream对象提供 景深帧数据 红外摄像机的视场是金字塔形状的。离摄像机远的物体比近的物体拥有更大的视场横截面积。这意味着影像的高度和宽度，比如640X480和摄像机视场的物理位置并不一一对应。 深度帧数据中，每个像素占16位，这样BytesPerPixel属性，即每一个像素占2个字节。每一个像素的深度值只占用了16个位中的13个位。 ​ 深度值存储在第3至15位中，要获取能够直接使用的深度数据需要向右移位 SDK在DepthImageFrame类中定义了一个常量PlayerIndexBitmaskWidth，它定义了要获取深度数据值需要向右移动的位数。 UI界面显示 在UI界面中Image空间的属性中，宽度和高度是硬编码的。如果不设置值，那么空间会随着父容器（From窗体）的大小进行缩放，如果空间的长宽尺寸和深度数据帧的尺寸不一致，当鼠标点击图片时，代码就会返回错误的数据，在某些情况下甚至会抛出异常。 景深图像处理增强灰度级 增强深度值图像： 按位翻转像素值。 图像的颜色是基于深度值的，他们从0开始。在数字光谱中0表示黑色，65536(16位灰阶)表示白色。 所有的不能确定深度值的数据都设置为了0 增强深度值图像 格式的转换 彩色影像的格式为了Bgr32位，每一个R,G,B分别占8位，剩余8位留用 这种模式限制了RGB的取值为0-255，所以需要将深度值转换到这一个范围内。 将深度值除以4095（13位的深度值，[2^13 -1] / 2），然后乘以255，这样就可以将深度数据转换到0至255之间了. 数据的处理 每一次当KinectSensor触发frame-ready事件时，代码顺序存储彩色影像。转换完成后，backgroud线程使用WPF中的Dispatcher来更新UI线程中Image对象的数据源。 这种异步的操作在基于Kinect开发的应用中很常见，因为获取深度数据是一个很频繁的操作。如果将获取数据以及对数据进行处理放在主UI线程中就会使得程序变得很慢。 景深数据处理 Kinect深度值最大为4096mm，0值通常表示深度值不能确定，一般应该将0值过滤掉。微软建议在开发中使用[1220mm（4’）~3810（12.5’)范围内的值。在进行其他深度图像处理之前，应该使用阈值方法过滤深度数据至1220mm-3810mm这一范围内。 可以绘制直方图 Opencv 处理景深数据处理 基于Kinect的应用程序不会对深度数据进行很多处理。如果要处理数据，也应该使用一些类库诸如OpenCV库来处理这些数据。 应用程序处理深度数据目的是用来确定人体在Kinect 视场中的位置。 对物体进行测量 c# 例子代码参考 每一个摄像机都有视场，焦距的长度和相机传感器的大小决定了视场角。Kinect中相机的水平和垂直视场角分别为57°和43°。 知道了底边的长度，我们就可以将像素的宽度转换为现实中的宽度。 1234（1）计算出等腰三角形底边的宽度为1500mm；（2）游戏者所占有的总象元的宽度为100；（3）深度影像数据的总象元宽度为320；实际宽度：（1500 / 320）*100 = 468.75mm 实现方式 1）先创建一个新的项目然后编写发现和初始化KinectSensor的代码，将DepthStream和SkeletonStream均初始化，然后注册KinectSnsor的DepthFrameReady事件。 2）CalculatePlayerSize方法遍历深度图像中的象元，然后提取游戏者索引位及其对应的深度值。 3）对于游戏者的每一个象元，方法调用PlayerDepthData对象的UpdateData方法。处理完所有象元之后，将游戏者数组复制给名为PlayerDepthData的ItemControl对象的数据源。 本文首先介绍了关于景深数据的简单图像数据，包括景深数据的直方图显示以及一些图像处理相关的算法，然后介绍了景深数据中的游戏者索引位，借助索引位，我们实现了人物宽度和高度的计算，最后借助景深数据结合彩色影像数据，将景深影像和视频图像进行了叠加。]]></content>
      <categories>
        <category>Kinect SDK</category>
        <category>Kinect</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect Sensor]]></title>
    <url>%2F2019%2F02%2F27%2FKinectSensor%2F</url>
    <content type="text"><![CDATA[Kinect Sensor 网上的知识点 Kinect 设备的硬件介绍 Kinect设备 基座和感应器之间有一个电动的马达，通过程序能够调整俯仰角度; 在上面的感应器中有一个红外投影仪，两个摄像头，四个麦克风和一个风扇。、 最左边是红外光源，其次是LED指示灯 中间的是彩色摄像头，用来收集RGB数据 最右边是红外摄像头用才采集景深数据 成像大小 彩色摄像头最大支持1280*960分辨率成像 红外摄像头最大支持640*480成像 麦克风阵列 一个在左边的红外发射器下面， 3个在右边景深摄像头下面 Kinect in windows 环境的搭建方式。 kinect in windows]]></content>
      <categories>
        <category>Kinect</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Application For Ubuntu]]></title>
    <url>%2F2019%2F02%2F26%2FApplicationForUbuntu%2F</url>
    <content type="text"><![CDATA[Application For Ubuntuupdate1234$ sudo apt update // 搜索可以更新$ apt list --upgradable // 可以看看有哪些可更新的软件$ sudo apt upgrade // 行更新操作$ sudo apt autoremove //更新完成之后会有一些不需要的旧组件需要清除 VS code安装1234sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-makesudo apt-get updatesudo apt-get install ubuntu-makesudo umake ide visual-studio-code 配置C/C++编译环境 C/C++ VS 更新123$ sudo wget https://vscode-update.azurewebsites.net/latest/linux-deb-x64/stable -O /tmp/code_latest_amd64.deb$ sudo dpkg -i /tmp/code_latest_amd64.deb$ 关闭vs code，然后再次打开会看到release note的页面，说明已经完成更新。 vs code 代码能编译通过，但是头文件全是红色 删除文件夹下的 .vscode 相当于重新建立索引，应该就能解决。 PDF阅读器Okular1$ sudo apt-get install okular Typora1234sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAEsudo add-apt-repository 'deb http://typora.io linux/'sudo apt-get updatesudo apt-get install typora Sougou link 12Download : http://pinyin.sogou.com/linux/ sudo dpkg -i sogoupinyin_2.1.0.0082_amd64.deb Arduino link Extensions 安装 搜索 arduino vs code –&gt; 首选项 –&gt; 设置 –&gt; 搜索arduino –&gt; 设置 arduino.path 123456查看软件安装目录： $ aptitude show sublime-text-installer //列出软件信息 $ dpkg -l //列车所有安装的软件 $ dpkg -l firefox //列出firefox 软件安装信息 $ dpkg -L 软件名 //没有在PATH路径下保存，通过下面命令寻找安装目录 Screenshot ubuntu 自带的截图工具 用用软件进行下载更新 Port Question查看设备的 Serial Devide123cd /devls ttyUSB* //esp32的端口Serial查询ls ttyACM* //arduino 端口的serial Port Permission denied 问题：下载程序到arduino时，端口权限报错。 12Auto-detected: /dev/ttyACM0*** [upload] could not open port /dev/ttyACM0: [Errno 13] Permission denied: '/dev/ttyACM0' ('/dev/ttyUSB0') 重启后权限消失 12给端口权限sudo chmod 666 /dev/ttyACM0 ('/dev/ttyUSB0') 永久权限 123sudo gedit /etc/udev/rules.d/70-ttyacm.rules('/dev/ttyusb') // 添加权限文件KERNEL=="ttyACM[0-9]*",MODE="0666" ('/dev/ttyUSB0') // 添加权限文件reboot Vi 编辑时上下左右键出现字母 ubuntu默认安装装的是vim tiny版本，而需要的是vim full版本。 12$sudo apt-get remove vim-common$sudo apt-get install vim 环境变量的设置 配置/etc/enviroment 1234sudo su // 用户权限vi /etc/enviromentPATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/quronghui/HustFiles/Esp32/crossTools/xtensa-esp32-elf/binsource /etc/enviroment //使之生效 配置 /etc/profile （这个不用配置） 1234sudo su // 用户权限vi /etc/profileexport PATH=/home/yan/share/usr/local/arm/3.4.1/bin:$PATHsource /etc/profile //使之生效 Linux 下的串口 minicom 123456789sudo apt-get install minicomsudo minicom // 需要在root权限下开启minicomctrl-a o //进入端口配置,先按下 Ctrl + a;放开Ctrl + a，按下 oselect ：A //修改端口 和 波特率change : /dev/ttyUSB0select : Save setup as dflctrl-a x // 退出minicon 查看已安装文件的目录 dpkg 12dpkg -l "*sougou*" //来查看软件的状态。dpkg -P //来卸载软件,或者 dpkg --purge完全删除,包括配置文件 查看目录 12ps -e //查看软件对应的名字sudo find / -name "platform" //查询得到软件的目录 设置PlatformIo 串口的波特率单次修改串口波特率12stty -F /dev/ttyUSB0 //查看Usb的属性 stty -F /dev/ttyUSB0 115200 //修改usb的波特率 修改默认值 进入platformIO的python目录 1/home/quronghui/.platformio/penv/lib/python2.7/site-packages/serial/tools 给权限并且修改内容 12345678chmod 777 sudo miniterm.py/*********find***************/parser.add_argument( "baudrate", // 修改波特率这一栏就可以了 nargs='?', type=int, help="set baud rate, default: %(default)s", default=115200) # default这里改成你想要默认的波特率，115200 然后删除本目录下的miniterm.pyc文件，再次开启串口监视器时会重新编译生成此文件。 声卡无声音 Ubuntu 18没有声音 解决方式参考 git clone 速度慢 git clone https:// 克隆的是工程所有的提交历史quronghui 克隆最近一次的commit，然后更新得到所有的提交历史 123$ git clone http://github.com/large-repository --depth 1$ cd large-repository$ git fetch --unshallow 配置shadowsocket git ubuntu18 误删除 /etc/shadow/etc/shadow 是Ubuntu系统的登录和权限认证的文件 保存了密码 如何进行恢复 参考博客 进去recovery 编辑模式 这里不是 Enter选中，而是直按下e 按e进入如下界面，找到图中红色框的recovery nomodeset并将其删掉，再在这一行的后面输入quiet splash rw init=/bin/bash 我的系统后面没有 find_pressed …. 我是加上后才成功的 接着按F10后出现如下界面 1passwd username // 一定要加用户名，不然修改后不能成功 reboot 重启一直报错 1reboot -f 流程图工具 Reference 安装Eagle 安装方式 Autodesk student eagle for Linux 报错 1./eagle: symbol lookup error: /usr/lib/x86_64-linux-gnu/libGLX_mesa.so.0: undefined symbol: xcb_dri3_get_supported_modifiers 安装WPS 下载wps for linux WPS官网下载deb包：http://linux.wps.cn/ wps_symbol_fonts.zip: https://pan.baidu.com/s/1eS6xIzo 安装 1234$ sudo dpkg -i xxx$ cd wps_symbol_fontsls$ sudo cp mtextra.ttf symbol.ttf WEBDINGS.TTF wingding.ttf WINGDNG2.ttf WINGDNG3.ttf /usr/share/fonts$ sudo apt-get remove libreoffice-common 安装Google123$ sudo wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb // download$ sudo dpkg -i google-chrome*$ sudo apt-get -f install Ubuntu 查看目录12345$ sudo snap install tree // 安装tree应用$ tree -a // 像树一样显示目录结构$ tree -d #仅显示目录$ tree -L n #n代表数字..表示要显示几层...$ tree -f #显示完整路径..]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect SDK for ColorImageStream]]></title>
    <url>%2F2019%2F02%2F26%2FKinect%20SDK%20for%20ColorImageStream%2F</url>
    <content type="text"><![CDATA[Kinect SDK for ColorImageStream 网上的知识点 通过安装的SDK包，看相应的代码 下面介绍如何发现以及初始化Kinect传感器，从Kinect的影像摄像头获取图片。 Kinect Sensor 基于Kinect开发的应用程序最开始需要用到的对象就是KinectSensor对象，该对象直接表示Kinect硬件设备。 KinectSensor对象是我们想要获取数据。包括ColorImageStream，DepthlmageStream和SkeletonStream。 从KinectSensor获取数据：通过监听该对象的一系列事件。 每一个数据流以帧(frame)为单位。 每一种数据流都有对应的事件，当改类型数据流可用时，就会触发改时间。 ColorImageStream：触发ColorFrameReady事件 KinectSensor数据流形式 每一种数据流(Color,Depth,Skeleton)都是以数据点的方式，在不同的坐标系中显示的 inectSensor对象有一些列的方法能够进行数据流到数据点阵的转换 123MapDepthToColorImagePoint；MapDepthToSkeletonPoint；MapSkeletonPointToDepth Kinect 设备的发现和引用 通过SDK探测有无Kinect连接 123（1）KinectSeneor对象有一个静态的属性KinectSensors（2）该属性是一个KinectSensorCollection集合，该集合继承自ReadOnlyCollection（3）ReadOnlyCollection集合很简单，他只有一个索引器和一个称之为StatusChanged的事件 Kinect 的初始化 12When : Connect --- 才进行赋值操作 not connect --- KinectSensor对象抛出InvalidOperationException异常 Load and Unload 事件 1234（1）窗口的Loaded事件中程序通过DiscoverKinectSensor方法试图调用一个连接了的传感器（2）窗体的Loaded和Unloaded事件中注册这两个事件用来初始化和释放Kinect对象note : DiscoverKinectSensor方法只有两行代码，第一行代码注册StatusChanged事件，第二行代码通过lambda表达式查询集合中第一个处在Connected状态的传感器对象，并将该对象复制给Kinect属性。Kinect属性的set方法确保能都赋值一个合法的Kinect对象。 StatusChanged事件: 当状态为KinectSensor.Connected的时候，if 语句限制了应用程序只能有一个kinect传感器，他忽略了电脑中可能连接的其他Kinect传感器。 以上代码展示了用于发现和引用Kinect设备的最精简的代码。 Kinect Sensor 的打开和关闭 Connect 初始化传感器 Enable 数据流 ：Color,Depth,Skeleton 数据流使用：使用Kinect对象的一些列事件 1234ColorImageStream ---- ColorFrameReady 事件DepthImageStream ---- DepthFrameReady事件SkeletonStream ---- SkeletonFrameReady事件 AllFramesReady 事件在任何一个数据流状态enabled时就能使用 应用程序调用KinectSensor对象的Start方法 frame-ready事件就会触发从而产生数据 Stop Kinect 先检测Kinect sensor 是否为空；然后监听frameready事件 1Using KinectSensor对象的 : Stop ways 应用程序在不需要使用KinectSensor对象时，释放这些资源 12Stop ways 注销frameready事件 Notes (1)不要去调用KinectSensor对象的Dispose方法。这将会阻止应用程序再次获取传感器。 (2)应用程序必须从启或者将Kinect从新拔出然后插入才能再次获得并使用对象 ColorImageStream 的获取 初始化和释放KinectSensor和ColorImageStream对象 12345if (value!=null&amp;&amp;value.Status==KinectStatus.Connected)&#123; this.kinect=value; InitializeKinectSensor(this.kinect);&#125; InitializeKinectSensor对象 ：调用ColorImageStream的Enable方法，注册ColorFrameReady事件并调用start方法。 一旦打开了传感器，当新数据帧大道是就会触发frameready事件，该事件触发频率是每秒30次。 123456if (kinectSensor != null) &#123; kinectSensor.ColorStream.Enable(); kinectSensor.ColorFrameReady += new EventHandler&lt;ColorImageFrameReadyEventArgs&gt; (kinectSensor_ColorFrameReady); kinectSensor.Start(); &#125; 数据显示 ）ColorFrameReady方法中：打开或者获取一个frame来提取获Frame数据。 ）ColorImageFrameReadyEventArgs对象中的OpenColorImageFrame属性：返回一个当前的ColorImageFrame对象。 ）ColorImageFrame对象：提取像素数据之前需要使用一个Byte数组保存获取到的数据。 ）FrameObject对象的PixelDataLength对象返回数据和序列的具体大小。 ）调用CopyPixelDataTo方法可以填充像素数据，然后将数据展示到image控件上。 图像数据获取方式的改进 知识参考 WriteableBitmap对象 它位于System.Windows.Media.Imaging命名空间下面，该对象被用来处理需要频繁更新的像素数据。（之前是更新30幅图像 / 每秒） 创建WriteableBitmap时，应用程序需要指定它的高度，宽度以及格式，以使得能够一次性为WriteableBitmap创建好内存，以后只需根据需要更新像素即可。 图像的处理 每一帧ColorImageFrame都是以字节序列的方式返回原始的像素数据：对这些原始数据进行一定的处理，然后再展示出来。 for循环遍历每个像素，由于数据的格式是Bgr32，即RGB32位(一个像素共占4个字节，每个字节8位)，所以第一个字节是蓝色通道，第二个是绿色，第三个是红色。 循环体类，将第一个和第二个通道设置为0.所以输出的代码中只用红色通道的信息。这是最基本的图像处理。 截图 可能需要从彩色摄像头中截取一幅图像，例如可能要从摄像头中获取图像来设置人物头像。为了实现这一功能，首先需要在界面上设置一个按钮。 图片数据格式介绍 ImageStream是ColorImageStream的基类。因此ColorImageStream集成了4个描述每一帧每一个像素数据的属性。在之前的代码中，我们使用这些属性创建了一个WriteableBitmap对象。这些属性与ColorImageFormat的设置有关。 ImageStream中除了这些属性外还有一个IsEnabled属性和Disable方法。IsEnabled属性是一个只读的。当Stream打开时返回true，当调用了Disabled方法后就返回false了。Disable方法关闭Stream流，之后数据帧的产生就会停止，ColorFrameReady事件的触发也会停止。 当ColorImageStream设置为可用状态后，就能产生ColorImageFrame对象。ColorImageFrame对象很简单。他有一个Format方法，他是父类的ColorImageFormat值。他只有一个CopyPixelDataTo方法，能够将图像的像素数据拷贝到指定的byte数组中，只读的PixelDataLength属性定义了数组的大小PixelDataLength属性通过对象的宽度，高度以及每像素多少位属性来获得的。这些属性都继承自ImageFrame抽象类。 数据流的格式决定了像素的格式，如果数据流是以ColorImageFormat.RgbResolution640480Fps30格式初始化的，那么像素的格式就是Bgr32，它表示每一个像素占32位(4个字节)，第一个字节表示蓝色通道值，第二个表示绿色，第三个表示红色。第四个待用。当像素的格式是Bgra32时，第四个字节表示像素的alpha或者透明度值。如果一个图像的大小是640480，那么对于的字节数组有122880个字节(widthheightBytesPerPixel=6404804).在处理影像时有时候也会用到Stride这一术语，他表示影像中一行的像素所占的字节数，可以通过图像的宽度乘以每一个像素所占字节数得到。 ImageStream 数据获取的方式事件模式 目前为止我们都是使用KinectSensor对象的事件来获取数据的。事件在WPF（为不同用户界面提供统一的显示系统（ Windows Presentation Foundation））中应用很广泛，在数据或者状态发生变化时，事件机制能够通知应用程序。 “拉”模式 采用拉模式获取数据的性能应该好于事件模式。 唯一不能使用事件模型获取数据的情况是在编写非WPF平台的应用程序的时候。比如，当编写XNA或者其他的采用拉模式架构的应用程序。建议在编写基于WPF平台的Kinect应用程序时采用事件模式来获取数据。只有在极端注重性能的情况下才考虑使用“拉”的方式。]]></content>
      <categories>
        <category>Kinect SDK</category>
        <category>Kinect</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect in Ubuntu]]></title>
    <url>%2F2019%2F02%2F20%2FKinect%20in%20Ubuntu%2F</url>
    <content type="text"><![CDATA[OpenKinect Application for UbuntuOpenKinect on linux 环境搭建 OpenKinect/libfreenect libusb的安装 Download libusb &gt;= 1.0.18 安装过程 ./configure执行报错时 1./configure --build=x86_64-linux --disable-udev sudo make install Use 提示安装好了lib，目录所在。 1make[1]: 离开目录“/home/quronghui/Kinect/libusb-1.0.22” 所以我们基于libusb编程的时候，需要包含这个库 */ 编译时加上 –lusb-1.0 就是这个原因，库放在这个目录下，需要链接上。 CMake安装方法 Download : Source Distribution 或者 Binary Distribution，前者是源代码版，你需要自己编译成可执行软件。后者是已经编译好的可执行版，直接可以拿来用的。 安装教程 Python3 安装方法 参考教程 下载Python3 时候特别的慢，一直在等。 Libfreenect 安装 编译 1234567git clone https://github.com/OpenKinect/libfreenectcd libfreenectmkdir buildcd build // 在这之后的操作需要插入设备 // 尽量带sudo ,不然会少安装一些东西sudo cmake -L .. # -L lists all the project optionssudo make 更新依赖库 12sudo apt-get install git cmake build-essential libusb-1.0-0-devsudo apt-get install freeglut3-dev libxmu-dev libxi-dev 测试设备 12cd build/binsudo ./freenect-glview QTGUI for linuxKinect for WindowsKinect SDK 安装 Bug 首次安装KinectSDK-v1.8-Setup]]></content>
      <categories>
        <category>Kinect</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect in Windows]]></title>
    <url>%2F2019%2F02%2F20%2FKinect%20in%20Win%2F</url>
    <content type="text"><![CDATA[[TOC] Kinect in Windows Kinect in Windows 开发指南 kinect + opencv + vs 环境配置 安装 Kinect SDK Bug 首次安装KinectSDK-v1.8-Setup 连上kinect后，打开一次后，第二次打开提示 “ No kinet to connect ” 重新卸载后，安装KinectSDK-v1.7-Setup，成功 在官方网站下载Kinect for Windows SDK和Developer Toolkit： 参考教程 KinectSDK-v1.7-Setup.exe KinectDeveloperToolkit-v1.7.0-Setup.exe 安装成功后，连上kinect, 设备管理器出现 “ Kinect for windows ” 通过kinect tools 测试 XBox的好坏 安装 Visual StudioVS2017 安装教程 Download Visual Studio Community免费版 选择工作负载这里仅勾选”使用C++的桌面开发”，单个组件和语音包使用默认 按照需要选择要安装的模块（但是我下载后没有已安装的选项） VS2017的文件目录 C:\Users\quronghui\source\repos 安装注意 直接安装VS2017，并且卸载完之前安装的VS2015版本（如果可以的话直接升级） 我的是因为之前安装的VS2015 ios镜像不成功，卸载不完全，导致的系统重装. Mircosoft 的软件安装的时候，不要中途暂停，不然容易造成卸载不了的问题 解决方案 重装系统后，直接安装VS2017，这样就不会报错了 因该是以前装VS其他版本没有卸载干净，导致的后果 Kiinect SDK 关于 VS 的配置 Kiinect SDK 关于 VS 的配置 使用VS进行开发的话，需要配置include和lib路径 进入VS，右键-项目属性，Debug + x64，选择VC++Directories: 1234Debug and Release 都要添加 Include files : add C:\Program Files\Microsoft SDKs\Kinect\v1.7\inc； Library files : add C:\Program Files\Microsoft SDKs\Kinect\v1.7\lib\x64； 链接器 : add Kinect10.lib C:\Program Files\MicrosoftSDKs\Kinect\v1.6\inc 目录下有： 1234- NuiApi.h ---包含所有的NUI(自然用户界面) API头文件和定义基本的初始化和函数访问入口。这是我们C++工程的主要头文件，它已经包含了NuiImageCamera.h 和 NuiSkeleton.h。- NuiImageCamera.h ---定义了图像和摄像头服务的API，包括调整摄像头的角度和仰角，打开数据流和读取数据流等。- NuiSkeleton.h ---骨架有关的API，包括使能骨架跟踪，获取骨架数据，骨架数据转换和平滑渲染等。- NuiSensor.h ---音频API，包括ISoundSourceLocalizer接口，用于返回声源的方向（波束形成）和音频的位置。 安装 OpenCV 本次安装的opencv，是为了迁移上一个工程师的代码，所以opencv的版本需要一致才能编译成功。 opencv 2.4.6.0，vc10 提取码：f3pz Opencv 的安装和配置教程 Opencv 的安装 我是直接复制工程师的 opencv 解压包，只是进行依赖链接的配置。 环境变量 Opencv Start Dll 文件的复制 dll 文件都在安装的opencv的 bin 目录下 12copy : opencv_ffmpeg .dll to C:\Windows\System32copy : opencv_other .dll to C:\Windows\SysWOW64 Opencv With VS2017 VS 属性中（ Include Direction）: 12345Include Direction： C:\Software\opencv\opencv\includeC:\Software\opencv\opencv\build\include\opencvC:\Software\opencv\opencv\build\include\opencv2C:\Software\opencv\freetype\include // 为了在opencv里面检测的图片上加上字 VS 属性里面的 库目录 12Library Direction: C:\Software\opencv\opencv\build\x64\vc10\lib VS 属性 – 链接器 – 输入项 – 附加依赖项 1234567" **在 Debug x64 下面进行配置**"Link : opencv_core246d.lib // lib 库下面 opencv_xxx "d" : 代表的是Debug版本使用的库 opencv_highgui246d.lib opencv_video246d.lib opencv_imgproc246d.lib opencv_photo246d.lib 1234567" **切换 Release x64 下面进行配置**"Link : opencv_core246.lib // lib 库下面 opencv_xxx : 代表的是Release版本使用的库 opencv_highgui246.lib opencv_video246.lib opencv_imgproc246.lib opencv_photo246.lib 安装QTQT 的安装 安装方式 1234Notes: QT组件的选取： MSVC 2017 64-bit : VS2017 的QT编译器 MinGW 5.3.0 32 bit : gcc 的编译器吧 QT with VS2017 配置方式 Notes 123456VS 属性 -- 链接器 -- 输入项 -- 附加依赖项 ：加入QT. lib如果报错再加入： qtmain.lib Qt5Core.lib Qt5Gui.lib Qt5Widgets.lib 代码迁移后需要改动VS 的项目 – 配置属性 VC ++ 目录 ： 下面的包含目录和库目录。 注意修改迁移项目的目录链接。 （之前背的工程师的SDK or opencv 放在其他的目录下） Qt Meta-Object Complier: Include Path C/C++ 目录 常规 – 附加包含目录： 所有选项 – 附加包含目录 计算机中丢失 MSVCP100D.dll 代码迁移后，会报计算机中丢失 MSVCP100D.dll 解决方案：去对应工程师的电脑下，拷贝MSVCP100D.dll download提取码：fkvr 12copy xxx.dll files to C:\Windows\SysWOW64 copy xxx.dll files to C:\Windows\System32 VS2017 项目打包部署（.exe files） 参考链接 Vs的部署方式 部署连接，Mircosoft官网 Vs + Qt 的应用程序发布部署 通过编译Release 得到可执行文件exe，生成相关可执行文件 将需要发布的exe（Release ）文件编译后（如QtGuiApplication1.exe），放到单独的目录。 在“开始菜单”启动Qt 5.9.1 32-bit for Desktop (MSVC 2015); Win + R 进去 cmd编辑； cd C:\Software\kinect\QtGuiApplication1\x64\Release 进入 exe 文件的目录 执行命令 1windeployqt.exe QtGuiApplication1.exe --qmldir C:\Qt\Qt5.12.1\5.12.1\msvc2017_64\qml 生成运行时需要的文件。（源程序发生改变，需要重新生成一次） Vs 2017的依赖库 123456789进入路径C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\Remote Debugger\x64拷贝文件api-ms-win-core-* concrt140.dllmsvcp140.dllucrtbase.dllvcruntime140.dll粘贴到 *步骤一的目录下* 这样迁移到相同屏幕尺寸的电脑下，就可以运行了。 如果出现Qt提示的文字超出界面，修改字体的大小就能自适应平板了。 增加语音功能 增加语音功能，实现特定语句的播放]]></content>
      <categories>
        <category>Kinect</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SerialCommunication]]></title>
    <url>%2F2019%2F02%2F19%2FSerialCommunication%2F</url>
    <content type="text"><![CDATA[GPIO，I2C，SPI，UART，USART，USB的区别GPIO（General Purpose Input Output ） 系统需要采用远端串行通信或控制时，GPIO产品能够提供额外的控制和监视功能。 SPI (Serial Peripheral Interface) 是一种标准的四线同步双向串行总线。 SPI接口主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。 芯片 – 间的高效通信 数据线 串行时钟(SCLK)、串行数据输出(SDO)、串行数据输入(SDI) SPI总线：一个Master，多个Slave设备 主从设备间可以实现全双工通信 通用IO口模拟SPI总线 主从设备：必须要有一个输出口(SDO)，一个输入口(SDI)， SCLK则视实现的设备类型而定 SPI 通信协议 一个主设备启动一个与从设备的同步通讯的协议，从而完成数据的交换 与普通的串行通讯不同，普通的串行通讯一次连续传送至少8位数据，而SPI允许数据一位一位的传送 至少8次时钟信号的改变（上沿和下沿为一次），就可以完成8位数据的传输 主设备通过对SCK时钟线的控制可以完成对通讯的控制 I2C (INTER IC BUS) 是一种集成电路间的总线标准，用于连接微控制器及其外围设备 非常适合在器件之间进行近距离、非经常性的数据通信 数据传输 传输数据时都会带上目的设备的设备地址，因此可以实现设备组网。 双向、两线(SCL、SDA)、串行、多主控（multi-master）接口标准 通用IO口模拟IIC总线 则需一个输入输出口(SDA)，另外还需一个输出口(SCL) I2C通信协议 接到总线的器件都可以通过唯一的地址和一直存在的简单的主机从机关系软件设定地址主机可以作为主机发送器或主机接收器 UART(Universal Asynchronous Receiver Transmitter) 通用异步接收/发送装置。 复杂 : 异步串口，因此一般比前两种同步串口的结构要复杂很多，半双工通信 数据线 一般由波特率产生器(产生的波特率等于传输波特率的16倍)、UART接收器、UART发送器组成 通用IO口模拟UART总线 需一个输入口，一个输出口 USART 通用同步异步收发器； USB：Universal Serial BUS 通用串行总线 CAN 现场总线]]></content>
      <categories>
        <category>Communication</category>
      </categories>
      <tags>
        <tag>SerialCommunication</tag>
        <tag>Electronic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言入门]]></title>
    <url>%2F2019%2F02%2F19%2FLinuxC%2F</url>
    <content type="text"><![CDATA[Linux C编程一站式学习 LinuxC 课后习题答案 LinuxC.pdf 文档中的代码 C语言入门 程序的五个步骤 math函数的gcc编译 12$ gcc math.cpp -o math -lm // math的编译要加上 "-lm"$ gcc hello.c -o hello -Wall // gcc编译带上 -Wall,显示所有警告的信息 [UNIX编程艺术] The Art of UNIX Programming. Eric Raymond. 全局/局部变量 虽然方便，但是要慎用，能用函数传递参数的就不要使用全局变量 局部变量可以用任意类型相符的表达式来初始化,而全局变量只能用常量表达式初始化。 Debug 如果全局变量在定义时不初始化,则初始值是0。但是局部变量不初始化时，初值就不确定，局部变量先赋值 if/else else 总是和最近的一个if配对 如果需要隔开的话，加 “ { } ” 隔开 Debug Ways 增量式开发：通过printf的方式，一步步打印结果查看 printf (“ “) // 通过打印进行调试 递归函数：要加上 Base Case 12345int factorial(int n)&#123; if (n == 0) //也就是0项 return 1;&#125; 递归和循环是等价的; 用循环能做的事用递归都能做 循环函数 循环函数:相当于将函数表达式展开，然后通过while()，进行循环的迭代 do / while 的格式 123do 语句；while(); // while 后面有个分号 Break and Continue break : 跳出当前循环体，执行后面的语句； Continue : 终止本次循环(循环里面的内容，在continue之后的语句都不执行)，然后回到循环体的开头准备再次执行循环体。 表达式的左值和右值 由 “ = ”进行连接 左边：表示的是存储位置；— 称为左值 右边：表示要存储的值；– 称为右值 C 中的输入输出 printf 语句打印 1printf(" %g ") // 打印一个浮点值 格式化的输入输出 12scanf("%d", &amp;i);printf("%d", i); 字符：非格式化 12getchar();putchar(); goto 跳转语句 goto : 实现无条件的跳转 我们知道break 只能跳出最内层的循环 如果在一个嵌套循环中遇到某个错误条件需要立即跳到循环之外的某个地方做出错处理,就可以用goto 语句。 语法 12345678for (...) for (...) &#123; ... if (出现错误条件) goto error; &#125;error: 出错处理; error 叫做标号lable，给标号起名字也遵循标识符的命名规则。 goto的限制 goto 语句过于强大了,从程序中的任何地方都可以无条件跳转到任何其它地方,只要给那个地方取个标号。 唯一的限制是goto 只能跳到同一个函数的某个标号处,而不能跳到别的函数里面。 不推荐使用goto 数据1.]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO Github]]></title>
    <url>%2F2019%2F02%2F18%2FHEXOGithub%2F</url>
    <content type="text"><![CDATA[Linux 下HEXO + Github 搭建博客HEXO 环境搭建流程 HEXO 环境搭建流程 安装Nodejs 和 npm 正式安装Hexo 初始化文件夹 hexo init Github 的部署 github 上建立repository ； 命名为 username.github.io; 修改hexo 目录下的_config.yml 12345修改hexo 目录下的_config.yml deploy: type: git repository: https://github.com/quronghui/quronghui.github.io.git branch: master 配置github 12$ git config --global user.name "yourName"$ git config --global user.eamil "email@example.com" HEXO 主题的修改 使用 NEXT主题 更改主题配置文件(NEXT)中的，站点配置文件_config.yml 动态效果还未实现 官方NEXT的配置文档 avatar 下添加头像 Hexo的Next主题详细配置 HEXO 博客分支备份 参考教程 在 hexo 博客文件夹下，创建两个分支（Github 的部署, 修改_config.yml时，只是添加git的源在里面，没有进行add 或者clone，因此没有master主分支） 12$ git branch dev(master) // 创建分支,dev只是分支名字$ git checkout dev(master) // 分支切换（也就是设置默认分支） clone 博客文件到本地，git clone https://github.com/quronghui/quronghui.github.io.git 将之前的hexo文件夹中的文件 ，复制至username.github.io文件夹，为了进行一次分支提交； 123456_config.ymlthemes/source/scaffolds/package.json.gitignore 将themes/next/ 下的.git/删除，否则无法将主题文件夹push； 123delete : themes/next/ 下的.git/删除 两个地方都删除 在username.github.io 下创建分支dev , 并且切换分支dev 这样以后就在username.github.io 下工作 123456分支： git branch dev git checkout devinstall sudo npm install sudo npm install hexo-deployer-git --save 提交文件到分支dev上。 123git add -A ;git commit -m "" ;git push origin dev ; 部署至Github上 12hexo ghexo d HEXO 博客迁移 主要是需要重装一遍环境 安装git； 安装Nodejs和npmwin； 使用`git clone -b hexo https://github.com/quronghui/quronghui.github.io.git 将仓库拷贝至本地； 在文件夹内执行以下命令 123ubuntunpm install hexo-cli -gnpm installnpm install hexo-deployer-git HEXO 博客分支问题 在quronghui.github.io 文件夹下进行提交的时候，产生了很多冲突。因此，我直接删除hexo文件夹。 使用clone将仓库拷贝至本地； 1git clone -b hexo https://github.com/quronghui/quronghui.github.io.git 在文件夹内执行以下命令 12sudo npm installsudo npm install hexo-deployer-git 这样相当于在本地重建环境 HEXO关于Tags 点击无反应 参考链接 添加标签 ： hexo new page tags 确定配置文件中，大小写一致 确认站点配置文件里有tag_dir: tags 确认主题配置文件里有tags: /tags 编辑站点的source/tags/index.md，添加 1234title: tagsdate: 2015-10-20 06:49:50type: "tags"comments: false HEXO 添加搜索 npm install hexo-generator-searchdb –save 修改站点配置文件 12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件 123hemes/next下的_config.yml文件local_search: enable: true## HEXO 添加搜索 HEXO 修改默认生成的文档界面 站点配置文件_config.yml查看 1default_layout ：post 修改 123456/scaffolds/post : 修改默认页面 layout: post title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125; categories: tags: 新建页面 使用 hexo new post &lt; name &gt; HEXO 文章引用pdf – 可查看 安装pdf插件 1npm install --save hexo-pdf 本地存在的pdf 121. 将pdf文件放在 /source/_post/name 下2. 文档中使用 &#123;% pdf ./pdf名字.pdf %&#125; 网上链接 1&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125; HEXO 添加本地文件下载 调整程序配置文件_config.yml 里的post_asset_folder:这个选项设置为True 在source下创建/document文件夹 12mkdir document把文件复制到这个文件夹 在 .md 中引入 [ name ]（/ document /name.ppt） HEXO markdown文档添加多个分类 添加子分类 123categories: - Java - Servlet 添加多个分类 123categories: -[Java] -[Servlet] Hexo 的侧边栏，显示错误 问题描述：Search 显示成了Suche]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>linux hexo github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18 And Win10]]></title>
    <url>%2F2019%2F02%2F18%2FLinuxAndWin10%2F</url>
    <content type="text"><![CDATA[Win10 + Ubuntu 双系统Win10 + Ubuntu环境的搭建 参考链接 有些工作需要切换windows,因此才搭建了双系统。 主机环境是SSD+HDD 压缩卷的时候，不用压缩SSD，找一个大一点的机械硬盘，直接将其状态删除为未分配的状态。 准备工作 下载UltralSO，这是用来制作启动盘的软件 下载Linux系统的镜像ubuntu16.04，可以在官网上下载 （可选）下载启动项编辑工具[EasyBCD] windows系统下进行分盘 我的电脑–计算机管理–压缩的磁盘–右键–压缩卷 选择未分配区域，右键选择“新建卷“ – 右键“删除卷”可以将这变成可用空间 制作ubunut启动盘 打开UltraSO软件，选择“文件”-“打开”打开之前下好的iso映像文件 选择“启动”-“写入硬盘映像”。此处注意选择正确硬盘驱动器。 依次点击“格式化”和“写入”，完成后它会在消息处提示“刻录成功！” 设置window 下的BIOS 关闭快速启动。选择控制面板-电源选项-选择电源按钮的功能，选择“更改当前不可用的设置”，取消选中“启用快速启动” 安装ubuntu 在下一步之前，一定要先联网，会进行下载 选择 安装音频相关软件…… Ubuntu 工具的安装 参考链接 用到的时候直接搜索]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>linux win10 双系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArduinoMQ135]]></title>
    <url>%2F2019%2F02%2F17%2FArduinoMQ135%2F</url>
    <content type="text"><![CDATA[口气检测仪项目报告 基于Arduino和MQ135硫化物传感器，实现口气检测 [TOC] 1. 总体实现描述 人呼出的气体中含有多种痕量挥发性硫化物 , VSCs中硫化氢、甲硫醇和二甲基硫醚的量与口臭的强弱直接相关。这些化合物通常与人体健康及代谢过程相关, 一般分为口腔性和非口腔性, 其中90%来源于口腔，目前监测这种变化的方法目前有: (1) 感官分析法, 即鼻测法; (2) 仪器分析法:气相色谱法、气相色谱质谱联用法、硫化物分析仪 (Halimeter) 法、便携式气相色谱口臭测量仪。本产品主要是根据人体呼出气体中硫化物的浓度进行评判的。 本产品基于Arduino作为主控，通过其模拟通道，结合MQ135传感器，对人体呼出的气体中硫化物的浓度进行采集，（人体口气中的成分如如图）对浓度值进行AD转换，对得到的浓度值进行等级的划分，最后得到用户口气检测的等级，用户通过等级查看小程序的相关建议，从而得到口腔保护的建议。 ​ 产品设计总的流程框架图如下所示: ​ 2. 硬件平台搭建2.1 主控Arduino 主控选择开源硬件Arduino, 使用AD转换的模拟通道进行MQ135的检测，数字通道检测按键的状态，IIC通信方式显示检测过程中的浓度大小。 ​ 2.2 传感器 MQ135 传感器检测口气中可挥发性硫化物，使用的是电导率较低的二样化锡SnO2，电导率随空气中污染气体浓度的增加而增大，输出一个模拟电压，主控arduino的AD采样值进行采样，并将电压值映射10-1000ppm之间的浓度。 ​ 2.3 显示OLED 采用IIC的OLED显示屏，对检测过程中的浓度进行动态显示，并且能显示以前检测的浓度值。 ​ 2.4 按键设计 按键设计了两部分： （1）按键一：按下时开始进行口气检测，并在OLED上动态实现；当按键弹起的时候，OLED上固定显示本次检测的最大浓度值和评价等级； （2）按键二：按下的时候，显示第几次检测，检测的口气浓度值大小和等级。 2.5 供电 锂电池供电，提供充电模块。 3. 软件平台搭建 完整源码：https://github.com/quronghui/Arduino 3.1 MQ135浓度采样 通过map()函数，对采样的电压值进行映射，得到浓度值。将MQ135输出的电压值（0.1-0.3V – 4V）映射成浓度（10-1000 ppm）。 1long mapping(long x, long in_min, long in_max, long out_min, long out_max); // 函数的映射 3.2 存储采样数据 通过数据对MQ135每次采样数据的存储，通过排序得到本次检测的最大浓度值，实现按键一（中断0）的功能。 12void MemoryData(); // 采样数据的存储，存储到数据；void max(); // 排序得到最大值 3.3 EEPROM 存储本次检测的等级和浓度值 为了用户能查阅以前检测的等级，设计EEPROM函数，对每次检测的等级和浓度值进行保存，当按键二（中断1）按下时后，显示第几次检测，检测的口气浓度值大小和等级，实现按键二的功能。 12345// EEPROM 存储的函数声明void EepromWriteMaxArray(int EEP_data); // 写入每次检测到的最大浓度值EEPROM存储器,void EepromWriteGrade(int grade_data); // 写入每次检测的等级值void EepromRead(); // 从EEPROM存储器读出数据void EepromClear(); // 清除EEPROM里面的数据 3.4 OLED显示 采用IIC通信方式，动态显示每次检测的浓度值，以及显示EEPROM 存储的检测值，满足按键一和按键二的需求。 12345678// 对每一次数组的采样值进行OLED显示u8g.firstPage(); //一下是显示实现部分do &#123; u8g.setFont(u8g_font_fub30); //设置字体和自号，目前测试字号有fub14,17,20,30 u8g.setPrintPos(0, 50); //显示的位置 u8g.print(array[i]); //显示变量i的值&#125; while( u8g.nextPage() );delay(500); 3.5 浓度等级评定 浓度等级的评定，主要是根据MQ135的检测结果，和人体承受硫化物浓度的范围进行设定的，根据需求将测量的浓度等级分为5大块，具体设定参考下图。 1234567int MQgrade(int temp); // 进行等级的评定int score[] = &#123; &lt;30, // grade = 0 未检测 40,45,50, // grade = 1-3 轻微 55,65,70, // grade = 4-6 中度 75,85,90, // grade = 7-9 重度 &gt; 100 // grade =100 检测其他物体/或者传感器没有正常连接 &#125;; ​ 4. 实现效果图 实现效果图主要分为以下三部分：（1）动态检测的浓度值；（2）本次检测的最大浓度值和浓度等级；（3）显示EEPROM 存储的检测值，显示第几次检测，检测的口气浓度值大小和等级。 (1) 按键一按下后，显示口气检测仪的动态浓度采样值 (2) 按键一弹起后，固定显示本次口气检测的最大浓度值和等级 (3) 按键二：按一次，显示第几次检测（T），检测浓度大小（ppm），评价等级（G） 5. 总结注意 MQ135传感器的特性，要求预热足够的时间，40小时以上，检测的浓度值才会稳定。 口气检测仪开始检测时，要进行通电预热，待稳定的时候在进行检测。 由于MQ135的材料特性，每个传感器预热后的初值都不太相同，因此为了检测的灵敏度要求，需要手动调整一下代码。 6. 价格 物料 / 个 价格 / 元 链接 Arduino Pro Mini 10.9 智能创客科技 MQ135 9.23 risym旗舰店 OLED 22.99 telesky旗舰店 PCB制板 5 嘉利创 锂电池 13 海兄弟锂电池 其他电容电阻和接插件]]></content>
      <categories>
        <category>Product</category>
      </categories>
      <tags>
        <tag>arduino</tag>
        <tag>MQ135</tag>
        <tag>OLED</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Direction]]></title>
    <url>%2F2018%2F12%2F25%2FElectronicDirection%2F</url>
    <content type="text"><![CDATA[Computer Direction 为何要为开源做贡献 怎么查找开源项目 Contents[TOC] 计算机相关工具 相关工具类型 名称/作用 myself Github 上的Awesome awesome : 强大的收集网站，能找到对应的模块 awesome-electronics : 嵌入式的一些相关网站 electronics AutoDesk student 免费使用的软件； Eagle : PCB软件，里面含有各大公司的封装库 Adobe Creative Cloud Adobe Creative Cloud desk，从而安装 Illustrator (AI的矢量图) 计算机相关书籍 搜索下载：基本上是高清的 [极客侠栈] 网页上直接搜索： xxx. epub xxx.pdf 网上的资源很多，我们需要一把钥匙，能够将这些资源灵活的用起来 书籍类型 书籍名称/介绍 是否阅读 计算机技术 计算机科学速成课 : 从嵌入式的元件，到计算机的整体架构；推荐 OK 嵌入式 面试相关 LinuxC LinuxC 编程一站式学习 : C 和 linux 的入门书籍 OK C和指针.pdf :和剑指offer一起刷的，指针讲的很好 2019. 6.25 C专家编程.pdf) C Primer Plus第6版) : 用于在手边查阅 Shell 编程范例 C 语言编程透视 数据结构算法 数据结构与算法教程，数据结构C语言版教程 ：这个网址有基础知识和相应的代码； 大话数据结构) 基础数据结构 算法图解 基础算法 [剑指offer] ( 结合C和指针一起看，可以编写测试代码) [编程之美] 这本书的作者，绝大部分都是微软的工程师，所以质量很有保证。算法题目稍微有点难，也不是很系统，这也是为什么我把它归到面试这一部分的原因。 编程珠玑 2 这本书最大的特色是讲了很多针对海量数据的处理技巧 [数据结构与算法分析：C语言描述原书第2版高清版.pdf] 2019. 5.27 算法导论原书第3版 充斥着各种算法的正确性、复杂度的证明、推导，数学公式比较多 算法 更容易看懂，更适合初学者入门。 计算机程序设计艺术 殿堂级的 凸优化，算法优化 操作系统 操作系统导论 现代操作系统 原书第4版: 提取码：j5p9 编程中的线程一直是很难理解的概念，通过理解操作系统的原理，线程的概念就很容易理解了 linux就该这么学 鸟哥的Linux私房菜-基础学习篇(第四版)高清完整书签PDF版.pdf 最经典的Linux系统管理和使用教程 Linux内核完全剖析 非常细致全面的一本书 linux 程序设计 深入理解Linux 内核) Orange’S:一个操作系统的实现 大神带你实现一个操作系统 UNIX操作系统设计 深入浅出 嵌入式OS FreeRTOS / uCOS) : 嵌入式实时操作系统； 嵌入式系统LINUX / VXWORKS 对计算机系统结构（CISC/RISC）了解到 了解bootload、kernel等启动流程 计算机网络 [图解TCP/IP 第5版 tcpip协议应用分析指导指南 TCP/IP圣经级教材 268张图解轻松入门 [一本书读懂TCP/IP] TCP/IP详解 卷1 学习TCP/IP协议的圣经 TCP/IP详解 卷2：实现 下载第一卷讲理论，第二卷讲实践 TCP/IP详解 卷3：TCP事务协议、HTTP、NNTP和UNIX域协议 下载 计算机网络 系统方法 计算机网络 自顶向下的方法 UNIX网络编程 学习套接字编程最好的书籍 数据库 设计模式 《大话设计模式》 本书适合编程初学者或希望在面向对象编程上有所提高的开发人员阅读。 [STL 源码剖析] 代码大全（第2版） 下载 程序员必读经典 PCB 高质量PCB设计入门 ：PCB SCH 绘制规则参考ESP32 OK 其他 程序员的自我修养 下载 硅谷之火_——个人计算机的故事.pdf [硅谷之火——PC从梦想到现实.pdf] [黑客与画家] [浪潮之巅.pdf] 嵌入式学习方向 CPU 方向： 计算机 / SOC 架构； 脚本语言，Python 优先； 物联网方案 悉 TCP 与 UDP 的特点与使用，了解 Wi-Fi / 蓝牙协议优先； FreeRTOS / uCOS 等嵌入式系统优先； 熟悉脚本语言，掌握 Python 优先； 熟悉计算机网络协议熟悉 802.11 协议或蓝牙协议优先； 熟悉 GCC 和 GDB； 熟悉系统外围驱动（I2C、SPI、UART、485）和应用的编程 Tools[github] GitHub Trend 页面总结了每天/每周/每月周期的热门 Repositories 和 Developers，你可以看到在某个周期处于热门状态的开发项目和开发者。 GitHub Topic 展示了最新和最流行的讨论主题，在这里你不仅能够看到开发项目，还能看到更多非开发技术的讨论主题， 优秀的项目 free-programming-books：整理了所有和编程相关的免费书籍，同时也有 中文版项目。 github-cheat-sheet：集合了使用 GitHub 的各种技巧。 android-open-project：涵盖 Android 开发的优秀开源项目。 chinese-independent-developer：聚合所有中国独立开发者的项目。 Autodesk 选择地区是中国的，为了后面的学校验证 { % aeest_img autodesk.png % } 用学校邮箱创建账户，进行验证 进入免费软件一栏，可以看到免费软件 { % aeest_img autodesk_free.png % } Eagle PCB绘制工具，相对于AD来说更加轻量级，而且有大量的封装库。 申请免费的Eagle { % aeest_img eagle.png % } 学习【高质量PCB设计入门–Eagle使用】 Adobe Creative Cloud Adobe Creative Cloud 通过安装Adobe Creative Cloud desk，从而安装 Illustrator (AI的矢量图) Illustrator 能够绘制矢量图，从而导入到 Eagle. Eagle : 不能写中文，而且图形不是矢量的。 Open Link IT Community stackoverflow ：IT与程序相关的IT技术问答网站 element : IT的互助社群 Lmos社区 China IT Community CSDN ：国内IT的博客分享平台 开源中国 ：中国最大的开源IT社区 IT article INfoQ UI Design UI dribbble UI Behance Vector ICONS FlatIcon : 有版权限制的矢量图标 iconfont : 矢量图标 Security Community 看雪论坛 : 致力于PC、移动、智能设备安全研究及逆向工程的开发者社区 吾爱破解：论坛致力于软件安全与病毒分析的前沿,丰富的技术版块交相辉映,由无数热衷于软件加密解密及反病毒爱好者共同维护 [ i 春秋 ]注网络安全、信息安全、白帽子技术的在线学习,教育、培训的平台 Emebadded Community hackaday ： Hardware open source items hackster ：Hardware open source store Cadlab.io ： 可以使用github push 的可视化图形软件 Crowdfunding Community kickstarter ：众筹项目 indiegogo : 众筹项目 modian : 中国的众筹项目 Hacker New ：世界的重要新闻 RSS (Really Simple Syndication) inoreader : RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合）。 feedly : Feedly是一款第三方RSS阅读器，在经过了几次更新后，已经有比较多的忠实的使用者。 第一次访问Feedly的用户，Feedly会自动提示接入 Google Reader的访问权限，无需注册新会员. 能够增加我们之前的Open Source PDF Transform Doc https://pdf2doc.com/ Algorithm visualization* https://visualgo.net/zh : 算法可视化的工具，用于展示算法的好工具 UART HMI 通过串口发送，就之间显示出对应的图形和数据 在显示屏上显示二维码就可以用。 与非网：一些嵌入式的前沿 可能你已修炼成资深行业观察家，如何小庆老师那样真知灼见； 可能你善于分析行业趋势，如飞翔的鸭子侃侃而谈； 可能你精通某一项技术，如加菲那样精讲技术而不失幽默； 可能你善于发现身边的工程师故事，如骆驼般娓娓道来。 github 优秀的用户 github 上搜索 awesome-xxxx Cheng Zheng 芋道源码 阮一峰每周分享的教程, 电子书, 网站等. EbookFoundation/**free-programming-books typing lesson 打字练习]]></content>
      <categories>
        <category>Computer Direction</category>
      </categories>
      <tags>
        <tag>Direction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018_HUST_PPT]]></title>
    <url>%2F2018%2F12%2F11%2F2018-12-11-2018-HUST-PPT%2F</url>
    <content type="text"><![CDATA[2018_HUST_PPTEPIC Lab PPT 20180905AIWAC宝宝机器人.pptx 20180905武大EEG硬件PPT.pptx 20181211CBIB口气检测仪.pptx 20181211EEG项目汇报.pptx 20181211Minchen.pptx 20181216EEG项目汇报.pptx CBIB Lab PPT 20181228CBIB电影龙猫.pptx 20181228CBIB开发社区.pptx 20190104长跑.pptx 20190111Computer.pptx 20190119 Computer Programe.pptx]]></content>
      <categories>
        <category>PPT</category>
      </categories>
      <tags>
        <tag>PPT</tag>
        <tag>epic</tag>
        <tag>cbib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows and GitHub Pages and Jeklly Building owns Bolg]]></title>
    <url>%2F2018%2F11%2F14%2F2018-11-14-win-git-jekyll%2F</url>
    <content type="text"><![CDATA[Windows By GitHub Pages and Jekyll building BlogInstall Tools 整个流程参考链接如下，包括博客的模板 Visit Link github Building yourself github account number. Build a New respository. Name : “github_name”.github.io (ep: quronghui.github.io) git clone 选好的模板 上传到你的GitHub Github Page GitHub Page 相当于一个服务器 Jekyll 运行在 GitHub Page 上 Jekyll 环境的搭建Jekyll Knowledge Jekyll 是一个简单的博客形态的静态站点生产机器 Jeklly 的一个最好的特点是“关注 blog 本身”，一个文件夹_posts下进行管理，减少繁琐 Jekyll 搭建 GitHub Pages + jekyll 的方式 直接参考这个Link Jekyll环境的搭建 Jekyll 搭建中安装包的说明 安装Ruby Ruby 是一种开源的面向对象程序设计的服务器端脚本语言 没找到在Blog中担当的角色 安装RubyGems 用于对 Ruby 组件进行打包的 Ruby 打包系统 也就是 Ruby 的管理系统 用Rubygem 安装Jekyll,所有的依赖包都会被安装 用RubyGems安装Jekyll cd到博客文件夹，开启服务器 访问 http://localhost:4000/ 提交代码到远程GitHub上 jekyll 中文说明文档 Jekyll 变量语法 jekyll serve =&gt; 一个开发服务器将会运行在 http://localhost:4000/ 始终需要重新更新 jekyll serve –watch 本地调试的时候，会自动更新 categories 和 tags categories 属性归类 tags 类似于搜索标签 date 变量 这个日期会覆盖文件命名的日期，并作为发布的时间。 Jekyll 文件夹 _posts Blog文件夹 年-月-日-标题.MARKUP MARKUP : 是一种标记，是用什么格式写。 example .md 和 .textile _assets 图片和文档目录 图片和文档的引用，前提是图片和文档放在assets 目录下 PDF文档 _drafts 草稿文件夹 保存一些占时没有写好的文档，不会进行发表。 jekyll serve –drafts : 查看未发表的草稿博客 github.io 文件夹目录 index.html – 创建主页面 任何网站的配置一样，需要按约定在站点的要目录下找到index.html 这个文件就将是你的 Jekyll 生成站点的主页。 为其他文件创建页面 命名 HTML 文件 没有真正理解这个每个页面的展示，没有成功实现 _config.yml – 文件 修改文件，好像本地博客不会发生改变代码亮亮 代码亮亮 给代码加入行号]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>jeklly Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Language]]></title>
    <url>%2F2018%2F02%2F19%2FComputerLanguage%2F</url>
    <content type="text"><![CDATA[第二章 指令–计算机的语言Schedule Dateline start time end time Learning 2018/12/6 8：50 9：50 第二章计算机指令 2018/12/7 8：20 9：30 MIPS寄存器和存储器 2018/12/8 8：40 9:11 效率低 2018/12/10 19：00 19：44 效率低 2018/12/11 8：36 9：22 多寄存器的冲突问题 Proper Noun Full name 中文 acronym instruction set 指令集 一个给定的计算机体系结构所包含的指令集合。 American Standrad Code for Information Interchange ASCII 计算机的文字处理 Acorn Risc Machine ARM 处理器 P99页 ARM 有更多的寻址模式 MIPS 有更多的寄存器 Question 1、为什么 Java 和 C 会是一样的呢？？ 解释和编译的平衡随着时间的推移逐步形成。 2、加速大概率事件？是什么意思. 3、编译C语言和解释Java语言？在配套的网站上。 Conception 指令集：计算机体系结构所包含的指令集合； MISP: 可方便硬件和编译器的设计，性能最佳且功耗最低。 存储程序的概念：多种类型的指令和数据均以数字形式存储于存储器中的概念。 数据传送指令：在存储器和寄存器之间移动数据的指令； 地址：用于在存储器空间中表示元素位置的值 存储程序：存储器存放程序和编译后的机器码（0/1），文本；甚至是用于生成机器码的编译器。 MIPS 的指令集 MIPS指令集，是一种寄存器到寄存器的语言。 MIPS操作数： | 类别 | 表示 | 数据访问 | 特点 || —————- | ——– | —————————- | ————————————– || 32个寄存器(32位) | $zero | 寄存器用于数据的快速存取 | 只能对存放在寄存器的数据进行算术操作。 || 2^30个存储器字 | Memory[] | 只能通过数据访问传输指令访问 | 字节编程；相邻Memory[4] 字地址相差4 | MIPS 算术运算 一条指令，由三个操作数构成 其余的汇编指令 P42页 ​ MIPS 32位各字段的表示和命名 操作码：指令中用来表示操作和格式的字段 计算机硬件的操作数 寄存器 $s0…… 用于表示C和Java程序中变量所对应的寄存器； $t0……用于表示将程序编译为MIPS，用到的临时寄存器； MIPS 算数运算指令的操作数，必须来自寄存器，由于寄存器位数有限，所以需要从存储器中取数据； 存储器 数据传送指令和地址； 存放像数组或结构那样的复杂数据结构； 存储器 –&gt; 寄存器 ：取数操作 load word 寄存器 –&gt; 存储器 ：存数操作 store word 软硬件接口 将变量和寄存器对应； 编译器在存储器中为数组和结构数据分配相应的位置； 编译器将存储器中数据对应的起始地址存放在：数据传送指令中。 软硬件接口 由于load和store指令中的地址是二进制的，作为主存的DRAM容量使用二进制而非十进制。 符号位和非符号位表示方式 负数的表示方式：采用补码的形式表示 补码：最高位设置为1，源码取反（最高位不变），最低位加1。 软硬件接口 寄存器的数量和定长指令的需求和设置–矛盾； 寄存器任何数量的增长，都需要在指令格式中各个寄存器字段至少增加一位； 寄存器越小越快，所以目用的寄存器大多是16/32。 逻辑操作 逻辑左移sll 和右移srl ：$$左移i位 = 原数 * 2^i$$ 软硬件接口 编译器的最初阶段：将程序分解为若干基本块； 基本快：没有分支，并且没有分支目标和标签的指令序列. 计算机硬件对过程的支持 为了解决更多寄存器使用的冲突问题。 栈的使用 栈的增长是一种先进先出的结构； 地址从高到低进行的,压栈时，栈的指针值减小；（从上到下） 过程嵌套，出现寄存器的冲突问题 通多对寄存器进行压栈处理，解决冲突； 软硬件接口–全局指针 全局指针：$gp，指向静态数据区的保留寄存器 为了简化静态数据的访问时间。 栈中使用的指针 帧指针（frame pointer)：$fp—-指向过程帧的第一个字； 栈指针：$sp 指向栈顶 人机交互 计算机是为了数字计算 计算机表示文字的处理，实现了人机交互。遵循ASCII 为了表示web的全球特性,当今的大部分web页面采Unicode,而非ASCII。 Java中的字符和字符串 字符串是一个标准的Java类，它对连接，比较，转换的方法提供了专门的方法 P75 数组和指针 1、指针中变量的地址用 &amp; 表示，指针所指向的对象用 * 表示。 2、寄存器的操作都是通过地址进行操作的。 3、编译器技术的理解，是理解性能的关键。 ARM7(32)位指令集 区别 ARM(32位) MIPS 多寻址模式 多寄存器 保存0 没有专门的寄存器 zero寄存器保存 第三章 计算机的算数运算Proper Noun Full name 中文 acronym Arithmetic logic unit 算数逻辑单元 ALU Exception Program Counter 异常程序计数器 EPC Question ？ 1、无符号数通常表示内存地址，溢出可以忽略？ 2、每个编译器都将以2为底的指数乘法替换为移位来进行优化。 3、使用32位数据表示通常要处理的无限数字。 4、乘法和除法：尽可能用 0/1 加法和减法 运算规则 加法运算：从右到左，二进制代码相加进位； 减法运算：将负数取反后，按照加法进行 计算是否会溢出 加法:源操作数异号时，不会溢出。 减法:源操作数同号时，不会溢出。 异常程序计数器EPC 保存导致异常的指令地址 乘法 乘法运算 被乘数和乘数的表示？ 被乘数每次左移一位，和乘数的一位相乘，结果相加 积的位数 = 被乘数的位数 + 乘数的位数 被乘数，乘数，积 每次进行的移位操作 积：每次的求和结果 更快速乘法 给每一个乘法数分配一个32位的加法器； 形成一个加法树； 除法 除法没有怎么看懂？ 计算的方式 除数：在右边补0，使其和被除数一样的位数 计算的时候：商左移，除数右移 除法：做减法；乘法：做加法 第四章 处理器]]></content>
      <categories>
        <category>Hardware Interface</category>
        <category>Computer-Composition-Principle</category>
      </categories>
      <tags>
        <tag>Hardware Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-matric]]></title>
    <url>%2F2018%2F02%2F18%2FMath-matric%2F</url>
    <content type="text"><![CDATA[邮箱： hustmath2018@163.com – math2018 typora使用操作 矩阵论 考试内容 Schedule Dateline start time end time Learning 2018/12/4 20:00 20:40 2018/12/10 20:00 10:00 2018/12/12 15:10 2018/12/13 14：35-17: 10 19:20- 2018/12/15 15：00 线性空间 条件：V是一非空集，F是数域，V中元满足向量的一些性质（数乘，交换和结合）； 结论：V为F上的线性空间(或向量空间),记为V(F); 空间V中的元称为向量； 若 性质：零元是唯一的 线性相关：集合中某一元素可由其他元素组线性表示。 线性无关定义： 当 m &gt;2 时；线性无关的条件是，向量组a_i中没有一个元素，可以由其他元素线性表示 单个非零向量组是线性无关； 在空间V中若能找到 n 个线性无关的向量组成dimV = n; 基（基底）的概念 基：最大线性无关向量的集合。 如何求多项式P(t)，在基B={a_i}下，的坐标x={x_i} 坐标：其实就是 A x = b中，向量x的解 求解：（1）构造增广矩阵，进行初等行变换化简；（2）行元素对应相等进行求解 基变换矩阵 空间 V 中的两个基B1 和 B2，存在一个变换矩阵P(ij)，使得B2中的每一个元素，可以通过B1和矩阵P(ij)的某一列相乘得到： 求解技巧： 通过逆矩阵：求解的坐标是n*m维，选用增广矩阵构造 单位矩阵 E，进行初等行变换； 坐标变换矩阵 由基变换引出的概念：求同一个坐标下，不同基对应的元素求解； 根据对应关系求解就行：向量 X = 基 B * 坐标 P； 这样，在根据基变换矩阵便可以求出关系式 当基为标准基：单位矩阵时；任何其他基，相同坐标下的向量都为零矩阵 子空间 线性空间V本身及由V的零元构成的零空间(记为{0}，都是V的子空间，称它们为平凡子空间。 张成子空间：span 子空间W的交；子空间W的和 —-维度 对于维度：先求W的和，再用公式求W交 子空间满足维 dim 的性质，维度就是不能线性表示的，元素的个数。 子空间的交，和满足的维度dim 子空间W的交；子空间W的和 —-基 对于基：先求W交的基，在求W和的基； 对于：W的交求基 存在一组不全为0的K，使得 V * K =0；最大线性无关向量的集合。 对于：W的和求基 直和：强调的是和空间的元素：唯一分解为两个子空间（各出一个元素）的和 直和：会考证明题——根据性质进行判断 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 2. 直和的性质： 1. W的交为零空间； 2. dim( W1 + W2) = dim(W1) + dim(W2) 3. 直接证明组成的：W(1)+W(2)—线性无关 直和的性质： W的交为零空间； dim( W1 + W2) = dim(W1) + dim(W2) refs/remotes/origin/master]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>matric</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera]]></title>
    <url>%2F2018%2F02%2F18%2FCamera%2F</url>
    <content type="text"><![CDATA[摄影知识三大元素 拍摄参数 | 场景 | 模式 | 光圈 | 感光度IOS | 快门 || :——–: | :——————: | :———————–: | :———: | :————: || 拍人像 | A模式-光圈优先 | 大光圈f/1.4、f/1.8、f/2.8 | 低 ISO &lt; 50 | A模式自动生成 || 拍夜景 | M-手动 或者 A | 大光圈 | 高ISO &gt; 400 | 大 = 1 / value || 晴朗的户外 | M-柔散迷人的景深效果 | 大光圈（F2.8） | 低 ISO &lt; 50 | 小 = 1/4000秒 || 快速的运动 | S-快门优先 | | | || 最常用的 | A-光圈优先 | 中等最好 | | 快门补偿曝光 | 光圈 摄影最重要的一个概念：光圈优先。光圈优先就是手动定义光圈的大小，相机会根据这个光圈值确定能正确曝光的快门速度。 光圈就是镜头里调节进光孔大小的装置。 光圈值： F1， F1.4， F2， F2.8， F4， F5.6， F8， F11， F16， F22， F32， F44， F64； 光圈大小：依次减小；进光量依次减小，相邻进光量相差一倍； 构图确定情况下（焦距确定），我们能控制景深的武器就只剩下光圈了。 大光圈（f/1.4、f/1.8、f/2.8等） 适用于光线不足时，增加曝光时间（快门速度变慢）； 背景模糊=景深浅：适用于拍人像（光圈数值越大，清晰的区域越小）； 小光圈（f/11、f/16、f/22等） 适用于光线充足时，捕捉时间； 背景清楚=景深深：适合拍风景（光圈数值越大，清晰的区域越大）； 中等光圈 镜头在中等光圈的时候成像最好（图片最清晰），成像最好的那档光圈就是最佳光圈； 景深：能够清晰成像的距离 景深浅，前景清晰，背景模糊；景深深，前景清晰，背景同样清晰； 拍摄时光圈越大景深就越浅； 拍摄时采用镜头焦距越长景深就越浅； 拍摄时相机与被摄对象距离越近景深就越浅。 调节位置：副拨码盘 感光度 IOS 高画质、低噪点与慢速快门 ISO &lt; 50 为低感光度 可以获得极为平滑、细腻的照片； 只要能够把照片拍清楚，就尽量使用低感光度。（宁可开大一级光圈，也不要把感光度提高一挡）; ISO400以上是高感光度 高的感光度能获得更快的快门速度; 但是高感光度的画质则是噪点比较大； 夜景的部份，则主要是利用在需要凝结瞬间的情境; 建议值：晴朗的室外使用ISO100；阴郁的天气使用ISO200；室内使用ISO400或更高。 调节位置 快门时间 快门时间 = 1 / value 快门速度 value 很大时：高速运动的瞬间被凝结了； value 很慢时：运动的过程被凝结下来 安全快门速度 快门值不慢于1/镜头焦距； 你使用的是50mm，快门值1/50便可以拍到一张不手震的照片了； 快门值设置 拍行走或快速移动时，设在1/250秒左右； 更快的自由落体或飞驰的物体，提高到1/400秒左右； 快速飞行时，设在1/800秒以上。 测光和自动曝光测光 测光范围：调节的方式 曝光和测光是一对双胞胎，如果不能准确测定光照强度，正确曝光就无从谈起。 点测光 ：只测取景框内一个小点的光线强度； 中央重点测光是简化的区域（平均）测光； 区域（平均）测光：加权平均得到光照强度； 曝光值：正值使拍摄对象更亮，负值则使其更暗]]></content>
      <categories>
        <category>Camera</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Outline and Technology]]></title>
    <url>%2F2018%2F02%2F18%2FComputerComposition-principle%2F</url>
    <content type="text"><![CDATA[第一章 计算机概要与技术 Proper Noun Full name 中文 acronym personal mobile device 个人移动设备 PMD Warehouse scale computer 巨型数据中心 WSC Liquid Crystal Display 液晶显示 LCD active matrix display 动态矩阵显示 Integrated circuit 集成电路 Central peocessor unit 中央处理单元 CPU dynamic random access memory 动态随机存储器 DRAM static random access memory 静态随机存储器 SRAM – 价格高于DRAM very large-scale integrated circuit 超大规模集成电路 VLSI clock cycle per instruction 执行每条指令所需时钟周期数的平均值 CPI System performance evaluation cooperative 计算机组织，为现代计算机系统建立基准测试集 SPEC Conception 计算机革命推动人类的进步 个人计算机和服务器 服务于个人，和服务于多人的一种可视化操作系统 嵌入式计算机：嵌入到其他设备中的计算机，一般运行预定义的一个或者一组应用程序。 云计算：集群服务器 软件即服务 现代微处理器： 理解现代微处理器硬件如何使性能提高200倍。 摩尔定律： 计算机设计者面临问题： 单芯片上的集成度没18-24个月翻一番，意味着驱动的快速变化。 使用抽象简化设计 抽象：表示不同的设计层次，从高层此种只能看到一个简化模型。 通过冗余提高可靠性 使用冗余部件提高系统的可靠性，并可以帮助检测错误。 学到啥 如何正确剖析软硬件，如何评价性能与功耗 程序入门概念 应用软件–&gt;系统软件–&gt;硬件执行 系统软件 提供常用的服务软件：操作系统，编译程序，加载程序和汇编程序。 操作系统 编译程序：将高级语言翻译为计算机识别的机器语言的程序 指令 0/1数字：即表述指令（计算机硬件理解并服从的命令），又表示数据（二进制位） 汇编语言 语言是一种指令（表示），程序是转换的过程。 汇编程序：将指令由助记符形式翻译成二进制形式的程序 汇编语言：以助记符形式表示的机器指令； 机器语言：以二进制形式表示的机器指令 硬件入门 正确剖析软硬件 基础硬件的基本功能 输入数据–输出数据–处理数据（数据通路和控制器）–存储数据 显示器 图像由像素矩阵组成，可以表示成二进制位的矩阵，称为位图（bit map） 处理器 逻辑上分为两部分：数据通路和控制器 数据通路：负责完成算数运算 控制器：负责指导数据通路 内存 内存：程序运行时的存储空间， 由多片DRAM组成 缓存 cache memory — SRAM 处理其内部的另外一种存储器 小而快的存储效应，作为DRAM的缓冲 抽象之一 - P15 该抽象被命名为计算机指令集体系结构 – 体系结构 硬件的实现方法必须依照体系结构的抽样 抽象系统中的一个关键接口是指令集体系结构–硬件和底层软件的接口 计算机网络 计算机不可缺少的功能 晶体管-硅制作的工艺–芯片chip 成品率的计算 性能 性能的评价因素 响应时间和吞吐量 增加性能和降低执行时间是一个倒数关系 CPU（Central Processing Unit） 性能及其影响因素 时钟周期数、时钟周期时间（时钟频率的倒数） CPU（t） = CPU ( 时钟周期数 ) / CPU ( 时钟频率 ) CPU 时钟周期数 = 程序的指令数 * CPI(每条指令的平均时钟周期数） 经典公式 ：CPU(t) = 指令数 * CPI / 时钟频率 功耗：使用能耗更合理 功耗：由于CMOS管0-1-0的跳变 能耗的来源是 CMOS 管开关动作中的消耗 一个晶体管能耗 = 1/2 负载电容 电压（平方） 一个晶体管功耗 = 1/2 负载电容 电压（平方）* 开关频率 单处理器–&gt;多处理器 原因： 增加多个微处理器，得到更大的吞吐量。不再继续追求单个程序运行在单个处理器上的响应时间 单处理器–processor or cores; 多核处理器(微处理器)– microprocessor 并行性 并行性对计算机性能十分重要，但它往往是隐蔽的 挑战：调度、负载平衡、同步、通信 硬件/软件接口：显示并行编程 并行性对计算机一直十分重要 程序员未来：显式并行编程，不单是串行 Iner Core i7 基准 SPEC CPU 基准测试程序 工作负载：运行在计算机上的一组程序。 基准测试程序：用于比较计算机性能的一组程序。 SPEC 采用单个的数字来进行归纳 SPECpower 功耗是有规定 称为：overall ssi_ops per watt 计算公式 谬论和陷阱 谬论：面向性能的设计和面向能量效率（功耗）的设计具有不相关的指标。 陷阱：用性能公示的一个子集去度量性能。 硬件和软件的设计者都采用分层的方法构建计算机系统，每个下层都对其上层隐藏本层的细节。 抽象：理解硬件和底层软件之间的接口，指令集的体系结构。 执行时间：唯一有效且不可推翻的性能评价指标。]]></content>
      <categories>
        <category>Hardware Interface</category>
        <category>Computer-Composition-Principle</category>
      </categories>
      <tags>
        <tag>Hardware Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HC-05-Bluetooth]]></title>
    <url>%2F2018%2F02%2F18%2FHC05-Bluetooth%2F</url>
    <content type="text"><![CDATA[HC-05-Bluetooth-ATResourse 这个软件只能设置HC-03 和HC-05,其他的还需要另外的软件 百度网盘 AT指令调试 先安装setep控件； 打开“蓝牙测试软件”，这样才会获取模块的信息； HC-05的模块进入绝对AT状态 按住按键在上电（或者EN脚接高电平）； 波特率 38400； 按照AT指令输入相应的设置；]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>Bluetooth</tag>
        <tag>AT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP8266]]></title>
    <url>%2F2018%2F02%2F18%2FESP8266%2F</url>
    <content type="text"><![CDATA[ESP8266 串口测试 串口WiFi，将串口数据发送到服务器上 工作： 连接wifi 开启服务器监听，连接到服务器 所需工具软件 下载串口调试工具sscom 这个调试工具在输入 AT command后,需要加同一个回车 硬件 ESP8266 USB转TTL下载器 接线方式 esp8266供电方式VCC = 3.3v EN 使能方式,上拉到VCC=3.3v AT指令测试 ATcommand 波特率的设置9600 或者115200 ESP8266有三种模式 第一种是客户端模式：Station 第二种是接入点模式：AP 第三种是两种模式共存:Station+AP 发送指令：AT+CWMODE=3 发送指令：AT+CWJAP=”SSID的信号名”,”密码” 建议：在之后的实验中，可以先用手机热点或者电脑热点来测试设备。 重启自动连接 EN：使能脚需要一直拉高 ESP8266 tcp测试理论知识 什么是TCP 什么是UDP？ 任何网络服务器：理解为监听在指定端口的程序，负责接收数据并且做出反应。 需要在同一个网络下进行测试。ep：ESP8266和主机处于同一个路由器下。 手机作为服务器，进行TCP测试 测试原因：台式机没有无线发射器；实验室路由器没有充钱 后续： 在手机上测试，明白其原理，后续还是需要无线发射器。 软件 电脑：下载串口调试工具sscom 手机：手机TCP调试助手USR-TCP-Test 硬件 ESP8266 USB转TTL下载器 测试过程 手机开启热点，等待被连接； 电脑打开 sscom ,进行AT指令调试； AT+RST // 重启模块 AT+CWMODE=3 // 设置模式Station+AP 第三种是两种模式共存 AT+CWJAP=”SSID的信号名”,”密码” // 连接手机热点 AT+CIFSR // 查看ESP8266连上热点后的IP 注意 AT指令输入后，都会输出OK, 才表明配置成功 此时手机WLAN扫描可以看到ESP8266的wifi 如果不知道名字，可以先配置连上手机热点，看连接设备的名字。 手机打开调试助手–USR-TCP-Test 手机作为服务器，进行端口监视； 选择 tcp serve 配置端口号（IP 地址是手机网络的IP，不能更改（电脑也一样）） 点击激活，记下此时出现的 IP 和 端口port 切换到电脑 sscom, 进行AT调试 AT+CIPSTART=”TCP/UDP”,”IP”,port // 输入serve的IP和port,TCP/UDP用大写 手机端显示tcp连接成功的设备 此时，ESP8266和serve建立起了tcp连接；后面进行数据发送。 电脑 sscom，AT调试 AT+CIPSEND=4 // 设置数据包的字节数 输入 ABCD ESP8266作为服务器，进行TCP测试测试条件 在上面软硬件的基础上； ESP8266 连上手机wifi热点 测试过程 电脑端sscom AT+CIFSR // 查看ESP8266连上热点后的IP，使用START下的IP AT+CIPMUX=1 // AT+ CIPMUX=1 时才能开启服务器 AT+CIPSERVER=1,333 // 开启 server 后自动建立 server 监听 此时ESP8266开启了服务器监听 手机USR-TCP-Test，选择TCP Client 输入ESP8266模块的START_IP,和port; 连接服务器 输入数据进行发送 服务器接收到的数据 将手机换成笔记本 只需要换一个TCP调试工具 NetAssist。 完成了ESP8266的数据收发问题 接下来结合arduino,进行数据测试 参考链接]]></content>
      <categories>
        <category>WIFI</category>
      </categories>
      <tags>
        <tag>ESP8266</tag>
      </tags>
  </entry>
</search>
