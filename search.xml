<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BLE]]></title>
    <url>%2F2019%2F09%2F05%2FBLE%2F</url>
    <content type="text"><![CDATA[BLE 的GAP 和 GATT协议解析 协议 GAP GATT 作用 控制设备连接和广播 GAP建立连接之后，发送和接收数据的通用规范 连接 广播建立连接 独占; client请求建立, server响应 角色 外设S / 中心设备C 外设S / 中心设备C 数据 不建立连接，直接广播数据，最大31byte 建立连接；characteristic来实现通信 单/双向 数据传输单向（server –&gt; client） 双向（client ） 从机端：服务器端； 主机端：客户端； BLE 基础知识简介 从机–服务端的结构 作用 位于 profile 一个标准的通信协议，每个profile包含多个server 从机 – &gt; 服务端 server 可以理解为一个服务，包含多个characteristic 从机 characteristic 理解为一个标签，通过标签读取或者写入想要内容 主从机的通信实现 UUID 统一识别码，service 和 characteristic 都需要一个唯一的 uuid profile profile 可以理解为一种规范，一个标准的通信协议，它存在于蓝牙从机中（服务端）； 每个 profile 中会包含多个 service，每个 service 代表从机的一种能力 server 可以理解为一个服务，在 BLE 从机中有多个服务 每个 service 中又包含多个 characteristic 特征值； 每个具体的 characteristic 特征值才是 BLE 通信的主题，比如当前的电量是 80% 电量的 characteristic 特征值存在从机的 profile 里，这样主机就可以通过这个 characteristic 来读取 80% 这个数据 characteristic BLE 主从机的通信均是通过 characteristic 来实现，可以理解为一个标签 主机通过：这个标签可以获取或者写入想要的内容。 UUID UUID，统一识别码，我们刚才提到的 service 和 characteristic 都需要一个唯一的 uuid 来标识； 16bit的UUID 、 128bit 的uuid 总结 每个从机(服务端)都会有一个 profile，不管是自定义的 simpleprofile，还是标准的防丢器 profile，他们都是由一些service 组成（代表从机的一种能力） 每个 service 又包含了多个 characteristic 主机和从机之间的通信，均是通过characteristic来实现 GATT协议和GAP协议GAP 拓扑结构 GAP（Generic Access Profile） 作用：控制设备连接和广播 GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互； GAP设置角色 外围设备（Peripheral - 从机 - 服务端） 低功耗设备，用来提供数据，并连接到一个更加相对强大的中心设备 小米手环就等设备就可以与中心设备连接； 中心设备（Central - 主机 - 客户端） 中心设备相对比较强大，用来连接其他外围设备 例如手机 GAP 广播数据方式 Advertising Data Payload（广播数据） 每种数据最长可以包含 31 byte 这里广播数据是必需的，因为外设必需不停的向外广播，让中心设备知道它的存在； Scan Response Data Payload（扫描回复） 扫描回复是可选的 中心设备可以向外设请求扫描回复，这里包含一些设备额外的信息:“设备名字” 广播的网络拓扑结构 外设通过广播自己来让中心设备发现自己，并建立 GATT 连接，从而进行更多的数据交换； 不需要建立连接：只要外设广播自己的数据即可 因为基于 GATT 连接的方式：只能是一个外设连接一个中心设备 GATT 拓扑结构 BLE GATT (Generic Attribute Profile) 作用： 低功耗蓝牙 BLE 的连接 GATT 是一个在蓝牙连接之上：发送和接收很短的数据段的通用规范 很短的数据段被称为属性（Attribute） GATT 的特点 GATT 连接是独占的：也就是一个 BLE 外设同时只能被一个中心设备连接； GATT 建立在GAP协议之上：GAP完成广播和连接建立，GATT完成数据传输； GAP 通信是单向的 GATT 通信是双向的 GATT 通信：设备通过 Service 和 Characteristic 进行通信 GATT使用ATT协议：ATT 协议把 Service, Characteristic 对应的数据保存在一个查找表中，查找表使用 16bit UUID 作为每一项的索引 GATT 通信事务 GATT 通信的双方是 C/S 关系 外设作为 GATT 服务端（Server） 维持了 ATT 的查找表 以及 service 和 characteristic 的定义 中心设备是 GATT 客户端（Client） 所有的通信事件：都是由客户端发起（也叫主设备，Master） 接收服务端（也叫从设备，Slave）的响应 时间间隔 连接建立后，外设会给中心设备建立一个连接间隔； 中心设备就会在每个连接间隔尝试去重新连接，检查是否有新的数据 GATT结构 建立在嵌套的Profiles, Services 和 Characteristics之上的 心率 Profile（Heart Rate Profile） 结合了 Heart Rate Service 和 Device Information Service 以 Heart Rate Service 官方通过 16bit UUID 是 0x180D 3 个 Characteristic：Heart Rate Measurement, Body Sensor Location 和 Heart Rate Control Point 数据结构是，开始 8 bit 定义心率数据格式，接下来就是对应格式的实际心率数据 GATT 实现串口的双向通信]]></content>
      <categories>
        <category>driver</category>
      </categories>
      <tags>
        <tag>BLE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux_camera_driver]]></title>
    <url>%2F2019%2F09%2F04%2Flinux-camera-driver%2F</url>
    <content type="text"><![CDATA[Linux camera driverCamera驱动接口 接口 CSI I2C 接口作用 用于Camera感光器件数据本身的传输 用于控制数据的传输 摄像头感光器件本身数据传输的相关代码 设置曝光时间设置，图像大小设置，白平衡 实体 OV系列的驱动 驱动代码 平台(CPU)一旦确定：这部分的驱动代码就基本确定 根据不同的接口有不同的驱动代码 不同的camera开发，需要关注的是？ 具体摄像头的控制接口部分，I2C,SPI 不同的摄像头，设置白平衡等功能的方式不一样 CSI代码主要的职责 按照平台内的CSI控制器的特点，完成CSI控制寄存器的配置 CSI中断服务例程的实现以及具体数据传输（内存分配,DMA数据传输等）的实现 其他的接口驱动：USB和PCI 驱动初始化阶段：通过probe方法获得相关寄存器的访问地址，之后参照datasheet进行寄存器配置 数据处理：再结合Linux系统的中断机制和数据传输机制（DMA和MMAP） V4L2架构 V4L2 支持 – 视频输入输出设备四部分 四个模块 功能 字符设备驱动程序 V4L2是一个字符设备，具有字符设备的特性，向上提供接口给用户空间； V4L2驱动核心 构建内核中标准视频设备驱动框架，为设备提供统一的接口函数 平台V4L2设备驱动 在V4L2框架下：实现与平台相关的V4L2驱动部分，包括注册video_device和v4l2_dev结构体 具体的sensor驱动 上电、提供工作时钟、视频图像裁剪、流IO开启等，实现各种设备控制方法供上层调用并注册v4l2_subdev。 V4L2的核心源码 源码查看 1cd /driver/media/v4l2-core // 进入v412框架的代码 代码目录 模块 函数 核心模块 申请字符主设备号，注册class和提供video_device注册注销函数 v4l2-dev.c V4L2框架 构建V4L2框架 v4l2-device.c、v4l2-subdev.c、v4l2-fh.c、v4l2-ctrls.c Videobuf管理 完成videobuffer的分配、管理和注销 Ioctl框架 构建V4L2 ioctl的框架 v4l2-ioctl.c Videobuf 函数 1由videobuf2-core.c、videobuf2-dma-contig.c、videobuf2-dma-sg.c、videobuf2-memops.c、videobuf2-vmalloc.c、v4l2-mem2mem.c V4L2 两个结构体 结构体 树型结构 v4l2_device - 父结构 对子设备管理：通过链表将所有注册的子设备进行管理 V4l2_subdev是子设备 设备：可以是GRABBER、VBI或RADIO Video_device 创建子设备节点，把操作设备的接口提供给用户空间 V4l2_fh：是每个子设备的文件句柄，在打开设备节点文件时设置 v4l2_ctrl_handler：通过V4l2_fh，进行子设备控制 V4l2_subdev是子设备作用？ 包含了对设备操作的ops 和 ctrls 实现控制上下电、读取ID、饱和度、对比度和视频数据流打开关闭的接口函数 V4L2驱动的实现]]></content>
      <categories>
        <category>driver</category>
      </categories>
      <tags>
        <tag>camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux ALSA]]></title>
    <url>%2F2019%2F09%2F04%2FLinuxALSA%2F</url>
    <content type="text"><![CDATA[Linux ALSA 声卡驱动 驱动框架 ALSA OSS(Open Sound System) Linux版本支持 2.6 kernel 之后 2.4 kernel 开放的声音系统 总线 I2C 设备类型 字符设备 （ls-l /dev/snd） pcm and control C0D0 – 声卡0的设备0 内核设备驱动层 alsa-driver (ls -l sound) alsa-soc : 进一步封装driver 用户空间层 alsa-lib；tinyalsa ALSA 系统架构 系统架构 作用 Native ALSA Application tinyplay/tinycap/tinymix，直接调用 alsa 用户库接口来实现放音、录音、控制 ALSA Library API alsa 用户库接口，常见有 tinyalsa、alsa-lib ALSA CORE alsa 核心层，向上提供逻辑设备（PCM/CTL/MIDI/TIMER/…）系统调用，向下驱动硬件设备（Machine/I2S/DMA/CODEC） ASoC CORE asoc 是建立在标准 alsa core 基础上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系 Hardware Driver 音频硬件设备驱动，由三大部分组成，分别是 Machine、Platform、Codec ALSA从内核空间到DAC采样 Hardware driver I2C 是传输数据 ,I2S 是传输音频 ALSA 驱动具体工作 ALSA驱动具体工作 调用函数 创建snd_card结构体 snd_card_create() / snd_ctrl_create() 初始化 snd_pcm_new(): 创建逻辑设备（播放或者录音） 注册 snd_card_register 注册声卡 ALSA(Advanced Linux Sound Architecture) ALSA目前是：linux的主流音频体系结构 用户空间：alsa-lib 应用程序提供统一的API接口，这样可以隐藏了驱动层的实现细节 应用程序只要调用alsa-lib提供的API，即可以完成对底层音频硬件的控制 内核空间：alsa-driver；alsa-soc alsa-driver：内核设备驱动层 alsa-soc：对alsa-driver进一步封装，方便用户空间调用； ALSA设备文件结构 查询Linux下alsa驱动的设备文件结构 1$ ls -al /dev/snd // 设备属于字符设备 目录下的设备用途 我们更关心的是pcm和control这两种设备 设备类型 设备名字 作用 字符设备 controlC0 用于声卡的控制，例如通道选择，混音，麦克风的控制 midiC0D0 用于播放midi音频 (两组) pcmC0D0c 用于录音的pcm设备；capture pcmC0D0p 用于播放的pcm设备；playback seq 音序器 time 定时器 C0D0代表的是：声卡0中的设备0 ALSA 驱动目录文件 linux 查询alsa驱动目录 1$ ls -al /sound // 将sound slsa-driver分三层 声卡对象描述层 ALSA 核心层 ASLA Core Audio 设备驱动层 Audio device driver 驱动目录 作用 core 该目录包含了ALSA驱动的中间层，它是整个ALSA驱动的核心部分 core/oss 包含模拟旧的OSS架构的PCM和Mixer模块 core/seq 有关音序器相关的代码 include ALSA驱动的公共头文件目录，该目录的头文件需要导出给用户空间的应用程序使用 drivers 放置一些与CPU、BUS架构无关的公用代码 i2c ALSA自己的I2C控制代码 pci pci声卡的顶层目录，子目录包含各种pci声卡的代码 isa isa声卡的顶层目录，子目录包含各种isa声卡的代码 soc 针对system-on-chip体系的中间层代码 soc/codecs 针对soc体系的各种codec的代码，与平台无关]]></content>
      <categories>
        <category>driver</category>
      </categories>
      <tags>
        <tag>alsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux设备驱动的开发详解]]></title>
    <url>%2F2019%2F08%2F24%2FLinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Linux设备驱动的开发详解 如何学习驱动 驱动的框架 和 代码框架 硬盘镜像下载 m6a1 globalmem、globalfifo等代码目录 /home/baohua/develop/training/kernel/drivers 其他相关参考 设备驱动的概念 设备驱动的作用? 对设备驱动最通俗的解释就是“驱使硬件设备行动”。 驱动与底层硬件直接打交道, 按照硬件设备的具体工作方式,读写设备的寄存器,完成设备的轮询、中断处理、DMA 通信,进行物理内存向虚拟内存的映射等, 最终让 通信设备能收发数据, 让显示设备能显示文字和画面, 让存储设备能记录文件和数据。 设备驱动的分类和特点 驱动的对象: 存储器 + 外设 (包括CPU内部) Linux 三大设备驱动? 字符设备: 必须以串行数据依次访问的设备 触摸屏, 磁带驱动, 鼠标 块设备: 可以按照任意顺序进行访问, 以块为单位(512bytes)访问 硬盘, emmc 网络设备: 面向数据包的接受和发送设计, 并不倾向于文件系统的节点; 使用套接字编程 无OS的设备驱动 无操作系统的设备驱动 单任务框架 通过一个无限循环 + 中断检测 / 轮询检测完成 ( 有相应的代码框架) 连接 应用程序 和硬件的桥梁 驱动程序, 需要由应用软件直接完成 无操作系统的串口驱动 有OS的设备驱动 有OS的设备驱动 需要将驱动融入进内核; 驱动: 操作系统和硬件的桥梁 应用程序只与OS的API打交道 OS 给设备驱动带来了哪些麻烦? 操作系统通过给驱动制造麻烦, 来达到给上层应用提供便利的目的 麻烦: 需要按照OS的框架编写驱动代码; 还需要挂载到OS上; 实现驱动和内核接口的代码 Linux 设备驱动和软硬件的关系 Linux对字符和块设备的处理 + 将其映射为文件和目录;+ 应用程序通过调用OS的API调用字符设备和块设备 应用程序如何使用硬件设备? 直接使用Linux api进行编程 open(), write(), read(), close() 使用C库函数调用Linux的API, 便于代码移植 fopen(), fwrite() LED驱动 GPIO寄存器 :控制寄存器和数据寄存器 驱动设计的硬件基础处理器 通用处理器 冯·诺依曼结构 : 程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置 哈佛结构: 程序指令和数据分开存储,指令和数据可以有不同的数据宽度 哈佛结构还采用了独立的程序总线和数据总线 指令集划分: RISC 和CISC 数字信号处理器 数字信号处理器(DSP)针对通信、图像、语音和视频处理等领域的算法而设计。 相关矩阵运算等算法中的大量重复乘法。 存储器 总线SerialBusLinux 内核及内核编译内核目录的分析 linux 内核目录 arch :包含和硬件体系结构相关的代码,每种平台占一个相应的目录 drivers : 设 备 驱 动 程 序, 每 个 不 同 的 驱 动 占 用 一 个 子 目 录 内核中目录的总结 内核: drivers 与arch 的软件架构分离, 驱动不包含板级信息, 让驱动跨平台; 内核通用部分和具体硬件剥离 Linux内核的五部分, 之间的依赖关系 内核的编译和加载 内核配置的三个部分 Makefile Kconfig: 用户进行配置选择; 配置工具: 命令解释器和配置用的用户界面 1make menuconfig 目标代码是否编译的选项 123obj - y += foo.c // 将函数编译进内核; 内核编译obj - m += foo.c // 将函数编译成 .ko文件; 模块编译obj - n += foo.c // 函数不变异 Linux代码的编译风格 GNU C 预定义两个标识符保存: 当前函数名字 123__func__ __PRETTY_FUNCTION__ ;$ printf("this funcation name is : %s\n",__func__ ); // 可以代替函数的名字, 打印出来 宏定义: do{} while(0) 用法 1#def ine SAFE_FREE(p) do&#123; free(p); p = NULL;&#125; while(0) goto 跳转到错误代码 arm Linux 工具链 123arm-linux-gnueabihf-gcc; // 工具链armcc // 进行编译objdump; // 反汇编 Linux 下串口工具 1minicom // 设置其波特率 Linux 内核模块的编写 如何将驱动包含入内核中? obj - y : 直接编译进内核 缺点: 造成内核模块太大 obj - m : 编译成.ko模块, 需要的时候, 动态加载到内核; 驱动代码的编写(按照内核框架) – &gt; 编译成模块 – &gt; 加载到内核中 – &gt; 卸载模块 1234567$ insmod hello.ko // 模块加载函数 , 只加载hello.ko模块;$ modprobe -r hello.ko // 模块加载函数, 将加载hello.ko 依赖的所有模块;$ rmmod hello.ko // 模块卸载函数 , 只卸载hello.ko模块;$ lsmod // 查询模块之间的依赖关系; == cat /proc/modules$modinfo hello.ko // 得到模块相关参数信息 Linux内核中的打印函数 1printk(KERN_INFO "hello world\n"); // 使用printk进行打印 相关的信息, 通过查看内核日志得到内核输出 1$ vim /var/log/messages Linux内核模块程序结构 模块加载函数: 1234static int __int initialization_funcation(void) // __init : 模块加载函数的声明&#123;&#125;module_init(initialization_funcation); // 模块函数通过这样的方式进行指定; 使用这个函数的方法 模块卸载函数 1234static int __exit cleanup_funcation(void) // __exit : 模块卸载函数的声明&#123;&#125;module_init(cleanup_funcation); // 模块函数通过这样的方式进行指定; 使用这个函数的方法 模块的参数 1module_param(参数名, 参数类型, 参数读写权限); // 定义一个模块参数声明 在/sys 目录下, 查看模块参数 导出符号 linux的 /proc/kallsyms 文件对应着内核符号表 12EXPORT_SYMBOL(符号名)EXPORT_SYMBOL_GPL(符号名) 模块的声明和描述 表明模块的作者, 版本号, 设备号, 模块支持的所有设备 1MODULE_DEVICE_TABLE(table_info) //对于支持USB, PCI的设备: 表示模块支持的设备 Linux文件系统和设备文件 linux : 一切都是文件 – 设备即文件; 设备驱动是如何被访问的? 通过与文件操作相关的系统调用或C库函数(本质也是系统调用)被访问 设备驱动结构: 为了迎合应用程序而设计的API; 文件的属性 文件打开的标志 : 文件的权限 : 分三类用户 12mode + umask : 一起决定文件的权限umask: 只影响 r w x Linux 文件的权限通过5个数字表示 12&#123; [用户ID](0/1) ; [组ID](0/1); [读权限](3bit的八进制数); [写权限]; [执行权限]&#125;1 0 705; 用户组权限; 文件所有者rwx; 文件组0; 其他用户rx; 系统调用和C库函数的文件操作 区别 系统调用 C库函数调用 文件操作函数 全是 int型 存在不同的类型 文件的打开标志 O_EDONLY (以大写O开头) r / w / a(追加) 文件的权限 S_IRUSR(以S_I开头) 操作的数据类型 int 字符和字符串 推荐使用 便于移植 与驱动关系 应用程序 – 系统调用 – 驱动 应用程序 – C库 – 系统调用 – 驱动 C库函数使用时, 内部包含了系统调用函数 系统调用: 文件操作 123456int create(const char *filename, mode_t mode); // 创建, 由mode + umask决定权限; int open(const char *filename, int flag, mode_t mode); // 打开文件, 存在打开标志和打开权限; 返回 int fd;int read(int fd, const void *buf, size_t length); // 读buf; 返回实际读出来的字节数 int write(int fd, const void *buf, size_t length); // 写buf; 返回实际写入的字节数 int close(int fd); // 关闭;int lseek (int fd, offset_t offset, int whence); // 文件读写时的相对位置; offset,偏移量, 可取负值; whence: 相对位置 C库函数的文件操作 推荐使用库函数进行操作, 方便移植; 实现字符流的操作; 12FILE *fopen(const char *path, const char *mode); // 文件打开, mode为打开标志int close (File *stream); 读写: 以字符 和 字符串为单位进行读写; 可以实现从流中读取n个字段 12345678910 int fgetc(FILE *stream); char *fgets(char *s, int size, FILE *stream); // 类型比较特殊, 为char*int fputc(int c, FILE *stream);int fputs(const char *s, FILE *stream);int fprintf(FILE *stream, const char *format, ...); // 用法不太会int fscanf(FILE *stream, const char *format, ...); size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 定位功能 123int fseek(FILE *stream, long offset, int whence);int fgetpos(FILE *stream, fpos_t *pos);int fsetpos(FILE *stream, const fpos_t *pos); linux文件系统linxu 文件系统目录结构 /proc 目录 进行以及内核信息(包括PCU, 硬盘, 内存信息)存放的位置; 伪文件系统, 存在与内存之中 包含进程和线程的相关信息 /var /var/log 存放系统日志 /sys 内核支持的文件系统映射到此目录上; linux设备驱动模型中的总线, 设备, 驱动; 在sysfs文件系统中找到对应的节点; 虚拟文件系统和设备驱动的关系 结构体 : file and inode 设备驱动的两个模块 包含内容 目录查看 file private data inode i_cdev : 记录设备号 (32bit) ; 主(12bit)次设备号(20bit) /proc/devices 块设备 : block_device ; 字符设备: i_cdev struct file 在内核打开文件时创建, 并传递给在文件上进行操作的任何函数, 在文件的所有实例关闭后, 释放这个结构体; 命名: file or filp(file pointer) private data: 私有数据在设备驱动中广泛使用; struct inode : 元数据 Linux 管理文件的最基本单位 文件系统连接子目录的桥梁 inode 中的设备号的获取 12unsigned int iminor(struct inode *innode); // 主设备号的获取; minor -- 表示位数较少unsigned int imajor(struct inode *innode); // 次设备号的获取; major -- 位数较多 devfs and udev devfs udev 设备文件系统 用户空间设备管理 策略包含在内核中(受限) 策略: 处于用户空间; 内核只提供机制 模型抽象 devfs : 内核不仅要提供恋爱的机制, 还需要规定和谁恋爱 udev: 内核只提供恋爱的机制, 和谁谈恋爱由用户决定 udev的工作原理 利用设备加入和移除时内核所通过netlink套接字, 发出的热插拔式事件uevent来工作; udev 如何处理设备的热插拔和冷插拔? 热插拔 冷插拔 udev 已经启动, 才插入设备 udev还未启动 设备信息由内核, 通过netlink套接字发送, 叫做uevent; 内核提供的sysfs下面的uevent节点, 给该节点写一个add udev从内核收到的信息来进行创建设备文件节点; 导致内核重新发送netlink; udev启动后就可以处理 sysfs文件系统 sysfs文件系统的特点 虚拟文件系统; 将连接在系统上的设备和总线组织成为一个分级的文件 目录: 来源于bus_type ; device ; device_driver 文件: 来源于具体的attribute 1$ dump //打印出总线, 设备和驱动信息; /sys/bus/pci 在划分出drivers 和devices目录 Linux内核中描述总线, 设备, 驱动的三个结构体 bus_type ; device ; device_driver 模型抽象: 红尘中的男女+月老 设备和驱动分开注册; bus_type: match()进行匹配, 匹配成功后, xxx_driver的probe()被执行 attribute属性文件 伴随着show()和store()函数, 分别用于读写该attribute对应的sysfs文件 字符设备驱动 Linux字符设备驱动的关键数据结构 cdev: 设备号的注册注销 file_operations结构体: 文件操作具体功能函数 globalmem 虚拟字符设备驱动的编写方法 读写函数, seek()函数和I/O控制函数; 私有数据的作用; Linux字符设备驱动1234struct cdev&#123; struct file_operations *ops ; //文件操作的结构体 dev_t dev; // 设备号&#125;; cdev结构体的操作函数 __init ：标志模块的加载 __exit：标识模块的卸载 1234void cdev_init( struct cdev *cdev, struct file_operations *ops ); // 初始化cdev成员, 建立cdev和file_operations之间连接struct cdev *cdev_alloc(void); // 动态申请cdev的内存int cdev_add(struct cdev *, dev_t , unsigned ); // 字符设备的注册void cdev_del(struct cdev *); // 字符设备的注销 cdev分配和释放设备号 12345(1)在cdev_add()之前, 先调用函数, 向系统申请设备号; register_chrdev_region(); // 申请自己知道的设备号 alloc_chrdev_region(); // 设备号未知,动态申请(2) 在cdev_del()之后, 调用函数 unregister_chrdev_region(); //释放设备号 file_operations文件操作结构体 使用的是函数指针 三个操作 123ssize_t xxx_read(); // 用户空间和内核之间的读写; copy_to_user()ssize_t xxx_write(); // copy_from_userssize_t xxx_ioctl(); 用户空间 – 内核空间 的读写 access_ok(); // 检测用户控件缓存区的合法性, 才能进行读写; 12copy_to_user(); // 内核空间到用户空间缓存区的复制copy_from_user(); //用户空间到内核空间的复制 globalmem()虚拟设备驱动 globalmem字符设备驱动会分配一片大小为GLOABLEMEM_SIZE(4KB)的内存空间 mem[]数组空间：与用户空间进行数据交换 虚拟字符设备：不仅有cdev ,也有了内存空间、 私有数据：使得驱动改动小量代码，实现多个设备的支持 1container_of() ; // 通过结构体成员的指针找到对应结构体的指针 globalmem()的结构体 1234struct globalmem_dev&#123; struct cdev cdev; unsigned char mem[GLOABLEMEM_SIZE];&#125; globalmem中模块的加载和释放函数 和linux设备驱动中的一样 globalmem文件的操作 使得设备结构体中的mem[]数组 – &gt; 用户控件交互数据 1234static ssizet_t globalmeme_read(); //读数据static ssizet_t globalmeme_write(); // 写数据static ssizet_t globalmeme_llseek(); // 数据偏移static ssizet_t globalmeme_ioctl(); // I / O控制函数 私有数据的使用 1234int global_open(); // 进行私有数据的设置&#123; file-&gt;private_data = globalmem_devp; // 私有数据先设置, 后使用;&#125; 使用私有数据后, 就可以实现同时包含多个设备; 但是只使用一套文件操作函数; globalmem模块的查看 12$ cat /proc/devices // 查看字符设备的驱动$ mknod /dev/globalmem c 230 0 //创建设备节点; 主设备号 和次设备号; Linux设备驱动中的并发控制 linux设备驱动中必须解决的一个问题? 多个进程对共享资源的并发访问, 并发的访问会导致竞态; 两组概念 并发和竞态 自旋锁和互斥体 设备驱动中的并发 并发和竞态的概念? 并发: 多个执行单元同时, 并行被执行; 竞态: 并发的执行单元对共享资源的访问, 导致了竞态的发生; linux驱动中竞态问题的产生原因? 多处理器SMP的多个CPU 单CPU的进程抢 中断发生(默认不进行中断嵌套) 解决并发和竞态 Linux中为何会存在编译乱序? 编译器的行为: 对内存访问时, 为了提高cache的命中率和CPU的Load/Store单元的工作效率; 再发开编译器优化时, 汇编代码并没有严格按照代码的逻辑顺序; Linux中执行乱序? 处理器运行的行为: CPU执行的时候是乱序执行的, 但是这一个乱序对于单核的程序是不可见的, 当碰到依赖点(需要后面指令结果)时会等待; 解决互斥的方法? 中断屏蔽(中断屏蔽指令): 很少单独使用 原子操作: 只能针对整数进行; 自旋锁和互斥体: 应用的最广泛; 自旋锁和互斥体 区别 自旋锁 互斥体 锁被占用时 自旋等待的时间 上下文切换的时间 阻塞/非阻塞 非阻塞访问的内存区 进程级: 多个进程对资源的互斥; 阻塞访问 应用 访问时间较短;中断和软中断情况 访问时间较长, 存在上下文切换; gobalmem增加并发 gobalmem 只能使用互斥体, 不能使用自旋锁 12copy_from_user()copy_to_user() 导致阻塞的函数存在, 只能使用互斥体; Linux设备驱动中阻塞和非阻塞I/O 实现 阻塞 非阻塞 方法 等待队列中进行进程的唤醒 轮训函数实现 实现函数 sleep_on(); wake_up() poll(); select(); epoll() 虚拟字符设备 globalfifo() 非阻塞方式中的poll函数? 设别驱动中的poll()函数不会阻塞; 但是与 poll(); select(); epoll()相关的系统调用会阻塞的等待至少一个文件描述集合可访问或超时; Linux设备驱动中的异步通知与异步IO异步通知 设备驱动: 异步通知的概念 一旦设备就绪, 则主动通知应用程序, 这样应用程序就不用查询设备的状态; 机制: 信号驱动的异步I/O; 信号: 在软件层次上对中断机制的模拟, 信号是异步的; 一个进程收到一个信号, 与处理器收到一个中断请求可以说是一样的; 进程能捕获的SIGIO信号? 除了SIGSTOP和SIGKILL两个信号外, 进程能够忽略或捕获其他的全部信号; 设备驱动与用户程序之间的异步通知 用户空间: 设置文件的拥有者(设置进程) , FASYNC标志(检查信号的变更), 捕获信号 内核空间: 响应文件的拥有者, FASYNC标志的设置, 资源可获得时释放信号 在globalfifo驱动中增加异步通知 123456用户空间 fcntl(); 设置文件的拥有者, 设置FASYNC变更机制 signal(); 捕获信号设备驱动: int fasync_helper(); // 处理FASYNC标志变更的函数;void kill_fasync(); // 释放信号量; Linux的异步IO Linux常用的输入/输出模型 同步IO(Synchronization): 当请求发出之后, 应用程序就会阻塞, 直到请求满足为止; AIO异步IO(Asynchronous ): 应用程序发起IO请求后, 直接执行, 并不等待IO结束 过一段时间查询之前的IO请求完成的情况; IO请求完成后会自动调用与IO完成绑定的回调函数; glibc 提供一个不依赖于内核完成的AIO glibc中包括的函数 1234aio_read();aio_write();aio_error(); //确定请求状态;aio_return(); //异步IO需要调用该函数, 实现返回值的读取; 本质: 借用了多线程模型,新的AIO线程与发起AIO的线程通过pthread_cond_signal(), 实现线程间的同步 内核空间实现AIO libaio实现异步AIO的优点? AIO可以一次性发出大量的read/write调用, 并且通过通用层的IO调度获取更好的性能; 用户程序可以减少过多的同步负载(多线程同步) 内核空间实现的机制 12io_submit(); //AIO的请求都用io_submit进行下发;gcc aior.c -o aior -laio; // 加上laio的库进行编译 AIO与设备驱动 用户空间调用io_submit()后, 生成一个iocb结构 内核对应生成与之对应的: kiocb结构; 中断和时钟 Linux中断中引入顶半部和底半部分离的机制? ISR的执行并不存在于进程的上下文切换中, 要求ISR要尽可能短; 底半部执行的方法? 中断的分类 根据中断的来源? 内部中断: 来自于CPU内部(软件中断指令, 溢出, 出发错误); OS从用户态切换到内核态: 借助cpu内部的软件中断 外部中断: 来自于CPU的外设请求; 中断是否可屏蔽? 内部中断: 不能屏蔽 外部中断: 可屏蔽 中断入口的跳转方法不同? 向量中断: CPU为不同的中断分配不同的中断号, 当检测到某个中断到来后, 自动跳转到对应中断号的地址执行; 不同的中断号有不同的入口地址 非向量中断: 多个中断共享一个中断入口地址, 在软件内部判断中断号 嵌入式系统和 X86中的中断? PIC(program interrupt control): 可编程中断控制器; MASK寄存器: 中断屏蔽; PEND寄存器: 中断使能; ARM多处理器常用的中断? GIC(Generic interrupt control): 通用中断控制器 支持三种中断 SGI(software generated interrupt): 软件产生的中断, 用于多核间通信; PPI(private peripheral interrupt): 某个CPU的私有的外设中断, 只能发给特定的CPU SPI(Shared peripheral interrupt): 共享外设中断; 中断从CPU0产生, 将中断设定到CPUi上; Linux 中断编程 中断申请 12request_irq(); free_irq(); // 内核提供的函数devm_request_irq(); // devm开头的API申请的是内核"managed"资源, 一般不需要显示释放 中断屏蔽和使能 123456void disable_irq(int irq); // 等待目前的中断处理完成;void disable_irq_nosync(int irq); // 立即返回;void enable_irq(int irq); // 中断使能#define_local_irq_save(flags); // 禁止所有中断, 保存状态到flag中 #define_local_irq_restore(flags)void local_irq_disable(void); // 禁止所有中断, 且不保存状态 # void local_irq_enable(void) 底半步机制实现 tasklet 执行上下文方法: 是软中断, 执行时机通常是中断顶部返回 1tasklet_schedule(); // 进行调度 工作队列 执行上下文方法: 内核线程, 可以进行调度和睡眠; 12INIT_WORK(); //将工作队列和处理函数绑定schedule_work(); // 工作队列的调度 cmwq(Concurrency-managed woekqueues): cmwq维护了工作队列的线程池, 以提高并发性 软中断 和tasklet一样运行与中断上下文, 属于原子上下文的一种, 不允许睡眠 内核定时器 软件意义上的定时器: 最终依赖于硬件定时器实现, 在内核时钟中断发生后检测各定时器是否到期, 到期后的定时器处理函数将作为软中断在底半部执行; Linux内核中提供一组函数和数据结构来完成定时处罚工作或者完成某周期性的事务; 1time_list()； // 定时器的结构体，设置到期时间 定时器的到期时间 1jiffies + Hz; // jiffies 表示定时时间; Hz 表示1s; 内核中的延时 忙等待: ndelay(), mdelay() 配合硬件上短延时; 睡眠等待: msleep()对应于时间精度要求不高的延时; 内存与I/O访问 内存空间和I/O空间的访问 I/O空间: 通过两个指令– in/out 内存空间: 地址和指针; MMU MMU: 内存管理单元, 实现虚拟地址和物理地址的快速转换; TLB: MMU的核心部件, 他缓存少量的虚拟地址与物理地址的转换关系, 式转换表cache; TTW(translation table walk): 转换漫游表 当TLB中没有缓冲对应的地址转换关系时, 需要通过内存中的转换表访问得到VA-PA的对应关系 TTW成功后, 将结果添加到TLB中 Linux中与硬件无关的四级页表目录 PGD, PUD, PMD, PTE Linux内存管理 分为用户空间(0-3G)和内存空间(3G-4G) 每个进程的用户空间是完全独立, 互不干涉的, 用户进程各自有不同的页表. 内存空间: 有内核负责映射, 不会跟着进程改变, 是固定的;内核空间的虚拟地址到物理地址的映射被所有进程共享; 内核地址空间, 由低地址 – 高地址 内存存取 用户空间动态分配内存 12malloc(), free(); // 内存申请和释放malloc() 实现的机制: 通过brk() 和 mmap()两个系统调用从内核申请内存 内核空间动态分配内存 | kmalloc() | __get_free_pages() | vmalloc() || ———— | —————— | ————– || 阻塞等待; | 非阻塞 | || 分配页的大小 | 2^n页进行分配 | || 物理空间连续 | 物理空间连续 | 物理空间不连续 | DMA (Direct memory Access)编程 DMA属于内核空间的一块区域, 16MB以下的空间; DMA造成Cache缓存一致性问题? Cache: 被作用于CPU对内存的缓存, 提高TLB的命中率, 从而避免CPU每次都必须要与相对慢速的内存交互数据来提高数据的访问速率; DMA: 作为内存与外设之间传输数据的方式, 不需要cpu的参与; 缓存一致性问题: 当DMA内存地址和Cache内存地址访问有重叠, 经过DMA操作后数据发生改变, 而CPU并不知道, 认为Cache中的数据就是内存中的数据, 当使用Cache映射内存时, 用的任然是陈旧的数据. 1dma_alloc_coherent(); // 对于DMA缓冲, 使用其申请空间 驱动中出现缓存一致性问题 Cache与内存不一致错误, 导致驱动无法正常运行; DMA的三个概念 基于DMA硬件使用的是总线地址, 而非物理地址 | 总线地址 | 物理地址 | 虚拟地址 || ————————– | ———————– | ————— || 从设备的角度看到的内存地址 | 从CPU,MMU看到的内存地址 | CPU核看到的地址 || 通过总线: 连接芯片 | VA—PA的映射机制 | | Linux设备驱动的软件架构思想 软件架构思想: 将设备端的信息从驱动中分离出来 设备 和 驱动分离的思想 cdev 和 file_operation : 进行分离 Linux设备和驱动挂载到同一种总线上? 对于PCI, USB, IIC, SPI 等总线, 其设备和驱动直接按照对应的总线框架编写驱动 对于独立的外设: Linux使用一种虚拟总线platform; platform虚拟总线 bus_type: 结构体中的match() 函数匹配设备和驱动; platform_device: 设备注册 platform_driver: 驱动注册, 结构体中的probe()函数用于绑定驱动和总线 如何将globalfifo字符设备, 驱动挂载到platform虚拟总线上? 将globalfifo移植为platform驱动; 在板文件中添加globalfifo这个platform_device 设备驱动分层思想 实例: SPI中实现主机驱动和外设驱动分离的思想? Linux块设备和网络设备Linux 字符设备, 块设备, 网络设备驱动的区别 区别 字符设备 块设备 数据传输单位 字节为单位 块为单位 – block(512bytes) 有无缓冲区 无须缓冲且直接读写 有I/O缓冲 访问顺序 顺序读写 随机读写, 读取不同的扇区 设备 鼠标, 键盘…(大多数设备) 存储设备 Linux目录 /dev 一切皆文件 /dev 一切皆文件 块设备驱动的结构体 block_device_operations 文件操作结构体 类似于file_operations; 但是没有读写相关的函数, 只有打开, 释放, 控制 函数 gendisk 磁盘设备结构体 使用gendisk(通用磁盘)结构体表示一个独立的磁盘设备(或分区) 块设备的I/O操作 bio, request, request_queue 结构体 bio: (block IO), 对应上层传递给块层的I/O请求; 块设备的I/O操作中: 贯穿始终的就是”请求“; 块设备的I/O操作会排队和整合; I/O调度算法, 为了完成请求的合并. 一个请求: 可以包含多个I/O | I/O调度器 | 作用 || ——————— | ———————————————————— || Noop | 实现简单的FIFO队列, 进行基本的合并, 适合基于flash存储器 || Anticipatory (预期的) | 推迟I/O请求, 等待更多I/O请求, 进行排序 || Deadline | 将每次请求延迟降到最低, 使用轮训调度器; 适用于读取较多的环境 || CFQ | 为所有任务分配均匀的I/O带宽 | 块设备驱动的任务 驱动的任务是处理请求, 队请求的排队和整合由I/O调度算法解决; 块设备驱动的核心 请求处理函数: 需要请求队列的支持, 实现块设备的随机访问 制造请求: 设备本身支持正真的随机访问 Linux网络设备驱动 网络设备驱动的作用? 完成用户数据包在网络媒介上发送和接受的设备, 他将上层协议传递下来的数据包以特定的媒介访问控制方式进行发送, 并将接收到的数据包传递给上层协议 数据包向下为发送, 向上为传递 网络设备驱动的四层结构 Linux层次化设计的作用? 实现了对上层协议接口的统一 硬件驱动对下层多样化硬件设备的可适应性; 四层结构的作用? | 四层结构 | 作用 | 特殊数据结构 || ————– | ———————————————————— | ——————- || 网络协议接口层 | 通过两个函数实现数据的接受和发送 | sk_buffer (socket) || 网络设备接口层 | 为万千设备定义统一, 抽象的数据结构体 net_device | net_device || 设备驱动功能层 | 填充net_device具体成员, 注册net_device实现操作函数与内核的挂接 | || 网络设备和媒介 | 完成数据包接受和发送的物理实体 | 网络适配器 | sk_buffer 结构体 sk_buffer 的作用? 用于Linux网络子系统各层之间传递数据, 是所有数据流动的载体 struct sk_buffer head 和 end: 指向缓冲区的头部和尾部 data 和 tail : 指向数据的头部和尾部 Linux套接字缓冲区支持分配, 释放, 变更的函数 Linux内核中使用的函数 123struct sk_buffer *alloc_skb(); // 分配一个套接字缓冲区和数据缓冲区void kfree_skb(struct sk_buffer *skb); //释放一个套接字缓冲区和数据缓冲区unsigned char *skb_put(); // 在缓冲区尾部添加数据 设备驱动中使用的函数 123struct sk_buffer *dev_alloc_skb(); // 分配一个套接字缓冲区和数据缓冲区void dev_kfree_skb(struct sk_buffer *skb); //释放一个套接字缓冲区和数据缓冲区unsigned char *skb_push(); // 在缓冲区尾部添加数据 net_device结构体 net_device的作用? 包含网络设备的属性和操作函数; open() , ioctl() 设备驱动中的数据包接收? 网络设备驱动: 以中断方式接收数据包 poll_controller(): 采用轮询方式; NAPI(new API): 接收中断来临 – 关闭接收中断 – 以轮询方式接受所有数据包直到为空 – 开启接收中断 …. 网络设备驱动的注册与注销 使用的函数 12register_netdev() ; // 网络设备的注册函数register_netdev() ; // 网络设备的注销函数 网络设备 网络设备的初始化 探测网络设备是否存在, 存在则检测设备所用的硬件资源 软件接口: 分配net_device结构体对其数据和函数指正成员赋值 获得设备的私有信息指针并初始化各成员的值; 网络设备的打开和释放 数据发送流程 数据接受流程 主要有中断引发设备的中断处理函数; 网络连接状态 网络适配器硬件电路可以检测链路上是否有载波; 载波反映了网络的连接是否正常; DM9000网卡设备驱动 DM9000一般挂在外面的内存总线上; I2C、SPI、USB驱动 Linux的理念 将主机端驱动和外设端分离，通过一个核心层将某种总线的协议进行抽象； 热插拔能力的总线 I2C和SPI不具备热插拔能力，所有会有板级信息的描述； USB和PCI总线，具有热插拔能力，没有板级信息的描述；当存在USB设备插入后，linux子系统会自动探测； Linux I2C驱动I2C驱动体系结构由三部分组成 1tree /sys/bus/i2c/ // 在sysfs文件系统下，查看i2c设备 I2C核心 ： 是I2C总线驱动和设备驱动中间枢纽，提供注册和注销方法，实现I2C的通信（Algorithm); 它以通用的、与平台无关的接口，实现I2C中设备与I2C适配器(adapter)的沟通； I2C总线驱动 对I2C硬件体系结构中适配器端的实现 I2C总线驱动填充：i2c_adapter和i2c_algorithm结构体 12（1）struct i2c_adapter and i2c_algorithm（2）控制i2c_adapter产生通信信号的函数 I2C设备驱动（客户驱动） 对I2C硬件提示西结构中设备端的实现； I2C设备驱动填充：i2c_driver和i2c_client结构体； I2C四个结构体的关系 适配器和通信 结构体关系 i2c_adapter i2c_algorithm 各自作用 对应物理上的一个适配器 对应一套通信方法 函数 master_xfer()产生I2c访问周期需要的信号，以i2c_msg为单位 关系 适配器需要i2c_algorithm产生通信时序 驱动和客户端 结构体关系 i2c_driver i2c_client 各自作用 对应一套驱动方法 对应真实的物理设备 函数 probe(), remove(), supend(), resume() BSP板级信息：i2c_board_info 关系 一个驱动支持多个物理设备；一对多 适配器和客户端 一个适配器：可以被多个client依附； 总线如何实现设备和驱动的绑定 i2c_bus的函数match()函数检测到device和device_driver匹配时，就会调用driver里的probe()函数，完成初始化适配器硬件，申请适配器需要的内存，时钟，中断等资源，最终完成适配器的注册； USB驱动USB驱动框架：分主机侧和设备侧 USB主机侧角度 USB主机侧的模块 作用 结构体 USB主机控制器驱动程序 控制插入其中的USB设备 usb_hcd; hc_driver USB设备驱动程序 控制设备如何作为从设备与主机通信； usb_driver USB核心（API）：通过定义一些数据结构和宏，功能函数；向上提供接口，向下提供编程框架；维护USB设备通信； USB从机角度 UDC设备控制器：关心底层的硬件操作； Funcation驱动：利用通用的API，通过usb_request与底层UDC驱动交互； ​ 3. USB设备逻辑包含 + 设备、配置、接口、端点四个层次 + 每个设备提供不同级别的配置信息，不同配置体现不同的功能； + 一个配置由多个接口组成； + 一个接口由多个端点组成； URB 中断的生命周期 通常包含创建，初始化，提交和被USB核心级USB主机传递，完成后回调函数被调用的过程； ARM Linux 设备树 板级代码信息的描述 对于内核来说，板级代码信息的描述是不需要存在的 123arch/arm/plat-xxx; // 这两个目录下存在着描述信息arch/arm/mach-xxx;platform_device, i2c_board_info, spi_board_info 设备树的特点 描述硬件的数据结构 设备树被命名：节点（可包含子节点）和属性（名称和值） 设备树可以将硬件的细节直接传递给Linux，无需在内核中进行大量的冗余编程； 通过设备树替代用于注册的板级代码，驱动也以新的方式与.dts中定义的设备节点进行匹配； 设备树的传递和展开 Bootloader 在启动时，会将设备树.dtb的入口地址传递给内核，内核会将其进行展开出linux内核中的platform_device,i2c_client, spi_device等设备 设备用到的内存，IRQ等资源，也被传递给了内核，内核会将这些资源绑定给展开的相应设备； 设备树的组成和结构 结构描述 描述 DTS 文件.dts是一位种ASCII文本格式的设备树描述;.dtsi：dts中的公共部分，类似于.h文件；(.dts包含.dtsi) DTC(device tree compiler) 是一个工具，将 .dts(ascii文本) – 编译为 – dtb(二进制文件) DTB(device tree binary) 是.dts被DTC工具编译后的二进制格式的设备树描述 绑定(Binding) 对于设备树中的节点和属性，如何描述设备的硬件细节，需要.txt文档 Bootloader Uboot运行 fdt addr命令设置 .dtb的地址 Linux内核移植 移植Linux到全新的SMP Soc上需要底层硬件提供 定时器节拍 中断控制器 SMP启动 GPIO 时钟 pinctrl (pin control) 这些底层功能被封装好后，其他设备驱动只能调用内核提供的通用API 这些API底层：填充内核规定好的回调函数 调试工具]]></content>
      <categories>
        <category>driver</category>
      </categories>
      <tags>
        <tag>platfrom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uC/OS-III]]></title>
    <url>%2F2019%2F08%2F19%2FuC-OS-III%2F</url>
    <content type="text"><![CDATA[嵌入式实时操作系统实时系统 和 实时内核 实时系统的概念? 系统要求: 对任务 处理结果的正确性 和 处理过程的实时性 都有严格要求的系统. 硬实时和软实时系统的区别: 对处理过程超时及超时带来的后果的容忍度; 硬实时: 不允许处理过程超时 前后台系统的分类 前台结构(中断级): 中断服务程序(ISR)用于处理系统的异步事件; 后台结构(任务级): 应用程序是一个无限的循环, 循环中调用相应的函数完成相应的操作; 任务的响应延迟: 应用程序循环到该任务时, 花费的时间; RTOS(real-time- Operating system) 系统和内核的区别? 实时系统: 内核 + 高层系统服务(文件系统, 协议栈) 实时内核(uC/OS-III) uC/OS-III 定义? 定义: 是一个可裁剪, 可固化, 可剥夺的多任务内核, 管理的任务数目不受限制; 本质: 实时内核(用于管理的软件代码) 实时内核(uC/OS-III )的作用? 作用: 负责管理这些任务的调度, 使得CPU在多个任务之间进行切换; 任何时刻, 单个CPU只能执行一个任务; 多任务: 系统功能被分成多个任务, 每个任务(线程)完成一个功能; 可剥夺型内核: 在任何时刻都可以发生任务调度, 任务调度使得CPU总是运行处于就绪状态并且最高优先级的任务; 多任务数目受限 : 受限于RAM的大小; uC/OS-III 的特性 极短的关中断时间: 通过锁定内核调度的方式, 不是通过关中断方式保护临界段, 使得关闭中断时间降到最低; 确定性: 中断响应时间确定; 出错检验: err = OS_ERR_NONE 防止死锁: 通过超时检测机制; 时钟节拍处理: 通过时钟节拍进行处理; 中断服务程序: 函数内部不能有阻塞(等待), 中断处理的时间总是很短; 本书命名规则 以”OS_”开头 调试工具: uC/Probe uC/OS-III 软硬件结构 硬件结构 PCU + 定时器 + 中断控制器 通用异步收发器(UART) + ADC + 以太网控制器; 软件结构 应用程序 + 相关代码 … uC/OS-III 代码描述应用程序 应用程序完成过程? 用户调用uC/OS-III提供的一系列函数(任务)完成相应的功能; 函数作用: 管理信号量/消息队列/互斥信号量; 每个任务(线程)? 在RTOS中, 任务也称之为线程; 每个任务多有属于自己的栈; 单任务的应用程序执行过程? 1)启动关中断: 启动代码引导CPU, 从main()函数开始执行; 关闭中断: 保证系统启动期间中断关闭 1BSP_IntDisAll(); // 关闭所有中断 2)初始化内核,创建任务: 初始化内部变量和数据结构, 创建2-5个任务(至少两个) 1OS_Init(&amp;err); // 先初始化, 才能使用 空闲任务: OS_IdleTask() 在其他任务不就绪时, 就运行空闲任务, 为了保证CPU处于运行状态; 时钟节拍任务: 负责时间管理; 3) 创建任务 1OS_TaskCreate(); // 创建任务, 先创建在使用 为每个任务分配: TCB + 堆栈 + 优先级 + 其他参数; 只能内核进行访问, 应用程序不能访问; 4) 执行任务 1OS_Stat(); 最后: 1应用程序中的每一个任务都必须调用一个可以引发任务**等待某事件**的函数; 多任务应用程序创建执行过程? 存在临界区共享问题; 临界区代码保护 临界区代码的保护方式? 关中断: ISR 和任务 都能访问的代码; 调度器上锁 : 仅任务能访问的代码; 参数配置起效果 123os_cfg.h OS_CFG_ISR_POST_DEFERRED_EN == 0 ; // 使用关中断方式 OS_CFG_ISR_POST_DEFERRED_EN == 1 ; // 使用调度器上锁的方式 测量中断关闭时间 设置寄存器 1CPU_CFG_INT_DIS_MESA_EN == 1; // 打开后,才能测量中断时间 测量两个时间: 总的关闭中断时间 和 每个任务中断关闭时间; 计算: 从中断关闭时开始计时, 到重新打开中断; 单位: 与系统时间戳CPU_TS的单位一致 测量调度器上锁时间, 类似 设置寄存器 1CPU_CFG_SCHED_LOCK_TIME_MESA_EN == 1; // 打开后,才能测量调度器锁定时间 任务的介绍 多任务等待单个内核对象? 四个内核对象 多任务同时等待多个内核对象? 只允许多信号量 和 多个消息队列; 不允许同时等待事件标志组和互斥型信号量; 1OSPendMulti() // 一旦有对象被发送, 那么OSPendMulti立即返回; 任务管理 任务的概念描述? 定义: 是一个线程, 也就是一个简单的程序; 分类: 运行至完成型; 无限循环型; 任务和C函数的区别? 任务执行过程: 是顺序的无限循环; 任务执行完后: 不允许返回; 任务和c函数: 通过使用参数传递, 实现函数的可重入性; 任务管理的概念? 多任务的调度, 和CPU使用权的切换 任务优先级的分配? 优先级的值 = 任务索引下标 优先级: [0, N-1] 0 : 优先级最高, 留给ISR [1, N-1] : 分配给不同的任务 允许: 多任务拥有统一由县级 每个任务分配的堆栈空间? 分配但不释放: 动态分配堆栈空间, 但是不允许释放, 否则会存在空间碎片; 堆栈溢出检测: OS_TCB中的成员 .StkLimitPtr 指针: 指向分配空间的位置; 栈空间的阈值: 无限接近MyTaskStk[0] 栈空间分配的大小 计算值 * 安全系数(1.5/2) 任务的5种状态? 休眠态 代码已经写入代码空间, 但是uC/OS-III 不知道它的存在; 任务删除: 并不是删除代码, 而是使其无法获得CPU使用权 就绪态 任务准备运行时, 就会进入这个状态; 就绪表: 用于对任务优先级进行排序; 运行态 优先级最高的任务进入; 单核CPU: 任何时刻只有一个任务进入该状态; 等待态 当一个任务所等待的事件没有发生时, 进入等待 等待时: 不消耗CPU事件, 会调用下一个优先级的任务进行执行; 中断服务态 允许CPU中断时, 当前任务会被挂起, CPU开始执行ISR 处于uC/OS-III 内部任务的8种状态? 就绪: 任务实现其功能的唯一途径; 延时: 任务可以让自己延时等待一段时间 等待: 任务等待某个事件的发生, 不发生就一直等待; 带超时检测的等待: 等待超时时才能运行 被挂起: 运行中的任务被挂起, 在恢复前是不能获得CPU的使用权的 恢复: 其他任务来恢复该任务的运行状态 等待且被挂起: 在等待状态被挂起 恢复: 当等待的事件发生, 并且挂起状态取消, 任务才能运行 带超时检测的等待且被挂起: 系统内部(的五个任务)? 空闲任务(必须创建) 1OS_IdleTask() , os_core.c; // 当其他任务都处于未就绪状态时, 空闲任务运行 空闲任务运行时, 两个计数器不断递增 OSIdleTaskCtr: 表示空闲任务的活跃度 OSStatTaskCtr: 统计程序运行是CPU的利用情况 优先级最低: 为(n-1) 时钟节拍任务(必须创建) 1OS_TickTask(), os_tick.c; // 实时操作系统的时钟源 用于跟踪任务延时和任务等待超时; 硬件定时器: 10-1000Hz 统计任务 1OS_StatTask(), os_stat.c; // 可以再系统运行时, 统计CPU的利用率 定时器任务 1OS_TmrTask(), os_tmr.c 定时器是一个递减的计数器, 当计数器减为0时, 就会做一个操作 操作: 回调函数 中断服务管理任务 1OS_InitQTask(), os_int.c 禁止或者打开中断, 给调度器上锁或者解锁; 优先级最高, 为0; 不允许存在阻塞; CPU实际利用率计算?$$CPU = 100 - (100 * OSStatTaskCtr )/OSStatTaskCtrMax$$ 当OSStatTaskCtr计数到最大值时 12OSStatTaskCtr = [0, 10 000 000];实际的最大值: 7500 000; 应用程序的运行会花费 : CPU = 25% 的时间; 任务就绪表 任务就绪表由两部分组成: 就绪任务优先级位映射表 1OSPrioTbl[ ]; // priority , 用于标记哪个优先级下有任务就绪 就绪任务列表 1OSRdyList[ ]; // 记录每一个优先级下所有就绪的任务 查找就绪任务 优先级 == 索引号 顺序查找就绪任务优先级位映射表, 直到遇到第一个非零位 至少会找到一个就绪任务而结束; – 空闲任务列表 任务调度 任务调度的概念: 负责确定下一个要执行的任务; 可剥夺型: 当一个事件发生(每个任务都会等待事件发生); 也就是任务将信号量释放或者发布消息时; 并且使得更高优先级的任务就绪时, CPU的控制权就会被剥夺, 转交给更高优先级的任务 同一优先级的任务执行 采用时间片轮转的方式执行; 时间片的长度 = n * 时钟节拍 uC/OS-III 存在两个调度器 任务级调度: 1OSSched() -- &gt; OSCtxSw() // 任务调度函数入口 -- &gt; 任务切换功能函数 ISR中断服务程序调度: 1OSIntExit() -- &gt; OSIntCtxSw() // ISR调度函数入口 -- &gt; 中断任务切换功能函数; 任务切换 任务切换 过程: 保存当前任务现场(CPU相关寄存器)到当前任务的堆栈中, 恢复新的优先级最高的任务现场; 时间: 取决于多少寄存器需要保护和恢复; 虚构CPU的15个寄存器 + 状态寄存器 R0-R13 : 正常的寄存器 R14: 任务级堆栈指针(TSP) ; R14’ : 中断堆栈指针(ISP) SP指针指向最后一个入栈的寄存器R13(栈顶) TSP 和 ISP 存在于不同的内存区域; R15: 程序计数器(PC) PC和SR 先进入堆栈中 SR: 状态寄存器 具体的切换过程 保存: 每个任务都有一套堆栈寄存器, 任务运行在cpu的堆栈寄存器中, 当任务切换时, 将cpu的寄存器值保存在当前任务的堆栈中 恢复: 在返回时, 同时恢复CP和SR 两个切换函数, 对应任务级和ISR级 注意: OSIntCtxSw() 仅需要执行任务切换的后半部分工作, 因为uC/OS-III 进入终端服务程序时, CPU寄存器已经得到保存 中断管理 多个中断发生时, 应该怎么处理; 实时多任务内核的重要指标: 中断关闭总时间 定义: 内核在运行临界区代码前关闭中断, 在临界区代码完成后重新打开中断; 这段时间: 中断关闭的总时间 中断中其他时间定义 时钟(系统)节拍: 只有器存在, 才能测量时间; 中断延迟时间: 最大中断关闭时间; 中断响应时间: 中断被识别 – &gt; ISR中断代码开始运行的时间; 中断恢复时间: ISR代码运行完毕 – &gt; 下一个任务代码开始运行的时间; 任务等待时间: 从中断发生 – &gt; 任务代码重新开始执行的时间; 中断控制器的作用? 作用: 处理多个中断请求, 为其设置优先级, 记录哪些中断还未处理, 并将最高优先级的中断ISR的地址传递给CPU; 优先级定义: 16个中断优先级[15,0], 优先级最高是15 中断优先级 &gt; 任务优先级 中断服务程序ISR? 所有中断源共用同一个ISR: 缺点: 必须对一个中断请求源处理全部完成, 才可能处理新发生的更高中断级别请求; 造成所有中断延迟时间最长; 每个中断源拥有单独的ISR; 根据中断向量表, 直接跳转到对应的ISR 允许 : 中断嵌套; 直接发布和延时发布? 针对: 从中断中发布消息或者信号; (每个任务都会等待一个事件发生) 选择: 取决于中断响应时间, 任务响应时间的要求; 直接发布: 采用关中断的方式, 保护临界区代码, 防止ISR访问临界区代码; 延时发布: 采用给调度器上锁的方式, 保护临界区代码; 增加: 中断队列 任务挂起表 任务挂起表的作用? 当一个任务等待内核对象的发生时, 将该任务放在挂起表(等待表)中; 内核对象: 信号量 / 互斥信号量 / 事件标志组 / 消息队列 任务挂起表: 跟踪正在等待内核对象的任务; 任务挂起表组成 由OS_PEND_LIST类型的结构体组成, 并且进一步封装到另外一个数据类型OS_PEND_OBJ; 任务如何链接任务挂起表? 表中的任务: 不直接链接到任务挂起表; 通过一个中间数据结构OS_PEND_DATA进行链接; 将等待内核对象的任务放入挂起表的同时, 将该数据结构放到该任务的栈空间中; uC/OS-III 的管理时间管理 uC/OS-III提供一种延时服务? 任务可以将自己挂起, 延时一段指定时间, 当指定时间结束后在运行; 延时的时间长度指定方式 时钟(系统)节拍 小时/分/秒/毫秒 时间接口函数 定时器管理 定时器的本质? 定时器是一个递减计数器; 当其值递减到零时, 自定义的回调函数就会立即被调用; 回调函数 : 在定时器任务内完成, 此时调度器是上锁的, 回调函数不允许任何阻塞调用; 定时器创建? 定时器需要先创建后使用 1OSTmrCreate(); // 创建定时器并指定其运行模式 创建以后: 启动(重启) , 停止 任意次数; 1OSTmrStart(); // 启动或者重启定时器 定时器运行的第三种模式? 单次运行模式 dly(节拍数) &gt; 0; period(周期) == 0; 计数器从dly开始, 递减到0时, 就调用回调函数,之后就不在进行定时 除非使用OSTmrStart(), 启动或者重启定时器 周期定时器(无初始延时) dly(节拍数)== 0; period(周期) &gt; 0; 计数器递减到0时, 重新设置初值为period, 重新计数 周期定时器(有初始延时) dly(节拍数) &gt; 0; period(周期) &gt; 0; 第一个周期有dly设置, 后面的周期由period设置; 定时器的状态? 共享资源的管理 共享资源好处和弊端? 共享内存能让任务之间的信息交互变得简单; 但造成了任务对数据的独占性造成了影响; 共享资源的种类? 不同任务处于同一寻址空间时, 就会造成数据共享问题; 种类: 变量(static and 全局), 数据结构体, RAM中的表格, I/O设备中的寄存器; 最常用的独占资源和创建临界区的方法? 关中断; 禁止任务调度; 使用信号量 使用互斥型信号量; 总结 任务等待某事件发生的方式? 等待资源的任务: 执行等待, 或者挂起操作; 超时等待 time &gt; 0: 只愿意在一段时间内等待时间; 事件不发生, 任务进入就绪状态等待运行, 并且任务返回等待超时错误 time = 0: 任务一直处于等待事件的状态; 阻塞/非阻塞 阻塞: 等同于 – 任务会一直等待事件的发生; 调度器就会介入, CPU会执行另外一个优先级高的就绪任务; 非阻塞: 任务在就绪状态, 事件未发生, 则返回错误; 解决死锁问题? 任务先得到全部资源, 在做下一步工作 任务用相同的顺序盛情多个资源;(不用全部获取) 在调用请求信号量的函数时, 设置超时时间; 关中断/开中断 使用条件? 共享资源访问的速度很快, 小于中断关闭的时间; 关闭所有的中断(接收不到其他的中断请求) 弊端 影响系统的中断延迟时间; 给调度器上锁 使用条件? 任务不需要和ISR共享资源; 原因: 虽然给调度器上锁, 但是此时中断一旦发生, 即便在临界区内, 该任务也会被挂起, 执行ISR程序; 但是虽然造成更高优先级任务就绪, 但是此时处于上锁状态; 中断返回后, 仍然执行挂起任务; 调度器上锁时: 禁止用户使用阻塞型调用; 信号量 (多用于同步) 信号量使用的条件? 只有任务级才能使用, ISR不能使用; 先创建才能使用; 引入信号量: 不会增加系统的中断延迟; 信号量分类 二值信号量: 1/0 计数型信号量: 初始化一个信号量的值 信号量导致一个问题 – 任务级反转? H的优先级最高, 等待L发布一个事件: 但是此时最低优先级L占用共享资源; 同时中等优先级的M等待的事件发生: 此时剥夺L的CPU使用权, 运行完后返回给L; 最后, L运行完后, 释放信号给H, 此时H运行; 结果: 最高优先级H, 最后才运行; 互斥型信号量(MUTEX) MUTEX使用的条件? 只有任务级才能使用, ISR不能使用; 对共享资源的访问, 有截止时间限制的任务; 解决: 任务反转的问题; MUTEX如何解决 任务反转的问题? 优先级集成的方式; 一旦出现高优先的任务H访问共享资源, 占有该资源的任务优先级将被提升到与H一样的优先级; 完成访问后, 会恢复到原先优先级 任务同步 任务同步的概念? 任务 : 与中断服务程序(ISR) 或者 其他任务进行同步; 同步概念: 当ISR执行时, 可以通过给任务发信号, 告诉该任务等待的事件发生; ISR完成后退出, 调度程序根据信号和优先级完成调度; 任务不能同步ISR; (ISR 不能阻塞,且时间要短) 任务同步方式? ISR和任务可以通过三种方式: 向一个或多个任务发信号 信号量 / 任务信号量 / 事件标志组; 信号量和任务信号量 区别? 信号量: 需要声明一个外部信号量对象; 信号任务量: 创建任务时自动创建, 适用于给单个任务发信号; 信号任务量服务函数的速度 &gt; 信号量的服务函数; 信号量 信号量的API? 先创建才能使用; 单向同步: 例子: I/O操作 任务 – &gt; 同步任务 ; ISR – &gt; 同步任务 信用记录 信号量可以被发布多次; 当任务优先级位于就绪状态是, 该任务会被连续执行多次, 执行次数与发布次数相同; 多个任务等待同一个信号量 广播: 使得等待同一信号的任务, 否处于就绪状态, 执行优先级最高的任务; 任务信号量 任务信号量的使用条件? 任务信号量: 内嵌信号量, 创建任务时, 自动被创建; 明确知道该给哪个任务发信号; 任务信号量的API OS_TaskSemPost() : 将目地任务控制块的地址作为其参数; 双向同步 双向同步, 只能用于任务之间, 不能用于ISR之间 事件标志组 事件标志组的使用条件? 当任务需要与多个事件同时发生同步时, 使用事件标志组 ; 同步机制: 或同步, 与同步; 使用事件标志时? 所有满足等待条件的任务都会进入就绪状态; (类似于广播) 只有任务: 才能创建和删除flag; 任务和ISR: 都能发布标志 事件标志组API接口? 消息传递 消息传递的作用? 当一个任务或者ISR: 和另外一个任务交流消息时,; 信息传递称之为: 任务间通信; 任务在等待消息时: 不占用CPU处理时间; 任务间信息传递的方式? 全局变量: 任务 与 ISR之间通信只能使用 全局变量的值: 需要进行查询才能得到 发布消息: 使用消息队列间接发布; 直接发布给任务 消息的发布 消息的本质: 指向消息(数据)的指针; 消息包含几个部分: 指向数据的指针, 表明数据长度的变量, 记录消息发布时刻的时间戳; 消息发布: 使用引用传递, 不是值传递;(不发生值的拷贝) 消息必须保持可见性? 可见性: 消息变量必须在接收消息任务代码范围内有效; 指针传递消息, 必须保持数据不能被改变; 消息的创建 消息通过OS_MSG结构体发布, uC/OS-III 维护着一个OS_MSG消息缓冲池; 发布消息时: 通过uC/OS-III从空闲的OS_MSG消息缓冲池中获取可用的OS_MSG; 消息队列的种类? 外部消息队列: 需要进行创建才能使用 适用于: 多任务都需要等待一个消息队列中的消息时, 分配一个OS_Q对象; 任务内建消息队列 用户明确: 消息目的接受任务 适用于: 单任务等待消息 消息发布的例子 双向同步 需要使用两个**消息队列**(外部/内建)进行同步; 每个消息队列只能容忍一则消息 流量控制 生产者和消费者模型: 只有生产者产生数据, 消费者才能消费数据; 流量控制: 数据大小进行控制; 客户端与服务端消息传递 存储管理 存储空间的动态分配? 使用malloc() 和 free() 动态分配和释放存储空间 缺陷: 产生存储碎片, 函数执行时间无法确定; uC/OS-III 提供一种替代函数的方法? 将连续的大块存储空间进行分区管理; 每个分区中包含整数个大小相同的存储快; 只使用malloc() 进行分配, 不释放空间; 应用程序申请的空间: 得到不同分区中, 不同大小的存储快; 1OSMem???() uC/OS-III 的移植]]></content>
      <categories>
        <category>Operate System</category>
      </categories>
      <tags>
        <tag>uC-OS-III</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TheLinuxCommandLine]]></title>
    <url>%2F2019%2F08%2F05%2FTheLinuxCommandLine%2F</url>
    <content type="text"><![CDATA[TheLinuxCommandLine 夺回计算机管理权 只有知道计算机正在做什么你才能够拥有这种“自由” 什么是shell shell 和 Termial关系 shell : 是一个程序, 接受从键盘输入的指令, 然后将其传递到OS执行; Termial : 可以输入命令行; 交互关系 人和Tremial 进行交互 Termial 用于和shell 交互; shell 用于和操作系统交互 什么是命令 是一个可执行程序; 是 一 个 内 建 于 shell 自 身 的 命 令。 是一个 shell 函数。 是一个命令别名。我们可以定义自己的命令,建立在其它命令之上。 shell 命令 显示作用 shell命令 作用 日期 date 令显示系统当前时间和日期, 输出一行 cal 输出整个月的日期 空间磁盘 df 查看磁盘所有的dev剩余空间的数量 free 只显示剩余空间和使用空间 终止 exit 终止终端会话 目录显示 pwd 显示当前工作目录 print current working directory cd 更改目录; 相对和绝对路径 cd - 返回工作目录到先前目录 ls / ls -a 列出目录下的文件名 / 包含两个目录文件 ls -l / ls -al 当前目录下文件的详细信息 / 包含两个目录文件 stat &gt; ls (作用比较) 显示文件的修改时间信息, 包括文件的元数据; 文本类型 file name 输出文件所属的类型 less name less 命令是一个用来浏览文本文件的程序。 双击 + 鼠标中键 命令行文件名的复制和粘贴 操作文件 cp 复制文件和目录 (通配符) mv 移动/重命名文件和目录 mkdir 创建目录 rm —删除文件和目录; 小心使用命令 ln / ln -s —创建硬链接和符号链接 命令操作 type command 显示命令的类别,给出一个特定的命令名 which 显示一个命令的位置 help 得到 shell 内部命令的帮助文档 man 一个特殊的叫做 man 的分页程序,可用来浏览他们 whatis 显示非常简洁的命令说明 info 显示程序 Info 条目 重定向 cat cat 命令读取一个或多个文件,然后复制它们到标准输出 less 将内容显示在标准输出 sort 排序文本内容; \ 通过管道线: 将多个命令结合使用 wc 打印行,字和字节数 grep 打印匹配行; 用作正则表达式 head / tail -n 打印文件开头部分/结尾部分 unip 忽略重复行 sort foo.txt \ uuip 文本操作 echo 显示一行文本 echo + 通配符 实现路径名展开 { }; “ “; ‘’ 引用和展开是相反的 键盘操作 clear -清空屏幕 history 显示历史列表内容 其他的光标移动命令 权限 chmod 更改文件模式 chown 更改文件所有者 su/sudo 有区别的 进程 ps / ps x 查看进程信息 / 查看所有进行信息 pid top 动态查看进程状态 bg / &amp; 让进程处于后台 fg %1 让进程返回前台;跟随着一个百分号和工作序号 kill all 杀死进程 线程 cat /proc/pid/status // 查询对应pid 的线程数量 环境变量 printenv –打印部分或所有的环境变量 set 设置环境变量 export 导出环境变量,让随后执行的程序知道 source 激活设置 文本编辑器 nano 第一个基于文本的文本编辑器,nano。 gedit 图形化编辑器 vi 命令行编辑 存储媒介 mount / umount 挂载 / 卸载 一个文件系统 mksf 创建文件系统 dd —把面向块的数据直接写入设备 网络系统 ping - 发送 ICMP ECHO REQUEST 软件包到网络主机 traceroute 打印到一台网络主机的路由数据包 wget 非交互式网络下载器 netstat 程序被用来检查各种各样的网络设置和统计数据。 ssh SSH 解决了这两个基本的和远端主机安全交流的问题 查找文件 locate –通过名字来查找文件 locate zip \ grep bin find 程序能基于各种各样的属性, 查找文件 归档和备份 gzip / bzip2 是文件压缩程序: tar / zip 归档程序: 格式化输出 fmt 一个简单的文本格式转换器 printf –一个文件格式系统 编译程序 make 只是构建需要的部分,不是重新构建所有的内容。 绝对路径 / 相对路径 绝对路径 : 从根目录开始, 直到它的目的地 相对路径 : 相对与当前目录 一对特殊符号表示相对位置 “ . “ : 指的是工作目录 “ .. “: 工作目录的父目录; ls -l 长格式输出 第一个字段 d/-rw-r–r– 的含义 第一个字母 : 文件类型 是 “ d “ : 表示目录 是 “ - “ : 表示普通文件 后面三个字段: 文件权限 文件所有者权限 文件所属组成员权限 其他所有人访问权限 read / write / exec(执行) 后面的字段 文本的定义 less : 浏览文本文件的程序 less 就是 more(禅语:色即是空) 文本 : 是简单的字符与数字之间的一对一映射。 less 常用的键盘命令 操作文件的5个命令通配符: 快速匹配文件名 shell 提供了特殊字符来帮助你快速指定一组文件名 CP 复制命令 cp复制的两种方式 12$ cp file1 file2 // 复制单个文件或目录 “item1” 到文件或目录”item2”$ cp file... directory // 赋值多个项目到同一个目录 cp 的附加属性 赋值目录中的文件到另外的目录下时: 目的目录需要存在 mv移动 mv的属性和cp基本类似, 只是mv移动后, 源目录下的文件会被删除; 硬链接和软链接 硬链接的缺陷 一个硬链接 : 不能关联它所在文件系统之外的文件 一个硬链接不能关联一个目录。 硬链接的特性 你要记得一个文件至少有一个硬链接, 因为文件名就是由链接创建的 符号链接特性 如果你往一个符号链接里面写入东西, 那么相关联的文件也被写入; 符号链接删除: 链接仍然存在,但是不指向任何东西, ls 呈现红色 1$ ln -s ../fun dir2/fun-sym // 不同文件下的目录链接 重定向操作(I/O)重定向 标准输入,输出,和错误: 默认情况下 标准输出(fd=1)和标准错误(fd=2) : 都连接到屏幕 标准输入(fd =0) : 连接到键盘 重定向标准输出 I/O 重定向允许我们来重定义标准输出送到哪里。 1$ echo hello &gt; file // "&gt;" 将字符hello重定向到文件FILE 把重定向结果追加 重定向文件: 从开头重写文件; 1$ echo word &gt;&gt; file //" &gt;&gt; " 使用这个进行追加 重定向标准错误 文件描述符 “2”,紧挨着放在重定向操作符之前 当文件不存在的时候就报错 1$ ls -l file 2&gt; log.txt // 将文件FILE的信息输出到文件.txt中 重定向标准输出和标准错误 到同一文件 12$ echo hello &gt; file 2&gt;&amp;1 // 通过 " 2&gt;&amp;1 "$ echo hello &amp;&gt; dile // 通过 " &amp;&gt; " cat 命令 只输入cat 12$ cat // 等待键盘标准输入, 将用户输入的结果, 通过屏幕显示;$ cat &gt; file.txt // 等待键盘标准输入, 将用户输入的结果, 重定向到文件 们把标准输入源从键盘改到文件输入 1$ cat &lt; file.txt // 将文件内容作为标准输入, 然后将其内容屏幕显示; 管道线 管道线: 命令可以从标准输入读取数据,然后再把数据输送到标准输出 1$ ls -l file | less // 将文件内容进行标注输出 通过管道线将多个命令综合输出 12$ ls /usr/bin | sort | uniq | grep zip // 匹配zip出现的位置$ ls /usr/bin | sort | uniq | wc -l // 显示次数 文本操作 echo 操作 + 通配符? 实现路径名展开 123$ echo * // 通配符展开$ echo ~ // 显示当前用户目录$ echo $USER // 用户展开 进行算数操作 1$ echo $((2 + 2)) // 算术表达式展开使用这种格式:$((expression)) 花括号展开 花括号展开模式可能包含一个开头部分叫做报头,一个结尾部分叫做附言。 1$ echo &#123;Z..A&#125; 用于创建一系列的目录, 或者文件 1$ mkdir &#123;2007..2009&#125;-0&#123;1..9&#125; &#123;2007..2009&#125;-&#123;10..12&#125; 双引号 意味着单词分割,路径名展开,波浪线展开,和花括号展开都被禁止 1$ ls -l "two words.txt" // 直接显示文件名的详细信息 ,除了 $,\ (反斜杠),和 ‘(倒引号)之外, 其他字符则失去它们的特殊含义, 1echo "$USER $((2+2)) $(cal)" 单引号 禁止所有的展开 12 $ echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER// 直接输出文本内容, 不进行展开 grep 正则表达式 一个连行符 : 由一个斜杠字符其后紧跟一个回车符组成。它们之间不允许有空白字符。 快捷键键盘操作 移动光标 修改文本 vi编辑 位置 VI的基本命令 功能 先按Esc 退出插入模式之后才能使用 行编辑 k - j - h - l 上 - 下 - 左 - 右 number + j 向下移动多少行 0(零按键) 移动到当前行行首 $ 移动至当前行行尾 o 在当前行下方打开一行 O 在当前行上方打开一行 文本编辑 gg 移动至文本的第一行 G 移动至文本的最后一行 numberG 移动至某一行 页编辑 Ctrl + f 向下翻一页 Ctrl + b 向上翻一页 撤销 u 撤销最后一次的编辑 删除文本 x / number + x(一起按) 删除当前字符 / number个字符 dd 删除当前行 dG / d+ numbger + G 删除当前行到文本末尾 / 删除当前行到文本末尾 复制和粘贴 yy / p 复制和粘 链接行 J 上下行连接 查找 /line 查找 文本操作 d: 剪切文本 p: 复制文本到光标位置 查找替换 / : 用于文本查找 权限操作chmod 文件权限 用 3 个八进制数字,我们能够设置文件所有者,用户组,和其他人的权限: :7 (rwx),6 (rw-),5 (r-x),4 (r–),and 0 (-–) “600”,我们能够设置文件所有者的权限为读写权限, 而删除用户组和其他人的所有权限。 用户标识 su/sudo su 和 sudo 之间的一个重要区别 sudo 不会重新启动一个 shell,也不会加载另一个用户的 shell 运行环境。 软件包管理 Debian 的 “.deb”,和红帽的”.rpm” 软件包管理工具 编写一个shell脚本基本脚本的编写 脚本的格式 123#!/bin/bash# This is our first script.echo 'Hello World!' 设置权限, 让脚本可与运行 注意为了能够执行脚本,脚本必须是可读的。 1$ chmod 777 file 脚本文件的执行 12$ ./file // 基本的执行方式$ file // 如果将脚本放在 /bin 目录下, 那么不需要指定脚本的路径, 就可以直接执行; 自顶向下设计 自顶向下设计是一种常见的程序设计方法,尤其适合 shell 编程。 shell 可以使用数据结构: 字符串, 数组 shell 可以使用一些控制流程: if while]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CommandLine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux用户和内核]]></title>
    <url>%2F2019%2F08%2F02%2Flinux%E7%94%A8%E6%88%B7%E5%92%8C%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[linux用户和内核 在Linux机器上，CPU要么处于受信任的内核模式，要么处于受限制的用户模式 区别 用户模式 内核模式 linux系统下 CPU要么处于受限的用户模式 CPU要么处于受信任的内核模式 进程 用户进程 内核进程 访问所有空间 系统调用向设备驱动程序或其他内核模式的代码发出请求 无限制地访问所有处理器指令集以及全部内存和I/O空间 地址空间 允许发生缺页 内核模式的代码则不允许 linux用户和内核之间的关系 Linux的用户态与内核态 定义? Intel的X86架构的CPU提供了0到3四个特权级: Linux操作系统中则主要采用了0(内核)和3(用户)两个特权级 进程寻址空间0~4G , 用户态只能访问0~3G，只有进入内核态才能访问3G~4G 用户态和内核态区别？ 用户态用printf, 内核态用printk 用户态每个应用程序空间是虚拟的，相对独立的；内核态中却不是独立的，内存是被共享的。 Linux的用户态与内核态 如何切换的? 系统调用: 用户态的进程通过系统调用申请使用操作系统提供的系统调用服务例程来处理任务 机制: 操作系统为用户特别开发的一个中断机制来实现的，即软中断 内存产生异常时 如缺页异常 外设产生中断 比如硬盘读写操作的完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 传统的方法无法用于实现用户态和内核态通信的原因？ Linux的用户态与内核态的通信方式？ 使用API接口 API接口 含义 get_user(x，ptr) 在内核中被调用：获取用户空间指定地址的数值并保存到内核变量x中 put_user(x，ptr) 在内核中被调用：将内核空间的变量x的数值保存到到用户空间指定地址处。 Copy_from_user()copy_to_user() 主要应用于设备驱动读写函数中，通过系统调用触发 使用内核的系统调用? Linux下内核空间与用户空间进行通信的方式主要有syscall（system call）、/proc、ioctl和netlink syscall（system call） Linux内核中设置了一组用于实现各种系统功能的子程序 用户可以通过调用系统调用接口（SCI）, 访问linux内核的数据和函数 /proc 是虚拟文件系统，是Linux内核信息的抽象文件接口, 大量内核中的信息以及可调参数都被作为常规文件映射到一个目录树中 echo或cat这样的文件操作命令对系统信息进行查取 netlink：用户态应用使用标准的socket API就可以使用 netlink 提供的强大功能； 使用自定义一种协议完成数据交换，不需要添加一个文件等。2.可以支持多点传送。3.支持内核先发起会话。4.异步通信，支持缓存机制 内核空间对netlink的使用：主要是create函数 1netlink_kernel_create(); //内核创建； ioctl：函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数控制设备的I/O通道。 使用mmap系统调用 将内核空间的地址映射到用户空间 信号：从内核空间向进程发送信号。 这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应进程。 内核空间的划分？ 虚拟地址 即逻辑地址，是指由程序产生的与段相关的偏移地址部分 物理地址 (physical address): 放在寻址总线上的地址。 物理地址一般与CPU有关系，是给CPU指令使用的 总线地址主要是给设备使用的，是设备中的一些内存资源 高端内存 地址空间大于1G的内存区域]]></content>
      <categories>
        <category>Operate System</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM体系结构]]></title>
    <url>%2F2019%2F08%2F02%2FARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[ARM体系结构ARM处理器的7种模式 处理器模式 描述 用户模式(User) 正常程序执行模式; ARM指令地址加4byte, Thumb指令地址加2byte 快速中断(FIQ) 高速数据传输和通道处理 外部中断(IRQ) 通常的中断处理 特权模式(Supervisor, sev) 供操作系统使用的一种保护模式 数据访问中止(Abort, abt) 用于虚拟存储及存储保护 未定义指令中止模式(Undefined, und) 支持通用软件方针硬件的协处理器 系统模式(System, sys) 运行特权级的操作系统任务 具体的区别: 特权模式(Privileged Modes): 除了用户模式之外的其他6种; 异常模式: 除了用户 和 系统模式, 系统模式 : 系统模式不是通过异常进入, 它和用户模式具有完全一样的寄存器; 寄存器介绍 ARM处理器有37个寄存器 31个通用寄存器, 包含程序计数器(PC), 都是32bit 6个状态寄存器 程序计数器(PC)的作用? 是用于存放执行指令的地方; 当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 程序状态寄存器(CPSR) 包含条件标识位, 中断禁止位, 当前处理器模式标志位以及其他的控制位; 寄存器移位方式 : 知道前三种 移位方式 名称 ASR 算数右移 LSL 逻辑左移 LSR 逻辑右移 ROR 循环右移 RRX 扩展的循环右移 ARM 处理器异常中断 异常中断类型和优先级 中断响应和返回 保存处理器当前状态; 设置CPSR中的位; 将寄存器lr_mode设置为返回地址 将计数器值(PC)设置为中断的向量地址; 返回到中断情况的下一条指令; FIQ和IRQ 异常中断? 用于外部设备向CPU请求中断服务 引脚低电平有效 同时发生时: 先处理FIQ ARM 指令集可以分为哪六大类? 指令集 (6类) 功能 跳转指令 直接向PC寄存器写入目的地址值; 数据处理指令 对数据的处理 程序状态寄存器(PSR)传输指令 读取–修改–写回; Load/Store 指令 协处理器指令 支持16个协处理器 异常中断产生指令 软中断SWI; 断点中断指令BKPT 数据处理指令分类 数据传送指令: MOV 算数逻辑运算指令: ADD(加法), SUB(减法), AND(逻辑与), MUL(乘法) 比较指令: TST load/store 指令 指令集 名字 LDR (load data ) 字数据加载指令 LDRB 字节数据加载指令 LDRH 半字数据加载指令 STR 字数据存储指令 STRB 字节数据存储指令 STRH 半字数据存储指令 位, 比特, 字节, 字四这之间的关系? 位 : bit, 计算自内部数据存储最小的单位; 字节: B, 计算机内部数据处理的基本单位, 1Byte = 8 bit; 字: word, 计算机进行数据处理时,一次存取, 加工和传送的长度 一个字组成: 一个或者多个byte; 取决于: CPU处理器的位数, 64bit, 32bit; 立即数寻址的方式 立即数组成 每个立即数由一个8bit常数, 循环右移偶数位得到; ARM体系结构中的工作状态? ARM体系结构有四种工作状态 ARM状态: arm处理器工作在32bit的指令状态, 字对齐的ARM指令; Thumb状态: arm处理器工作在16bit的指令状态, 半字对齐ARM指令; Thumb-2状态: 这个状态是ARM7版本的处理器, 兼容32bit/16bit 调试状态: 处理器关闭的状态; ARM状态 Thumb状态 的切换 12LDR R0=lable+1; // 从ARM到Thumb : 状态寄存器的最低位设置为1,BX指令, R0指令将进入thumb状态;LDR R0=lable; // 从Thumb到 ARM: 寄存器最低位设置为0，BX指令、R0指令将进入arm状态 进入ARM状态的三种方式: 寄存器最低位设置为0, 由Thumb到 ARM; 当处理器进行异常处理时，则从异常向量地址开始执行，将自动进入ARM状态。 ARM处理器复位后开始执行代码时总是只处于ARM状态； 注意几个问题? Cortex-M3 : 只有Thumb-2状态和调试状态； Thumb-2技术: ARM处理器无需再ARM状态和Thumb-2状态间进行切换了，因为thumb-2具有32位指令功能; ARPCS 的作用? 是ARM程序和Thumb程序中子程序调用的基本规则 ARM汇编 ARM 中的伪指令? 伪指令在汇编编译器对源程序进行汇编处理时, 被替换成对应的ARM或者Thumb指令(序列) AMR汇编语言中的符号? 符号可以代表地址, 变量和数字变量; ARM 汇编程序的格式 以段为单位组织源文件(.c / .h); 段: 具有相对独立, 特定名称, 不可分割的指令或者数据序列 分为: 代码段和数据段 存储器管理单元MMUMMU 作用 作用一: 完成虚拟空间到物理空间的映射; 把虚拟地址空间分成一个个固定大小的块, 把物理内存的地址空间也分成同样大小的页; 页的大小分为粗粒度和细粒度两种; 作用二: 存储器访问权限控制 作用三: 设置虚拟存储空间的缓冲特性; ARM中支持存储快大小 段(Section): 大小为1M的存储块 大页(Large Pages): 大小为64KB的存储块 小页(small pages): 大小为 4KB的存储块 极小页(Tiny Pages): 大小为1KB的存储块 AMR 中的源文件ARM是C/C++编译器和连接器 ARM的连接器 armlink ARM 映像文件 映像文件(image)生成 目标文件生成: ARM中各种源文件(.c, .s), 经过编译器生成ELF格式的目标文件 目标文件 + 运行的库, 通过ARM连接器处理后 生成ELF格式的映像文件(image) 12$ armcc -g -O1 -c main.c // ARM 中.c文件编译$ tcc -g -O1 -c main.c // Thumb 中 .c文件编译 映像文件(image)组成 一个或者多个域(region) 每个域包含一个或多个输出段 每个输出段包含一个或多个输入段 各输入段包含目标文件中的代码和数据 ARM映像文件的入口点 a) 运行时入口点, 初始化入口点; 地址: 0x0 为嵌入式应用系统入口点 唯一 的一个入口点 b) 普通入口点entry point; 多个entry point 包含各种异常中断的入口点 如果一个映像文件只有一个普通入口点, 就是初始入口点; ARM 系统复位 系统复位时, 地址0x0是从ROM开始? ARM体系结构中, 系统复位后跳转到地址0x0处执行, 存放的是复位异常中断的中断向量; 系统复位时: RAM中不存在代码和数据; 地址0x0处: 应该是从ROM中开始指向; 系统正常运行时, 地址0x0处为RAM ARM 体系中的调试 基于Angel的调试系统 主机上的调试器(debugger) 位于目标主机上的Angel调试监控程序 基于JTAG的调试系统]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Pragma Pack()]]></title>
    <url>%2F2019%2F08%2F02%2FPragmaPack%2F</url>
    <content type="text"><![CDATA[Pragma Pack(n)32位/64位的系统中, 各自的sizeof()是多少 32位的寻址空间是2^32, 即32个bit，也就是4个字节; 64bit同理 基本类型没有变化: 包括int、char、short、double等，在32bit和64bit中没哟区别; 64位相对于32位的提升，一个要素是在于地址的变化. 在C++中，sizeof(空类或空结构体) = 1，在C语言中，sizeof(空结构体) = 0。 地址空间的比较 函数指针 void (*fun) : 4个 / 8个 long double 10/12 10/16 有效位10字节。32位为了对齐实际分配12字节；64位分配16字节 数据类型 同等类型: 给出占的bit 32位 byte 64位 byte 备注 char __int8_t 1 1 unsigned char __uint8_t 1 1 bool 1 1 short int __int16_t 2 2 unsigned short = 2bute int __int32_t 4 4 unsigned int __uint32_t 4 4 float 4 4 double 8 8 long 4 8 long int __int64_t 8 8 同等类型: 基本的数据类型, char , int ; 没哟double long long 8 8 指针 4 8 (1)所有的指针类型; (2)函数指针 long double 10/12 10/16 有效位10字节。32位为了对齐实际分配12字节；64位分配16字节 数据类型间的混合运算, 最后的输出? Char型与int型数据进行运算，就是把字符的ASCII码与整型数据进行运算 若int型与float或double型数据进行运算，先将int型和float型转换为double型，然后进行运算，结果为double型 内存地址对齐 pragma pack(n)用法详解? 什么是对齐, 为什么需要对齐? 内存空间都是按照byte划分的; 对齐: 按照一定的规则在地址空间上排列, 而不是顺序的一个接一个的排放 例如: 访问特定变量的时候经常在特定的内存地址访问 为什么要对齐: 内存对齐基本上是透明的, 由编译器完成, 为了性能和平台移植等因素，编译器对数据结构进行了内存对齐。 pragma 的理解? #pragma的实现是与具体平台相关的。 可以简单将其理解为该预处理指令是开发者和编译器交互的一个工具 #pragma pack(n)内存对齐规则? pragma pack(n)中n的值 123vc6 中的编译选项有: Zp [1 / 2 / 4 / 8 / 16](1 ) n==1: 地址空间的排列是顺序的, 不用补空位;(2) #pragma pack()表示更改当前对齐系数为默认值: n==8 地址空间的对齐 1min (sizeof(mumber) , n); // 取sizeof(mumber) 值, 和 n的整数倍 的最小值 (1)n==1, 不存在内存对其, 按照顺序存储就行; (2) n &gt; 1: 需要内存对齐; sizeof(mumber) 值的计算 : 计算每一个成员的起始地址 1234(1) 第一个成员member的其实地址空间为 0x00;(2) 下一个member起始地址位置: 地址空间的起始位置 % sizeof(mumber) == 0; (3) 不为0的话, 补空字节;(4) 按照这种规则计算出struct 的全部字节数; n的整数倍 sizeof(struct) 是n的整数倍, 不足则补空字节; (3)补足后才是最终的字节数; 对齐规则的文字总结 对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍； 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍； 如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型。 三个例子 #pragma pack( 4 ) 12345678# pragma pack( 4 )struct A &#123; int a; // a的起始地址 [ 0x00 % sizeof(int) ] == [0x00%4 ] =0; a偏移地址为0x00~0x03; char b; // 由于紧跟a之后的地址，即0x04满足0x04%1=0，所以b存放在0x04地址空间 short c; // 由于紧跟b之后的地址0x05%2 != 0，而0x06%2=0，因此c的存放起始地址为0x06，存放在0x06~0x07空间。 // 在b和c之间的0x05地址 则补空字节。&#125;;min( sizeof(A) , 4k) = min ( 8, 4k ) = 8; #pragma pack( 4 ) : 只是调整起始成员 123456struct B &#123; char b; // 起始地址为0x00，由于满足0x00%1=0，所以b存放在0x00地址空间 int a; // a的自身对齐值为4，由于紧跟b之后的地址0x01%4不是0，而0x04%4=0，因此c的起始地址 0x04，存 放在0x04~0x07空间。// 在b和a之间的0x01~0x03地址则补3个空字节。 short c; // c的自身对齐值为2，由于紧跟a之后的地址0x08%2=0，因此c的存放起始地址为0x08, 0x08~0x09&#125;;min( sizeof(A), 4k ) = min( 10, 4k ) = 12; // 此时不满足 n的整数倍, 需要补0 #pragma pack(1) 12345678#pragma pack(1) struct fun&#123; int i; // 0x00 - 0x03 double d; // 0x04 - 0x011; // 顺序存储, 这里不进行补齐 char c; // 0x12&#125;;min( sizeof(fun), 1 ) = (13, 1) =13 结构体和联合体的内存对齐 联合体的定义: 内存占用: 使几个不同类型的变量共占一段内存 (相互覆盖 ) 每次存放一种: 共同体每次只能存放一种 相互覆盖: 共同体变量中起作用的成员是最后一次存放的成员，在存入新的成员后原有的成员失去了作用！ 联合体长度: 编译程序自动地产生一个变量，其长度为联合中最大的变量长度。 用途: 结构体 结构体的定义: 把不同类型的数据组合成一个整体; 内存占用: 结构体变量所占内存长度是各成员占的内存长度的总和; 需要进行内存对齐; 联合体和结构体共同使用: 123456789101112131415union myun&#123; struct &#123; int x; int y; int z; &#125;u; int k;&#125;a;int main()&#123; a.u.x =4; a.u.y =5; a.u.z =6; a.k = 0; printf("%d %d %d\n",a.u.x,a.u.y,a.u.z); return 0;&#125;// 输出结果: 0, 5, 6 union类型是共享内存: myun这个结构就包含u这个结构体 在内存中: 就是x的位置放置4，y的位置放置5，z的位置放置6 现在对k赋值: 对k的赋值因为是union，要共享内存，所以从union的首地址开始放置 首地址开始的位置其实是x的位置: 这样原来内存中x的位置就被k所赋的值代替了，就变为0了 大疆的题目: 结构体和联合体的内存字节对齐计算? 结构体和联合体相互定义12345678910111213141516171819202122232425262728293031// (1)struct 和 union结构体，计算sizeof占的空间大小// 联合体定义变量时，首地址的对齐：取该联合体的最大值的一个元素；#include &lt;iostream&gt;using namespace std;#pragma pack(4)// 联合体所占的地址空间大小；typedef union size MAX;union size&#123; u_int32_t array[5]; // sizeof()= 4*5 = 20 u_int8_t p; // sizeof()= 1&#125;;// 结合结构体// 联合体定义变量时，首地址的对齐：取该联合体的最大值的一个元素；struct space&#123; u_int32_t value; // 0x00-0x03 u_int8_t j; // 0x04 (中间补空字节) MAX i; // 0x08-0x27&#125;;int main()&#123; int union_size = sizeof(union size); int struct_size = sizeof(struct space); cout &lt;&lt; "union_size " &lt;&lt;union_size &lt;&lt; endl; cout &lt;&lt; "struct_size " &lt;&lt;struct_size &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Operate System</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[代码编写注意]]></title>
    <url>%2F2019%2F08%2F02%2FOnlineJudge%2F</url>
    <content type="text"><![CDATA[Online Judge代码编写注意OnlineJudge Online Judge 工作原理 OJ 只关心我们的输出, 不管程序细节; 请不要自行输出提示信息，这将会导致您的答案不正确，因为任何的输出到屏幕都会作为您答案的一部分。 1printf("Please input two numbers: ")、raw_input('Please input two numbers: ') OJ 的输入格式 整数的输入 1scanf("%d%d", &amp;a, &amp;b); // 只能读到文件空白结束; 字符串的输入 1char *gets(char *s); // 读入字符串的时候, 使用gets OJ的输出格式 主要是空格 / 空行的位置 123456scanf("%d", &amp;n);for(int i = 0; i&lt;n; i++)&#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("Case %d %d\n\n", i+1, a+b); // 每个case之后输出空行&#125;]]></content>
      <categories>
        <category>program</category>
      </categories>
      <tags>
        <tag>program</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间通信的几种方式]]></title>
    <url>%2F2019%2F08%2F02%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[进程间通信的几种方式 为什么进程间通信需要内核? IPC (InterProcess Communication) 通信机制 进程各自有不同的用户地址空间, 任何一个进程的全局变量在另一个进程中都看不到 进程之间要交换数据必须通过内核，在内核中开辟一块缓存区 进程间通信方式的总结 类型 属性 / 存在地方 通信要求 数据流向 传统的通信方式 匿名管道(pipe) 内存中的文件 亲缘关系 / 双方存在 (同步) 数据拷贝 / FIFO顺序 FIFO有名管道 磁盘介质或者内存中 只要能访问路径 / 双方存在 (同步) 数据拷贝/ FIFO顺序 信号(Signal) 对中断机制的一种模拟 任何时候 (异步) System v IPC对象 消息(Message)队列 内存, 特定数据格式的消息链表 异步通信 / 多进程访问 多数据拷贝 / FIFO写入, lessk访问读取 共享内存 内核留出一块共享内存区 异步通信 / 多进程访问 空间映射 / 信号量进行同步 信号量(semaphore) 是一个计数器 同步多进程对共享数据(内存)的访问; 互斥和同步 网络通信 套接字 通信机制, TCP/IP操作单元 client / server进行通信 套接字的三个特性 传统的进程间通信方式管道/匿名管道(pipe) pipe本质: 是一类特殊的文件, 只存在于内存中(内核缓存区)的文件, 数据流向 : 管道是半双工的 进程以FIFO读写数据(循环队列), 有一定的机制判断队列的满和空, 通知等待进行 数据只能向一个方向顺序流动, 不支持lseek()偏移量读取 无名pipe 通信要求: 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程); 在进行读写时, 通信双方都需存在, 否则会退出; 文件系统: 独立的文件系统, 只存在与内存中 阻塞情况处理: 循环队列都为空, 如果进程去读; 或者都为满时进程去写, 会发生阻塞; 题目一: 实现通过pipe进行进程间的通信? 有名管道(FIFO) 与无名管道的区别: 有名pipe, 将路径名和pipe进行关联; 名字存储: 存在于实际的磁盘介质或者内存中的文件系统; 通信要求: 进程只要能访问路径, 就能通过pipe进行通信; 双方必须存在; 题目一: 实现进程间通过FIFO通信的编程题? 信号(Signal) signal本质: 软件层次对中断机制的一种模拟, 异步通信方式; 异步通信: 信号在任何时候可以选择发送, 无需知道进程的状态; 通信双方: 进程之间 内核之间交互 信号产生 : 软硬件的终止 / 异常; 硬件来源: 用户输入Ctrl + C 退出, 硬件异常如无效的存储访问; 软件来源: 终止进程信号, 其他进程调用kill函数, 软件异常信号 信号的处理流程 (1)进程产生信号, 设置信号传递的目的对象(pid), 先由OS(操作系统)接收 (2)OS选择性: 阻塞或者传递信号; (3)目的进程接收到信号, 进行上下文切换(保护上下文), 完成信号操作后返回; signal 阻塞 信号被阻塞时, 内核先保留信号, 直到解除阻塞的状态后, 信号继续传递; linux_signal System v IPC对象消息(Message)队列 本质: 是存放在内存中, 具有特定的格式, 由标识符进行标识的消息链表 异步通信机制, 无需等待读取; 多端访问: 允许一个或者多个进程向消息队列写入或者读取; 数据流向: FIFO的数据写入, 支持消息的随机查询, 支持偏移访问 优势: 克服: 信号承载的信息少; 克服: pipe 承载的数据是无格式的字节流, 缓存大小受限; 两种类型的消息队列 POSIX 消息队列; System V 消息队列: 存在于内核之中, 生命周期和内核相关, 只有当内核重启或者人工删除, 消息队列才会删除; 题目一: 通过消息队列实现进程间通信? 共享内存 本质: 内核留出一块共享内存区, 进程将其映射到自己的私有空间, 多个进程可以读写同一块内存空间, 无需数据拷贝; 进程间的同步和互斥: 信号量(semaphore) 题目一: 通过共享内存实现进程间通信? 信号量(semaphore) 本质 : 是一个计数器, 用于记录信号量的值, 用于同步多进程对共享数据(内存)的访问; 通过信号量实现多进程通信, 需要哪几步? 创建一个信号量：这要求调用者指定初始值，非零整数值 / 二值信号量(0/1) 等待一个信号量：该操作测试信号量的值，如果小于0，就阻塞。也称为P操作( Proberen 测试 ) 挂出一个信号量：该操作将信号量的值加1，也称为V操作(verhogen 增加) 信号量值的操作: 测试和加1属于原子性的, 通过 wait(semap), signal(semap) 同步和互斥的概念 区别之处 互斥 同步 定义 某一资源, 同一时间, 只能由一个访问者访问 在互斥的基础上, 机制使访问者有序访问 特性 唯一性和排它性, 访问者无序 互斥特性 + 有序访问 本质区别 用于线程间互斥 用于线程见得同步 初始值 二值信号量（0 / 1） 非零整数值( value &gt;= 0 ) 操作线程数 同一线程 : lock , unlock Ａ线程: 释放sem_post; B 线程: 获取sem_wait; 信号量实现生产者和消费者模式 a. 信号量的初始值进行标识: 何时producter能进入buffer? 何时consumer能进入buffer? 定义两个信号量: empty , full 定义一个互斥锁, 用于保护临界区代码 b. 信号量:要具有指向性: 消费者不能指向消费者, 只能指向生产者; c. 全局变量: 存放在程序代码区(静态) d. 还要加一个二值信号量 : 锁 (应对多生产者的情况) e. 二值信号量放置的位置, 会造成死锁的状况;(先判断buffer是否为空, 在获取一个锁) 网络通信套接字 本质: 是一种通信机制, 通过网络实现不在同一主机上的client / server进行通信 TCP/IP网络通信的基本操作单元; 套接字的三个特性 套接字的域: 通信中使用的网络介质 AF_INET(Internet网络): server绑定一个端口，在指定的端口监听client的连接。 AF_UNIX (unix文件系统): 文件输入/输出，而它的地址就是文件名; 套接字端口号 TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号 端口: 是一个信息缓冲区，用于保留Socket中的输入/输出信息 端口号: 是一个16位无符号整数(0-65535)，以区别主机上的每一个程序 套接字的协议 流套接字: 通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型, 可靠协议 数据报套接字: UDP/IP协议实现, 不可靠 原始套接字: 允许对较低层次的协议直接访问，比如IP、 ICMP协议 网络监听技术 : 很大程度上依赖于SOCKET_RAW 原始套接字: 可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据; 题目一: 套接字的建立和通信方式]]></content>
      <categories>
        <category>Operate System</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WearableAffectiveRobot]]></title>
    <url>%2F2019%2F07%2F29%2FWearableAffectiveRobot%2F</url>
    <content type="text"><![CDATA[WearableAffectiveRobot 项目在2018年发表到IEEE 应用场景 提出一种将情感机器人、社交机器人、大脑可穿戴和可穿戴2.0相结合的可穿戴情感机器人. 提出的可穿戴式情感机器人适用于广大人群，相信它能在精神层面上改善人体健康，同时满足时尚需求 实现理念 结合智能情感交互机器人、智能触觉交互装置和智能大脑穿戴装置，以智能服装的形式实现了一种新型的fitbot社会情感机器人. fitbot社会情感机器人设计的架构 一个智能终端（智能手机）的隔离层，用于存储智能终端（智能手机），方便其与人体的物理连接和互动。 其他模块，如aiwac智能盒、aiwac智能触觉设备、大脑可穿戴设备、aiwac机器人和云平台。 嵌入式设计及实现功能 AIWAC智能盒硬件设计 设计过程: 基于全志 A33 Vstar 进行二次开发, 设计外围硬件接口并修改视频和语音的内核驱动,完成基本的音视频交互功能; 实现功能: 提供视觉和语音交互，提供丰富的触觉感知和交互功能; 通过语音交互识别情感; 大脑可穿戴硬件设计 设计过程: 基于 ADS1299 单路脑电采集装置, 由三个串联的电极组成：IN1P脑电信号采集电极、参考电信号电极和BIAS1偏执驱动电极; 实现功能: 采集用户脑电信号 AIWAC智能触觉装置 设计过程: 基于 CH559 和电容触摸片,实现与手机物理连接后简单的控制操作和触觉感知; 实现功能: 进行简单的游戏测试 可穿戴情感机器人原型 设计过程: 集成aiwac智能盒、aiwac智能触觉设备、大脑可穿戴设备、phone和时尚外套 实现功能: 采集的情绪数据主要是语音情绪数据, 机器人和用户之间的语音交流实现用户情感的分析. 情感机器人算法 基于aiwac智能盒的情感识别算法 在RNN算法框架中引入一种注意机制，在网络中引入了一种新的权值分担策略，特别注意了语音的强情感特征部分。 基于脑穿戴设备的用户行为感知 通过一个眨眼检测实例，可以介绍大脑穿戴设备对用户行为的感知]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>AIWAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SerialBus]]></title>
    <url>%2F2019%2F07%2F29%2FSerialBus%2F</url>
    <content type="text"><![CDATA[嵌入式总线和接口总线概述 总线是一组线路, 或者是接口的总称; 总线的功能: 任何一个微处理器(MCU) 都要与一定数量的部件和外围设备连接，常用一组线路，配置以适当的接口电路，与各部件和外围设备连接，这组共用的连接线路被称为总线。 总线的分类 总线类型 总线 功能 内部总线 I2C 同步两线; 半双工通信, 近距离; 通过地址识别多个设备(一对多连接); (近距离) SPI 同步四线全双工通信; SCI 通用异步通信接口UART(全)，与MCS-51的异步通信功能基本相同 外部总线 RS-232 全双工; 25针的信号接口; 限于PC串口和点对点通信; 20m 串行** (远距离) RS-485 半双工; 多用于多点互连; 传输速率最远(几十米到上千米); 并行 USB 半双工; 传输速率最快的总线12Mbps PCI / PCI-E PCI是总线结构，而PCIe是点对点结构 DMA 只需要CPU发送指令后，DMA使得内存和外部设备直接通信 现场总线 Can 不分主从; 单点, 多点广播通信; 自助关闭错误总线;(CAN 是所有总线中最为可靠的) 串行内部总线 类型 SPI I2C UART USB 信号线 SCLK, MOSI, MISO, SS SDA, SCL TXD, RXD 4线VCC(5V)/GND/D+/D-(3.3V) 全/半双工 全双工通信 半双工 全双工通信 半双工 同/异步总线 同步总线 同步总线 异步总线 同步总线 距离 主从设备(近) IC之间,短 远(1200m) 近 各自特点 有自己时钟协议 1) 先发送目的设备的地址; 固定的波特率 传输速度 最快的总线: 12Mbps 可靠性 不可靠(无效验) 可靠(校验位) 数据发送 空闲状态跳变 边缘触发 起始位= 0 数据帧 从高bit–低bit ; 8bit(data) 从高–低; 1) 7(adress) + 1(ack); 2)8(data) + 1ack 从低bit–高; 10bit / 11 bit1bit(起始 0) + 8bit(data) + 1(校验) + 1bit(停止 1) 总线拓扑结构 环形 总线型（特殊的树形） 星形 SPI 串行外设接口 SPI(Serial Peripheral Interface) 全双工的通信, 同步总线 四条信号线: 串行时钟(SCLK)、串行数据输出(MOSI)、串行数据输入(MISO) ，SS(slave 从设备选择线) SS : 低电平有效 IO口模拟SPI总线: 必须要有一个输出口(SDO)，一个输入口(SDI) SPI 通信描述 主从模式架构: 支持多slave模式应用，一般仅支持单Master 主设备 :提供串行时钟(SCLK) 通过移位寄存器实现主从设备的数据交换; 数据输出 空闲状态: 由时钟极性(CPOL)进行确定; CPOL=0(同步时钟的空闲状态为低电平); PCOL=1(高) 相位配置CPHA CPHA=0 : 第一个跳变沿开始采样 CPHA=1 : 第二个跳变沿开始采样 数据按位传输，从高 – 低; 传输的数据为8位 I2C 同步总线 I2C(INTER IC BUS) 信号线: 两线(SCL、SDA)、 同步总线 特点: 具有总线仲裁机制，非常适合在器件之间进行近距离 协议: 传输数据时都会带上目的设备的设备地址，因此可以实现设备组网 IO口模拟I2C总线: 并实现双向传输，则需一个输入输出口(SDA)，另外还需一个输出口(SCL) 时序状态 三种类型的信号，分别是：开始信号、结束信号和应答信号 开始信号：处理器让SCL时钟保持高电平，然后让SDA数据信号由高变低就表示一个开始信号。 主机: 发送adress: 7bit (目的地址) + 读/ 写(bit); 等待ACK 从机接受: 并且发送ACK确认 主机发送数据: 8bit (由高bit–低) , 等待ACK 从机接受: 并且发送ACK确认 停止信号：处理器让SCL时钟保持高电平，然后让SDA数据信号由低变高就表示一个停止信号。 问题一: 数据传输中, 如何保持SDA上传输的数据的稳定? 当SCL为高电平期间, SDA 发送的数据才能保持稳定; 外接IIC设备在SCL为高电平的期间 : 采集数据方知SDA是高或低电平 问题二: SDA数据在什么时候进行翻转? 只能在SCL为低电平期间翻转变化 (如果当scl为高进行翻转的话, 代表停止和开始) 问题三: 处理器把数据发给外接IIC设备，如何知道IIC设备数据已经收到呢？ IIC设备向处理器发送响应信号（ACK）; 处理器: 发完8bit数据后就不再驱动总线了（SDA引脚变输入）, 而SDA和SDL硬件设计时都有上拉电阻，所以这时候SDA变成高电平。 外接IIC设备能收到信号: 在第9个周期拉低SDA，处理器检测到SDA拉低就能知道外接IIC设备数据已经收到。 上拉电阻起作用的情况? 只有当SDA为输入脚时, 外部上拉的高电平才起作用; IIC读写读写寄存器? 都是主机向从机发起; 主机向从机发送地址, 进行地址识别 写寄存器 主机将数据写到从机中 读寄存器 从机将数据发送给主机; UART 通用异步收发器 UART (Universal Asynchronous Receiver Transmitter) 特点:异步串口，因此一般比前两种同步串口的结构要复杂很多; 接收方不知道发送方什么时候发送，所以在发送的信息中就要有提示接收方开始接收的信息，如开始位，结束时有停止位 信号线: TXD, RXD; UART 数据格式 一个数据帧: 10bit / 11bit(有校验) 起始位: 1bit – 为低0 data : 8bit , 从低地址到高地址; 校验位 (1) 停止位(1) – 为高1 数据发送和接收 数据发送时: 一位位的进行发送 发送过程 : 空闲状态，线路处于高电位; 当收到发送数据指令后，拉低线路一个数据位的时间T; 接着数据从低–高位依次发送(8bit); 接着发送奇偶校验位和停止位, 一帧资料发送结束; 接受过程 空闲状态，线路处于高电位; 当检测到线路的下降沿, 时说明线路有数据传输; 按照约定的波特率 , 从低 – 高位接收数据; 接着接收并比较奇偶校验位是否正确 保证数据正确性 UART采用16倍数据波特率的时钟进行采样; 每个数据有16个时钟采样，取中间的采样值，以保证采样不会滑码或误码。 发送数据时间计算 123波特率: 115200 bps ; Time (1bit) = (1/115200)=8.7us;一帧数据: (不考虑奇偶bit) : ( 8 + 2 ) * 8.7 = 87us;1s(1000000us) : 字节数(1000000/87) = 11494bit; -- &gt; 11.5KB/s 外部总线RS - 232 RS-232 接口形式 以9个引脚 (DB-9) ; 25个引脚 (DB-25) 串行物理接口标准 个人计算机上: 两组 RS-232 接口，分别称为 COM1 和 COM2. 传输距离短的原因: RS-232-C标准规定，驱动器允许有2500pF的电容负载，通信距离将受此电容限制; 是RS-232属单端信号传送(点对点)，存在共地噪声和不能抑制共模干扰等问题，因此一般用于20m以内的通信。 信号线 RS-232-C总线标准设有25条信号线，包括一个主通道和一个辅助通道，在多数情况下主要使用主通道 对于一般双工通信，仅需几条信号线就可实现，如一条RXD、一条TXD及一条地线 RS232 通信协议 负逻辑电平: 信号电平与通常的TTL电平也不兼容，“1”(-5V～-15V)，“0”(+5V～+15V) 实现OSI参考模型的: 物理层 RS - 485 通信方式 RS-485采用平衡发送和差分接收，因此具有抑制共模干扰的能力。 加上总线收发器具有高灵敏度，能检测低至200mV的电压，故传输信号能在千米以外得到恢复。 RS-485采用半双工，任何时候只能有一点处于发送状态，因此，发送电路须由使能信号加以控制 应用地方: RS-485用于多点互连时非常方便，可以省掉许多信号线。 应用RS-485可以联网构成分布式系统，其允许最多并联32台驱动器和32台接收器。 USB USB总线的优势 它可以为外设提供电源，而不像普通的使用串、并口的设备需要单独的供电系统; USB的最高传输率可达12Mbps比串口快100倍，比并口快近10倍，而且USB还能支持多媒体 支持热插拔 缺点 不能通过USB进行计算机的互连 PCI Peripheral Component Interconnect (外设部件互连标准） PCI 外设部件互连标准 目前个人电脑中使用最为广泛的接口，几乎所有的主板产品上都带有这种插槽 PCI的架构： PCI 总线 + PCI Bridge + PCI 总线域； PCI Bridge : 隔离处理器系统的存储器域与PCI总线域；并完成处理器与PCI设备间的数据交换 每个Host Bridge单独管理独立的总线空间，包括PCI Bus, PCI I/O, PCI Memory, and PCI PCI总线的三部分 PCI是总线结构，而PCIe是点对点结构 被称为“串行PCI”，由于采用了串行方式传输使得其工作频率可以达到2.5Ghz 每一个PCIe总线设备与外部通信时有四根数据总线，分别有两个RX和TX 现场总线Can CAN 是控制器局域网络(Controller Area NetWork)的简称. CAN 协议也遵循 ISO/OSI 模型，采用了其中的物理层、数据链路层与应用层。 工作方式: CAN 采用多主工作方式，节点之间不分主从; 但节点之间有优先级之分，通信方式灵活; 可实现点对点、一点对多及广播方式传输数据，无需调度; 传输介质和距离 CAN 总线可采用双绞线，同轴电缆或光纤作力传输介质 通信速率可达 1Mbps/40m，直接通信距离最远可达 10km/5Kbps。可挂接设备数最多可达110 个。 CAN总线的可靠性 CAN 的信号传输采用短帧结构，每帧有效字节为 8 个，传输距离短，受干扰的概率低。 当节点严重错误时，具有自动关闭功能，以切断该节点与总线的联系，使总线上的其它节点及通信不受影响。 可见，CAN 是所有总线中最为可靠的。 信号和硬件接口关系 物理硬件接口 串口、COM口 电平信号(电信号) TTL、RS232、RS485 TTL标准是低电平为0，高电平为1（±5V电平） RS-232标准是负逻辑(5-15v) PL2303、CP2102芯片 USB转TTL串口的芯片,用USB来扩展串口(TTL电平) MAX23芯片 TTL电平与RS232电平的专用双向转换芯片 接设备的时候注意: 一般只接GND RX TX。 不会接Vcc或者+3.3v的电源线，避免与目标设备上的供电冲突。]]></content>
      <categories>
        <category>emebeded</category>
      </categories>
      <tags>
        <tag>Bus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DjiEmebeded]]></title>
    <url>%2F2019%2F07%2F29%2FDjiEmebeded%2F</url>
    <content type="text"><![CDATA[Dji Emebeded嵌入式分享会 大疆工作体验 设备树: 内核会是很新的. 嵌入式开发过程中的思考和自己读独到的见解;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Dji</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RobotControl]]></title>
    <url>%2F2019%2F07%2F26%2FRobotControl%2F</url>
    <content type="text"><![CDATA[RobotControl2017.08 中国大学生电子设计竞赛 《板球控制系统》 项目实现: 为了实现小球在65*65cm的白板上做有规则运动; 设计板球平衡控制系统, 通过二值化处理得到小球位置, 使用PID算法调节小球与给定位置的偏差; 最终实现滚球在规定位置完成指定动作; PID算法测试 在控制中，P比例、I积分、D微分参数必须调试到合适的值才能有一个优良的控制性能。 我们先只用PD控制来观察小球定点的性能，测试出合适的PD值， 然后使用I消除稳态误差，由于I会影响控制系统的稳态性能，所以不能太大或者太小，我们采取一次一次尝试的方法得出合适的I值。 定点测试 将小球放在任意一个非指定地方，启动控制系统。测试多长时间才能停在设定位置。 模式切换测试 有触摸屏测试和按键模式两种模式 2016.01中国工程机器人大赛暨国际公开赛 《双足竞步工程》 项目的实现: 制作双足竞步机器人(窄足), 通过上位机对六路舵机进行PID控制, 调节机器人行进过程中的步态, 并设计最终的步态算法; 最后完成了机器人的直行和行进间的弯曲功能, 由于翻跟头时步态旋转过大除了比赛场地, 没有实现最后的功能; PID控制: PWM控制脉冲波形的宽度按正弦规律变化 Robot的原型 修改了机械结构, 降低了整体的高度; 将电池分布在两侧, 降低头部的重量; Robot前进功能的实现]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>robot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WindowsDownload]]></title>
    <url>%2F2019%2F07%2F26%2FWindowsDownload%2F</url>
    <content type="text"><![CDATA[WIN*.ios download you can download anyone opearting system open the link I tell you find opearting system copy the bt_link open baiduyun and off-line download WIN*.ios install download ios later, we need uncompress the ios win10的控制面板：Control Panel\Programs\Programs and Features MD5码效验工具 文件下载的时候有MD5码和SHA1码 保证下载的两个码一致 download: MD5 win10 永久激活 激活方式参考 数字激活下载 Disk disk 详解 Diskgenius 格式化磁盘分区的软件 固态接口 查电脑型号 当然是SATA3.0接口的固态硬盘 M.2 NVME 协议； M.2 Start 协议; MSATA mini-START 存储方式 固态硬盘的存储方式：采用的是固体颗粒进行存储； 颗粒决定了寿命 推荐产品 name 容量 价格 支架 无光驱的接口 Micron英睿达(Crucial) MX500系列 240G 379 镁光1100 256G 389 无支架 有插件 东芝Q200EX 240G 348 有支架 有插件 推荐三星860EVO 256G 250 有支架]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Life]]></title>
    <url>%2F2019%2F07%2F26%2FLife%2F</url>
    <content type="text"><![CDATA[Life is interestingInteresting videos time 作品 简介 2019.7.26 网易公开课 [十点视频官方] 河森堡的视屏, 才华才是一个男人最高级的性感 网易公开课 [Maxonor创意公元] MAXONOR创意公元, 国内首个创意设计类视频节目 [日食记] 生活还有美食 纪录片 [燃点] 2018没人活的容易, 今年很冷 2019.7.19 岩合光昭的猫步走世界 岩合光昭，用镜头捕捉巴黎、挪威、西西里猫咪身影。 Reading Books2019 books list list 书名 作者 推荐理由 1 大学大师-清华校长梅贻琦传（上下部） 岳南著-中国文史出版社 2 明朝那些事（7部） 当年明月 3 最好的告别 阿图.葛文德 关于衰老与死亡，你必须知道的常识。 4 黑体时代、黄金时代、白银时代 王小波 5 沉默的大多数、我的精神家园 王小波 小波的一些看法，散文集 6 吴哥之美 蒋勋 一个即将消亡的王朝 7 平凡的世界（3部） 路遥 平凡的世界，不平凡的人生 8 稻草人 叶圣陶 我们需要在自己有能力的条件下，做我们应当做的事，这是一种责任 9 三体（3部） 刘慈欣 失去后才懂得珍惜 10 你一年的9760小时 艾力 11 羊脂球 法-莫泊桑 12 芳华 严歌苓 当人们发现英雄也会落马的时候，连最胆怯的人也会上去扔下石头，这就是善良。 13 万历十五年 14 读书会感悟 武大读书会 为天地立心，为生民立命，为往圣继绝学，为万世开太平. 不应知识的增长而冷漠，知识和经历应让我们更有温度。 15 日食记 姜老刀 生活中的美食其实也有故事 16 《苏菲的哲学课》 法] 多米尼克·贾尼科 慈爱而有智慧的父亲送给女儿的礼物 17 《如何欣赏一部电影》 密歇根大学的教授托马斯 · 福斯特 福斯特认为电影自有一套“语法”，其中包括动作、形象、音效、配乐、时间设置等元素，“语法”规则其实几乎适用于所有的电影 18 《如何阅读一本小说》 19 《如何阅读一本文学书》 20 牧羊少年奇幻之旅 保罗 柯艾略 每个人都会去寻找，曾经那个热泪盈眶的自己 Planning to read 书名 作者 概述 《14岁懂社会系列》 日系 别把14岁的疑惑留到40岁，或许你应该学会思考和认识 《从诗经到红楼梦》 中信出版 古人听到悦⽿的曲调，会感叹“此曲只应天上有，⼈间难得⼏回闻”，现在我们能做的也只有默默单曲循环。我们好像缺少了⼀种观照生活的诗意的眼光 Notes 《如何阅读一本小说》 有一个胡老的演绎：所有的猪都是动物，但并非所有的动物都是猪。但把猪换成小说，把动物换成文学，所有的小说都是文学吗？围墙内外有不同的看法。 接机的我们在围墙外盼望，他们在围墙内环顾，当我们四目相对时，彼此都松了一口气，您悬着的心也落下来了，这便是期待。我们高举你能熟知的接机牌，翘首以望，或是期待与你相遇，或是厌倦长时间的等待。见面时，我们彼此相视而笑，相握相拥，哪怕之前诸多不快也在此刻烟消云散，只因我们最终相遇。 小说第一页，试着理解是第几人称来讲述，第三人称以旁观者的心态观察周边正在发生的事。 小说摆脱现实的羁绊，给人愉悦，而想象力除了自身，没有任何约束。最棒的是，它还邀请我们加入游戏，我们忘了我们需要自担风险。 或许小说本就是我们所思和所想的一个社会。 《如何阅读一本文学小说》 世界上根本没有完全原创的文学小说； 这就恰好可以解释，为啥“我好像在哪见过他来着” 《牧羊少年奇幻之旅》 何为炼金术士？ 我现在不说什么是炼金术士，先说炼金术最后得到的是元精，元精有两个产物，长生不老液和点金石。 炼金术士，他们理解宇宙的语言 爱情 世界上总有人在等待着另外一个人，无论是在大沙漠还是大城市，当这两个人最终相遇，四目相对的时候，过去的一切和将来的一切都变得无足轻重，只有眼前的这一刻最重要。 感受 你听说过天命吗？讲的上帝创造每一个人，都是怀着自己的使命，他们会在人生的旅途中发现自己的天命，在途中我们会明白一种宇宙的语言，让我们能和世界之魂沟通，然后按着预兆实现自己的使命。此时的你其实已经成为了炼金术士，因为你懂得了如何和世界之魂沟通，它懂得爱和创造，你也知道万物为一物的道理。 我也相信预兆，我知道在世界的另外一边有一个人在等待着另外一个人，当我们相遇的时候，过去的一切和将来的一切都无足轻重，只有眼前的这一刻最重要。 寻梦的过程都是以新手的运气为开端，又总是以对远征者的考验收尾。 谚语～夜色之浓，莫过于黎明前的黑暗。 一言 因为害怕失败，十年未曾尝试自己炼金，但他高兴的是，毕竟没等上二十年才做这件事。 当巨大的财富就在我们眼前时，我们却从来都没有察觉。因为人们不相信财宝的存在。 了解一个人最好的方式，是问他/她最喜欢的书是哪一本。 做什么并不重要，世上的每个人都在历史中扮演者着重要的角色，但通常懵然不知。 男孩笑了，他从来没想到，人生对一个牧羊人竟如此重要。 炼金术士 你的心在哪儿，你的财宝就在哪儿。 心低语：请你注意你流泪的地方，因为那里就是我所在的地方，也是财宝所在的地方。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>movie and book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PhysiologicalParameterDetection]]></title>
    <url>%2F2019%2F07%2F24%2FPhysiologicalParameterDetection%2F</url>
    <content type="text"><![CDATA[机舱环境下的群体生理参数监测技术研究针对的场景和用户 中老年人已经成为心血管疾病的高发人群,他们对于一些异常的环境往往更加敏感; 检测场景: 心血管疾病用户在机舱(低气压环境)的生理参数变化; 具体的优势在哪里 应用场景: 机舱环境将生理参数监测硬件与护颈枕相结合, 长时间的实时检测; 数据处理: 通过叠加过采样对数据处理, 既能保存原始数据, 又能减少数据换算的精度损耗; 健康云平台: 存储原始数据, 生成健康数据检测报告; 方案优势: 在飞行过程中进行长时间的持续监测; 具有可靠、快速地收集、保存和分析原始数据,并将检测结果及时反馈给用户的功能。 系统搭建的过程 硬件优势: BLE与手机进行通信, 适用于飞机无信号的场景; 数据上传: 云服务器接收数据的完整性和时效性,设计了双路上传机制; APP的下载: OpenWRT 搭建的简易 Web 服务器还可供乘客在没有Internet 的情况下连接至专用 Wi-Fi 下载 APP 健康云平台的搭建: 使用的方案 护颈枕模型 生理参数监测系统 光电容积脉搏检测PPG: 原理: 射血的时候: 血流流速增快, 血液容积增加, 能吸收的光强也就越大, 反射端接收的光就越少 ADC数据处理 每一条采样数据由红光和红外光对应的累加 LSB 组合而成 最终将两种光的采样数据组合成为一个 16 位十进制数进行发送 如何得到PPG信号? 光敏二极管反映出的电流变化, 也就是 PPG 信号的交流分量; 将光敏二极管中电流转化为电压信号, 计算出血氧饱和度; PPG信号中得到其他信号 心率、心率变异性、呼吸率以及血氧饱和度。 血氧饱和度: SpO2 经皮血氧饱和度利用 PPG 信号进行采集 产品上线前的组装测试 航空生理参数检测仪 具体产品内部结构可以观看视频提取码：cwwc]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>血氧饱和度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SleepApnea]]></title>
    <url>%2F2019%2F07%2F24%2FSleepApnea%2F</url>
    <content type="text"><![CDATA[睡眠呼吸暂停检测方式睡眠检测方式论文 ProQuest数据库论文搜索 CNKI关键词:睡眠检测 Abnormal respiratory event detection in sleep: A prescreening system with smart wearables A motion-based waveform for the detection of breathing difficulties during sleep Ambulatory detection of sleep apnea using a non-contact biomotion sensor. Patent Application Titled “Detection Of Sleep Apnea Using Respiratory Signals” 关键字: sleep apnea[关键词: 睡眠呼吸暂停 检测系统] 睡眠呼吸暂停综合征(sleep apnea syndrome)是什么? 指人体在夜 间 睡 眠 时,口 腔 或 者 鼻 腔 发 生 了 气 流 停止的症状,并且症状持续时间在 10 s 以上,次数超过30 次 这类呼吸暂停情况切断对身体的氧气供应，时间长达几秒，从而停止对二氧化碳的清除。因此，大脑短时将人唤醒，重新开启呼吸道，并重新启动呼吸。这可能在夜间发生多次，无法适当睡眠。人们在白天可能会出现过度嗜睡，注意力难以集中或头痛。夜间打鼾是最常见特征。 医学上: 睡眠呼吸暂停综合症诊断的标准 多导睡眠图 PSG 可以记录睡眠中的脑电图、 心电图、 口鼻气流、 血氧饱和度、 鼾声、 体位、 胸腹等多项生命指征。 2019 硕士: 多信息交互的睡眠呼吸暂停综合症无扰检测系统_董雪虎 设计模型–多传感器融合 判断出:每小时呼吸均暂停次数, 每次暂停的时间长; | 检测指标 | 方法 | 得到什么 || ———— | ———————————————————— | ———————————————————— || 鼾声检测 | 六麦克风阵列(录音模块代替) | 鼾声的分贝值患者无论是正常呼吸,还是呼吸暂停时鼾声共振峰分布,都不太稳定。 || 心率和呼吸率 | 基于光强度的高精度微弯型光纤传感器 | 光强度曲线值(类似于我们的检测仪) || 人体睡姿 | 柔性触觉传感器(压力阵列) 40*40 cm^2 | 人体六种睡姿判断(通过图像一些滤波处理) | 参考模型 2019 硕士基于微波非接触式呼吸检测及分析系统设计和研究 呼吸病理学原理: 四种异常的呼吸 非接触式呼吸检测方式 检测方法: 三路的微波雷达通道睡眠呼吸暂停检测系统; 通过三个方向的雷达进行探测: 得到在不同睡姿情况下的 – 呼吸的频率和幅度值; 检测指标 方法 得到什么 检测呼吸信号 三路的微波雷达通道 三个方向进行呼吸的检测; 得到呼吸和睡姿的信息 YH-600B睡眠呼吸初筛仪 医学上正在使用, 用于数据对比 24G CDM324-MOD 2017 硕士 基于24GHz雷达的SAHS检测系统研究与实现关键词 : 睡眠 呼吸检测 系统 2015 专利: 一种睡眠呼吸暂停综合症检测系统 搜到了一堆专利 产品模型2019.7.25 枕头垫模型 声音检测: 放在四个方向; 压力检测: 平躺或者侧睡; 微波检测: 人体的呼吸;]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>SleepApnea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS持久性]]></title>
    <url>%2F2019%2F07%2F24%2FOS%E6%8C%81%E4%B9%85%E6%80%A7%2F</url>
    <content type="text"><![CDATA[持久性 抽象模型 采用什么样的方式, 让数据(桃子)保存的时间长久; 持久性完成工作: 数据的有效存储; 硬件中断的实现过程: 设备准备好自身的工作 —&gt; 发出硬件中断 —&gt; CPU 执行OS 中预先定义的中断服务例程ISR(interrupt server routine) / 中断处理程序(interrupt handler) —&gt; 返回唤醒等待的I/O进程继续执行. 调度策略 调度策略的形成: 侧重于不同的影响因素而造成的; 因此: 不用去记忆调度策略, 反而应该知道影响因素; I/O 设备 – 数据交互问题一: OS 如何与I/O设备进行交互的? 将设备的硬件接口纳入到OS; 封装设备驱动程序(OS中的一部分软件): 完成底层操作; 驱动程序充满了整个内核; 标准硬件 原型系统架构的分层模型: 物理布局和造价成本决定的分层; 标准硬件 硬件接口: 寄存器 ( { status , data , command } + register ) 操作系统控制设备工作的接口 内部结构: CPU + Memory + 芯片 完成具体接口的工作; 标准协议 OS 对硬件接口的statue register 进行polling OS下发数据到data register CPU参与数据移动: 称之为PIO(programmer I/O) OS 下发command, 进行命令的执行 问题一 : 如何减polling中cpu的开销? 硬件中断实现: 优势: 中断允许计算与I/O重叠; (CPU可以执行其他进程) 中断改进 polling + interrupt: 先轮询一段时间, 时间超过某一个阈值, 选择进行中断; ( 防止有些CPU/IO 交换很快, 此时使用中断造成资源浪费 ) 合并: 抛出中断时, 等待一段时间; 问题二: 如何实现高效的数据传输? 增加硬件设备: DMA (direct memory access) DMA作用: 协调内存和设备间的数据交互, 无需CPU介入; 问题三: OS的交互指令是什么? 方法一: I/O指令 – 特权指令 OS是唯一能与硬件设备直接交互的实体; 方法二: 内存映射I/O 硬件将设备寄存器作为内存地址提供; 硬件 – 数据存储设备 设备: 长久的保存数据, 用户更关心的是数据 内存: 断电后内容会丢失; 磁盘驱动器 (I/O操作太慢) 硬件接口: 大量的扇区块( 512 byte ), 每个块可以进行读取和写入; 几何扇区如何进行数据存储 磁性: 对磁盘引入磁性, 进行数据永久保存 磁道: 一个同心圆; 磁头: 用于在磁道上读取或者写入数据的; 数据读取过程: 磁道 逆时针旋转, 到了磁头下面, 进行数据操作 磁盘的特性 单磁道: 旋转延时; 多磁道: 寻道时间 外磁道比内磁道有更多的存储空间; 缓存cache: 磁道缓存区 问题一: 数据是如何与磁盘进行交互的? 磁头通过寻道移动到不同的磁道上, 磁盘的逆时针旋转, 将不同的扇区块移动到磁头下面, 从而完成数据交互; 问题二 : 数据交互的时间? 1T(I/O) = T(寻道time) + T(旋转) + T(数据移动) 问题三: 磁盘调度策略 – 降低数据交互时间 根据不同的影响因素, 有不同的策略; 最短寻道时间优先 最短定位时间优先 RAID (廉价冗余磁盘阵列) RAID (Redundant Array of Inexpensive Disks) 将大量的独立磁盘扩充为更大, 更可靠的单一实体; 透明性: 使用RAID替换磁盘, 不用考虑更换软件驱动; RAID 的特性 性能: 加快I/O读取时间; 容量: 扩充磁盘 可靠性: 冗余进行数据的物理备份 硬件接口和内部 硬件接口: 线性的数组块, 每个块都可以通过文件系统进行读取和写入; 内部: 专业的计算机, 有一个CPU + Memory + 磁盘 问题一: 如何设计RAID? 方法: 根据对RAID的特性的不同偏重, 设计不同的RAID; RAID的类型 特性 RAID 0 级: 条带化 无冗余, 全部用来存储, 容量大 RAID 1 级: 镜像 对每个逻辑块, 保留两个物理副本; 只有一半的容量, 但是更可靠了 RAID 4 级: 奇偶校验 容量是(N-1); 需要一个块保存奇偶校验位 文件和目录 文件和目录的用途: 便于用户识别以及查找 文件系统: 通过对磁盘的管理, 便于文件和目录的存储 OS虚拟化另一个模块: 进程: 虚拟化的CPU;地址空间: 虚拟化的物理内存; 持久存储的虚拟化 文件和目录: 保持数据掉电不丢失; 文件的概念搭建 数据的存储: 是一个线性数组, 每个字节都可以读取或者写入; 元数据 : 包含了文件其余的信息,(比如– inode number (低级名字)) 文件系统: 将数据永久的保存在磁盘上; 目录的概念搭建 目录: 对应我们常说的文件夹; 文件的存储位置: 存放文件的空间; 包含 : 包含一个列表, 列表的信息( 用户可读名字, inode元数据 ) 结构: 根目录只是一个 – “ / “; 子目录通过分隔符 隔开 文件的相关操作 文件相关API接口 open(); write(); read(); close(); 下面介绍的系统调用, 将上面的接口进行封装; 工具使用 strace追踪系统调用 12$ strace cat file; // strace追踪cat命令对文件的操作过程;$ dd if=file; // dd 实用追踪 stat/fstat文件信息的查看 12$ stat file; // 查看文件的相关信息$ ls -a/-al ; // 列出目录下文件 文件的创建 – 文件描述符 1fd = open(); // fd--文件描述符 文件描述符: 指向文件的指针, 用于访问读写; 第一次创建文件: fd==3 12运行的进程已经打开了三个文件fd=0 / 1 / 2 --&gt; stdin; stdout; stderr; 文件的创建做了两件事 inode: 创建一个数据结构inode, 跟踪文件的全部信息; link: 将用户可读名链接到该文件, 并将该链接放入目录中; 文件的读写 顺序的读写 12$ strace echo hello &gt; file; // echo将hello重定向到文件file中;$ strace cat file; // 获取file中的文件内容; 通过偏移量的读取 1$ off_t lseek(int fd, off_t offset, int whence); 强制写入磁盘, 而非buffer 1$ fsync(int fd); // 强制写入磁盘 文件的其余操作 123$ strace mv file foo; // 文件的重命名, rename;$ strace rm *; // 文件删除, 删除当前目录下文件$ strace rm -rf *; // 递归删除目录下的: **所有文件和目录** 文件的链接 硬链接 创建链接后, unlink()其中一个用户可读名file, 对另外的没有影响; 缺陷: (1)不能创建目录的硬链接(成环); (2)只能在当前磁盘分区创建 123$ ln file file2; // link在创建链接的目录中创建了另外一个名称, 该文件不以任何方式复制$ ls -i file file2; // 查看两个文件的inode$ stat file2; 符号链接 symbolic link (软链接) 创建软连接后, unlink() file, 会使得file2指向不存在的路径 123$ ln -s file file2; // 将链接指向文件的**路径名 file**作为链接文件的数据, 链接到一个名为file的数据; $ ls -al file file2; // 查看$ stat file ; 查看 目录的相关操作 目录的相关API接口 1$ opendir(); readdir(); closedir(); 目录的创建 1$ strace mkdir foo ; // 创建目录(文件夹) 空目录foo 读取: 创建的目录中不为空, 包含两个条目 123$ ls -a/-al foo // 目录的读取, 包含两个条目; " . "./ : 引用自身的条目../ : 引用其父目录的条目; 目录的删除 1$ strace rmdir foo; // 只有当目录foo为空(只包含./ ../ 两个条目), 删除才能成功 文件系统VSFS(Very Simple File System) 文件系统的创建和挂载 将众多底层文件系统创建成完整的目录树; mkfs: 文件系统的创建工具 mount 文件挂在工具; 1$ mount -t /dev/sda1 /home/user; 问题一: 文件系统如何实现存储? 磁盘上用那些数据结构存储文件系统的数据和元数据; 磁盘的存储: 磁盘分块: 一个block的大小是4KB 数据: user Data + inode(256 byte) 空间空间管理: Ibit (inode bit) + Dbit(inode bit) Superblock: 包含文件的特定信息, data和inode有多少个块使用; mount 挂在文件系统时, OS将superblock加载到文件树中; iNode的数据结构: iNode的作用: 能有效存储数据块信息,并可以提供有效的访问; (指向数据块的位置) 4k大小的inode : 由256byte构成的一个iNode block; 数据结构: 可以使用指针, 链表, 树 …. 目录组织 目录只包含一个二元组列表( 条目名称, inode号 ) 每个目录还有两个额外的条目 问题二: 文件系统是如何实现磁盘数据的读写? 假设此时的文件系统已经挂载, superblock已经包含在内存中; 访问路径: /foo/bar 文件系统 –&gt; 读取i-number –&gt; 访问inode –&gt; 递归遍历路径名, 找到文件; 写入磁盘 首先: 分配一个磁盘间块(allocate) 然后: 5次的I/O读取 读data bit(查看可分配) , 写 data bit (跟新位图) 读 inode bit, 写 inode bit 写入data 缓存和缓冲 – 缩短时间 系统内存(DRAM) 在第一次读取的时候, 保存访问路径和条目, 后面访问就很快; 快速文件系统FFS( fast file system) VSFS 与 FFS 之间 – 对磁盘的处理方式: VSFS 文件系统 磁盘: 将磁盘分块4KB 内部碎片的问题: 将磁盘当做随机存储的内存; FFS 文件系统 磁盘: 将磁盘划分为分组, 称为柱面组(块组) 处理方式: 相关的东西放在一起, 将磁盘当做磁盘; 优点: 减少寻道时间; 后续文件系统的宗旨: 将磁盘当做磁盘 Linux 中的文件系统 : ext2 和ext3; FSCK 和 日志 文件系统的数据结构必须持久的保存在数据设备上(SSD); 工作负载: 以某种形式更新磁盘的文件系统; 问题: 当设备遇到断电和崩溃时, 文件系统和磁盘实际存储记录不一致的问题? 组合为六种情况: inode元数据, bit位图, data数据 处理方式一: Fsck (file system checker ) Fsck 是一个工具 抽象模型: 搜索整个房子找钥匙; 方式 : 遍历文件系统的三部分, inode元数据, bit位图, data数据 部分 缺点: 很慢 处理方式二: 日志(预写日志) 处理方式: 在更新磁盘时, 加入一个小注记(预写), 并组织成日志 1类似于: git commit -m "注记" 日志: 要写入文件系统中的, journalblock日志超级块; 修复: 文件系统利用日志记录的内容, 堆其进行修复 用的最多的日志: 有序元数据日志 日志结构的文件系统 LFS log-structured file system: 另外的一种文件系统 LFS磁盘更新的方式: 将所有要更新的data + inode 缓存在内存段中; 当段满的时候, 它会一次长时间的顺序写入到磁盘未使用的空间; LFS核心: 顺序写入 + 永不覆盖(旧空间的回收) 问题一: 每次都会产生新的 inode, 那么如何进行查找呢? inode 映射: 建立 inode number 和 inode(元数据) 间接层, 每次通过 inode number , 生成最新版本的磁盘地址; inode 映射存储在哪里呢? LFS 在磁盘上只有这样一个固定的位置, 检查点区域CR(checkpoint region); CR: 指向最新的inode映射片段 问题二: LSR会产生很多垃圾空间, 如何对这些空间进行回收? 数据库中的方法影子分页 : 永不覆盖, 旧空间的回收; 策略: 旧空间回收的策略? 数据完整性和保护 保护 和 花费(时间和空间) 总是成正比关系的; 问题 : 磁盘并不完美, 可能会发生故障, 如何才能保证有效的数据? 磁盘故障模型: 故障 – 停止 模型 : 构建RAID磁盘 故障 – 部分 模型; 完整性: 通过对数据的校验完成; 故障一 : 潜在扇区错误LSE(latent sector error) 故障原因: 磁盘内部数据位出现错误; 检测方式: 磁盘内纠错码ECC(error correcting code) 确定块中的磁盘位是够良好; 解决方法: 冗余机制 故障二: 磁盘块出现讹误(corrupt) 故障原因: 磁盘块出现错误, ECC检测不出来, 用户得到的却是其他的数据块 检测方法: 校验和 校验和函数的计算方法: 异或 XOR : 通过对所有数据的二进制形式求异或 缺陷: 相同位置的两位发生变化(0/1), 检测不出来; 加法: 每个数据块执行二进制补码加法, 忽略溢出; 缺陷: 数据被移位, 也检测不出来; 循环冗余校验CRC: ( Cyclic Redundancy Check ) 计算方式: 数据块 % 校验位 缺陷: 除法计算太花时间 CRC计算方法 抽象模型: 发送端和接收端: 选定的某个特定数( CRC多项式二进制形式)做模2除法 发送端: 要在原始的数据帧后面附加一个数（计算得到的CRC校验码），生成一个新帧发送给接收端。 接收端: 接收到的新帧 % 特定数, 如果余数为0, 则数据正确; 模2除法 宗旨: 既不向上借位, 也不产生进位 12模2加法运算为：1+1=0，0+1=1，0+0=0，无进位，也无借位模2减法运算为：1-1=0，0-1=1，1-0=1，0-0=0，也无进位，无借位 本质: 模二运算, 相当于是异或 CRC多项式 的选取 12假设: G（X） = X4 + X3 + 1; // 二进制形式 11001多项式 G(X) = x^k + ... + 1 // 总共 ( k + 1 )位 发送端: 计算得到该帧的CRC校验码( FCS帧校验序列） 12假设数据帧 : 10110011 ---&gt; 计算时后面补** k** 个0; 得到k位的CRC码进行替换CRC多项式二进制: 11001(k=4) 把上步计算得到的CRC校验0100替换原始帧101100110000后面的四个“0”，得到新帧101100110100。再把这个新帧发送到接收端。 接收端 : 123新的数据帧: 101100110100CRC多项式: （X） = X4 + X3 + 1; ( k = 4)进行模2除法: 101100110100 % 11001 余数为0 , 数据正确; 分布式系统 ( 由多个机器构成 ) 分布式系统的模型抽象 如何让不同的人, 在不同的时刻都能吃到桃子, 而且桃子还能保持新鲜; 如何保证数据有效, 而且是最新的; 分布式系统解决的问题: client – &gt; server 通信问题, 通信并不可靠 主要问题: 通信中如何处理故障(failure); 分布式系统的核心 – 通信 通信并不可靠, 丢包是网络基本的现象: 消息传递层: 传输层, 使用UDP/IP 和 TCP/IP 抽象通信: 分布式共享内存DSM(distributed shared memory) 作用: 使得不同机器上运行的进程共享一个大的虚拟地址空间; 故障: 指向一个不存在的地址空间 远程过程调用RPC(Remote Procedure call) 作用: 使在远程机器上执行代码的过程, 像调用本地函数一样简单; 包括两部分: 存根生成器 和 运行时库 存根生成器 作用: 消除将函数参数和结果打包成消息的一些痛处; 实现效果: 相同的接口, 自动生成不同的代码. 问题一: 复杂的参数, 如何发送一个复杂的数据结构 问题二: 并发性服务器组织方式, 线程池(thread poll) 主线程负责接收请求, 分发给其他线程处理 运行时的库 作用: 提供性能和可靠性 问题一 : 如何找到远程服务器, DNS域名解析; 传输协议: UDP传输RPC软件包 Sun的RPC使用的存根编译器 1rpcgen 许多系统处理的问题是: 字节序? 大端存储: 从最高有效位到最低有效位的存储; 小端存储 Sun的网络文件系统NFS 分布式文件系统: 服务器将数据存在其磁盘上, 客户端通过良好的协议消息请求数据; 问题一: Sun的网络文件系统的核心? 核心: 服务器的故障要能简单快速的恢复; 服务器故障的原因? 外在(硬件的断电) || 内在(内存的泄漏) || 通信(网络异常) 幂等性处理服务器的故障: Client请求重试 幂等性: 执行多次和一次访问的效果是一样的; NFS设计的关键: 文件句柄(FILE handle) 采用协议: 无状态协议, 服务器不会跟踪每个客户端的行为; 文件句柄: server 能够正确访问文件 卷标识符: 通知服务器, 指向哪个文件系统; inode号: 告诉服务器, 请求分区中的哪个文件; 时代号: 服务器确保 新 / 旧文件句柄 问题二: 提高client 和server之间访问的性能? 方法: 客户端缓存; 问题三: client缓存造成的缓存一致性问题? 客户端: 关闭时刷新 添加属性缓存, 每次检查 服务器 对服务器的写入, 在返回成功之前, 必须强制写入稳定存储(备用电源); Andrew 文件系统AFS AFS设计的理念? 为了让服务器和客户端交互最少, 采用全文缓存 和 引入回调的方式, 支持更多client访问 全文缓存 客户端第一次进行访问时: 将相关内容进行全文缓存, 后续的read and write 相当于在本地进行; 引入回调 解决问题: 目录层次结构的访问花费很多时间. 作用: 当用户第一次访问server时, 每一层的访问存入本地时, 服务器会设置一个remzi回调, 后面服务器通知客户端文件是否改变; 减少client每次的询问; 问题: 缓存一致性问题的解决? 方法: 更新可见性 和 缓存陈旧 虚拟监视器(virtual machine monitor) 虚拟监视器 作用: 位于一个或多个操作系统 和 硬件之间, 并为每个运行的OS提供控制机器的假象;(实际上是VMM控制硬件) OS 提供的虚拟化CPU和内存: 让每个用户认为单独享有CPU和内存, 以及进程间切换时, 共享内存; VMM 和 OS 抽象的区别? OS抽象: 提供新的抽象和漂亮的接口; VMM 抽象: 抽象与硬件相同;]]></content>
      <categories>
        <category>Operate System</category>
      </categories>
      <tags>
        <tag>持久性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS并发]]></title>
    <url>%2F2019%2F07%2F18%2FOS%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[操作系统的并发并发的基础知识 并发的基本抽象 问题: 多个用户要快速的抓取并吃掉多个桃子; 实现方式: 多线程的应用程序(表示多个用户), 访问内存节点数据(多个桃子) OS的支持: OS使用锁(lock) 和条件变量(condition variable), 支持多线程应用程序; 线程和进程 线程: 单个运行进程提供的抽象. 区别 进程 线程 运行时 完成相应的指令 每个线程就像独立的进程, 但是共享地址空间, 访问相同的数据 保存状态信息 PCB TCB Thread control block 页表 地址空间改变, 切换当前页表 地址空间不变, 不用切换页表 stack 只有一个栈段 多个栈段 单线程和多线程 区别 单线程 多线程 执行点 一个执行点(一个程序计数器, 用于存放执行的指令) 多个执行点(多个计数器) 临界区互斥 通过锁实现 线程交互(减少线程) 通过条件变量发送信号 共享数据的位置 heap 或者全局位置 实现线程间的同步方法的比较 实现方法 锁 条件变量 信号量 特点 二值信号量 (0/1) 队列(需要记录队列为空还是满) 是一个整数值(初始化赋值) 需要参数 1)共享变量(while自旋的条件); 1)共享变量(while 进入等待的条件) sem 2) mutex 2)mutex (实现线程间互斥) 3)cond(实线线程间同步) 函数 lock() ; unlock() cond_wait(); 线程进入等待状态会释放锁 sem_init()1) int pshared: 0 线程间同步;1-进程2) int value : 信号量初始化的值 cond_signal(); 唤醒线程 sem_wait() :不释放锁, 死锁问题 信号量减一, (与初始值比较)进入等待状态 sem_post();信号量加一, (与初始值比较)唤醒线程 线程的创建和执行顺序 问题一: 多线程的创建和执行? 记住: 先创建的不一定先执行; 情况一: 父线程创建子线程后, 父线程自己先运行(单CPU), 然后子线程才运行; 情况二: 父线程创建子线程后, 子线程先运行(单CPU);然后父线程才运行 问题二: 线程的创建和函数调用之间的关系? 并不是先执行函数, 然后返回给调用者; 而是 被调用的例程(进程)创建一个新的执行线程, 它独立于调用者运行; 多线程之间存在的问题 同步原语 问题一: 多数据之间数据共享? 问题: 线程在执行指令过程中, 时钟中断的产生, 操作系统将当前线程的状态保存在TCB中, 切换到另外的线程; 解决方式: 通过同步原语, 将临界区指令构造成原子性的执行块 问题二: 线程之间睡眠/唤醒的交互机制 问题: 一个线程继续执行之前, 要等待另外一个线程完成某些操作; 解决方式: 条件变量和锁 线程的API1man -k pthread // 查询线程所有的API 线程的创建和线程完成 线程的创建函数分析 1int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); pthread_t *thread : 与线程交互的参数 const pthread_attr_t *attr : 指定线程的属性 栈属性: 栈的大小; 优先级属性 使用前要进行初始化: pthread_attr_init() void ( start_routine) (void *) : 函数指针 线程需要完成的指令: 包括所有的临界区 void *arg: 传递给函数指针的参数 如何等待线程函数完成 等待线程的完成, 需要调用函数pthread_join() 能够保证在退出或者进入下一个阶段时, join等待的线程能完成所有的工作; 1int pthread_join(pthread_t thread, void **retval); pthread_t thread: 表示需要等待的线程 void **retval: 希望得到的返回值; 必须小心如何从线程得到的返回值; 永远不要返回一个指针; 锁的API 接口 锁的作用: 保护临界区的代码向单原子式的执行, 不受中断的影响; 锁的定义和初始化 没有检测是否初始化成功 1 pthread_mutex_t look = PTHREAD_MUTEX_INITIALIZER; 加断言函数, 检测是否初始化成功 123 pthread_mutex_t look; int rc = pthread_mutex_init(&amp;lock, NULL); assert(rc == 0); 获取锁和释放锁时, 应该检测是否获取成功 12345// 获取锁的函数接口void Pthread_mutex_lock( pthread_mutex_t *mutex )&#123; int rc = pthread_mutex_lock(mutex); assert(rc==0);&#125; 锁使用完之后, 要摧毁 1pthread_mutex_destroy(); 其他方式获取锁 : 解决死锁问题 12pthread_mutex_trylock() // 尝试获取锁, 如果由程序占用, 则失败pthread_mutex_timelock() // 在超时或者获取到锁后返回 条件变量 API 条件变量的作用 解决: 线程之间睡眠/唤醒的交互机制 条件变量的创建和初始化 使用条件变量时, 必须使用与此条件相关的锁 12pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 条件变量的使用 12int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); // 进入等待时,会释放锁的;int pthread_cond_signal(pthread_cond_t *cond); 实现锁 锁是一个变量, 互斥量(0/1); 锁的实现 纯硬件的实现; 硬件原语 + OS原语 评价一把锁的效果? 互斥性: 最基本的功能, 锁是否优先, 能够阻止多个线程进入临界区; 公平性: 当锁可用时, 每一个线程都能公平的获得锁; 性能: 加锁之后的时间花费; 基于硬件原语实现锁(不基于线程库) 基于硬件原语实现锁, 优缺点 属于自旋式, 永不放弃CPU, 等待的线程一直浪费CPU的时间片 硬件原语 实现 缺点 控制中断 在进入临界区时, 关闭中断 关闭中断, OS就不能有效介入 TestAndSet自旋锁 将互斥量(0/1)在获取锁和释放锁交换 将测试和设置合并为一个原子操作等待线程会一直自旋, 永不放弃CPU不保证公平性: 对锁是一种抢占式的 比较和交换 通过和期望值进行比较 无等待同步, 自旋式 链式加载和条件式存取 获取并增加 硬件原语 + OS原语 实现锁 OS原语实现 当线程竞争锁失败, 要进入自旋状态时(spin), 放弃CPU.(进行上下文的切换) 1yield(); //OS 原语 但是这样的上下文切换, 成本很高; 一直竞争不到, 就得一直切换; 使用队列: 休眠替代自旋 当线程竞争不到锁时, 通过一个队列保存他们的TID; 通过 park() / unpark() 睡眠和唤醒; Linux 支持的软件原语 1futex; 条件变量 – 另外的开发原语 条件变量的作用? 线程可以使用使用条件变量, 来等待一个条件变成真; (不是自旋等待) 条件变量: 是一个显示队列 当某些执行状态不满足时, 线程可以把自己加入队列, 等待该条件; 当执行状态满足时, 就可以通过唤醒线程, 让其运行; 条件变量的定义和程序 编写代码的几个要求? 共享变量: 共享变量的重要性, 用于判断某些状态的; 锁: 在使用条件变量(睡眠和唤醒机制)时, 必须加锁; 问题一: done 共享变量, 是否有存在的必要? 睡眠, 唤醒, 锁都离不开共享变量 a. 情况一: 父线程创建子线程后, 自己运行(单CPU), 调用thr_join()函数. 这种情况下 父线程先获得lock, done==0, 子线程还在运行, 调用wait()进入睡眠; 子线程得以运行, 调用thr_exit()函数发送signal 信号唤醒父线程; 父线程从wait中返回, 释放锁; b. 情况二: 父线程创建子线程后,子线程立即运行, 并且设置 done =1; 调用signal唤醒其他线程(线程队列为空), 然后结束; 父线程运行后, 调用thr_join(), 发现done = 1, 所以释放锁返回; 问题二: 唤醒和睡眠状态都不加锁? 会被中断信号打断 典型模型: 生产者和消费者(存在界缓冲区) Producter / Consumer 问题 Producter 产生数据, 并将数据放在buffer; Consumer 从buffer中获取数据 Condition: 只有buffer为空时, producter才能写入数据; 只有buffer满时, Consumer才能得到数据; grep 正则匹配 1grep foo file.txt | wc -l // Producter / Consumer 的问题; 而我们充当了用户 grep 在file.txt 中查找与”foo”字符相同的值; — Producter shell 把输出重定向到pipe, pipe的另一端是wc进程的标准输出 1wc -l // wc统计foo出现在文件中的次数 他们之间的交互:通过内核中的有界缓冲区, 共享资源; 代码编写注意三点 a. 共享变量进行标识: 何时producter能进入buffer? 何时consumer能进入buffer? b. Mesa语义: 关于条件变量的使用, 总是使用while loop 代替if c. 条件变量:要具有指向性: 消费者不能指向消费者, 只能指向生产者; 覆盖条件 问题: 关于内存分配的问题? 当出现空闲内存时, 唤醒哪一个等待的线程? 解决方式: 覆盖条件 1pthread_cond_broadcast() ; // 唤醒所有等待的线程 覆盖条件: 它能覆盖所有需要唤醒的线程场景, 广播进行全部唤醒; 基于锁的并发数据结构 还没有看 信号量 – 同步原语 信号量 : 是一个整数值的对象; 信号量作为同步原语, 可以替换锁和条件变量的; 12#include &lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int value); // 信号量的声明和初始化 int pshared: 表示信号量可以在多个线程 , 或者进程实现同步 0: 表示在多个线程之间进行同步; other value: 表示在进程间同步 unsigned int value 信号量的初始化的值 value = 1; 表示二值信号量(锁) value = 0; 表示条件变量, 用于线程之间的等待和唤醒; 信号量 : 可以使用两个函数来操作它. 通过这两个函数进行唤醒和睡眠 sem_wait(): 将信号量的值减一, 和0比较, 小于0就进入等待状态; sem_post(): 将信号量的值增加一, 产生数值变化就唤醒信号量的线程 二值信号量 (锁) 问题一: 信号量的初始值是多少? 初值为1, 当(sem&lt;0) 进入睡眠, 放弃CPU; 情景一: 只有一个线程 线程A调用sem_wait(), 使得信号量减一, 值为0; 从sem_wait()返回; 线程A进入临界区;没有其他线程获取锁; 线程A调用sem_post(), 使得信号量增加一; 情景二: 两个线程 代码使用) 123Sem_wait(&amp;sem);// codeSem_post(&amp;sem); 信号量实现: 条件变量 信号量作为条件变量: 实现线程间的等待和唤醒? 初始值value = 0; 情景一: 父线程 创建子线程后, 子线程先运行 情景二: 父线程 创建子线程后, 父线程先运行 实现方式code 父进程调用sem_wait(), 将sem值减一, sem&lt;0 进入睡眠模式 子进程调用sem_post(), 将sem值加一, sem=0, 唤醒父进程 信号量实现生产者和消费者 解题思路注意 : a. 信号量的初始值进行标识: 何时producter能进入buffer? 何时consumer能进入buffer? 定义两个信号量: empty , full b. 信号量:要具有指向性: 消费者不能指向消费者, 只能指向生产者; c. 全局变量: 存放在程序代码区(静态) d. 还要加一个二值信号量 : 锁 (应对多生产者的情况) e. 二值信号量放置的位置, 会造成死锁的状况; 12345Sem_wait(&amp;empty);Sem_wait(&amp;mutex); // 锁的信号量处的位置, 放在类似于条件变量之前的位置put(i);Sem_post(&amp;mutex);Sem_post(&amp;full); 问题一: 信号量实现的生产者和消费者为什么会产生死锁问题? 信号量实现的模型 先进入函数 : Sem_wait() 后比较比较: 进入睡眠模式(sem&lt;0)不会释放锁 12Sem_wait(&amp;mutex); // 已经获得锁了Sem_wait(&amp;empty); // 进入等待的时候**不会释放锁** 条件变量实现的模型: 先比较 : 有一个全局的共享变量, 进行标识buffer值的大小; 后进入函数: while 判断, 决定是否要进入 Pthread_cond_wait函数 123Pthread_mutex_lock(&amp;mutex); // 已经获得锁了while( count == 0 ) Pthread_cond_wait(&amp;full, &amp;mutex); // 进入等待时,会释放锁的; 信号量解决的问题 读者–写者锁实现方式? 读者锁: 一旦一个读者获得读锁, 其他读者也能获得该锁; 写者锁: 但是想要获得写者锁, 必须等待所有的读者结束; 哲学家就餐问题? 问题: 哲学家只有同时拿到左手边和右手边的参叉, 才能吃到东西? 如何进行同步; 解决: 防止出现死锁的状况, 在最后一个哲学家哪里, 调换一次拿叉子顺序 1234567891011void getfork()&#123; if( p == MAX-1 )&#123; // 换一下拿叉子的顺序 Sem_wait( &amp;fork[ right(p) ] ); Sem_wait( &amp;fork[ left(p) ] ); &#125; else &#123; Sem_wait( &amp;fork[ left(p) ] ); Sem_wait( &amp;fork[ right(p) ] ); &#125;&#125; 通过锁和条件变量 实现信号量 实现方式code: 通过一把锁, 一个条件变量, 一个状态变量 来记录信号量的值; a. 锁实现时: 共享变量是 0和1之间切换; semaphore 实现时, 是通过wait() 和post() 加1和减1 b. 唤醒机制 使用条件变量实现 常见的并发问题并发缺陷(非死锁) 类型 原因 解决 违反原子性 代码执行时, 被中断打断 加锁, 实现互斥 违反顺序性 先使用, 后初始化 添加一个条件变量, 锁, 状态变量( 或者信号量 ) 死锁缺陷 什么是死锁? 线程之间相互依赖, 相互等待对方释放; 12thread_1: do_something( lock(L1), lock(L2) ) // 线程各自持有一个锁, 等待对方释放锁thread_2: do_something( lock(L2), lock(L1) ) 死所发生的原因和解决的方法 死锁情况一: 循环等待 解决: 通过一个比较, 让其按照摸个顺序访问.(类似于哲学家就餐问题) 12345678if( m1&gt;m2 )&#123; // 换一下拿叉子的顺序 pthread_mutex_lock(m1); pthread_mutex_lock(m2);&#125;else &#123; pthread_mutex_lock(m2); pthread_mutex_lock(m1);&#125; 死锁情况二: 持有并等待 解决: 通过原子性的抢锁; 通过设计一个全局锁; 死锁情况三: 非抢占 解决: pthread_mutex_trylock() // 尝试获取锁, 如果由程序占用, 则失败 死锁情况四: 互斥 很难解决, 代码存在临界区; 解决死锁方式: 通过调度避免死锁; 在MapReduce (Google)系统中, 可以完成一些并行计算, 无需使用锁; 基于事件的并发 基于事件的并发解决哪些问题? 多线程中并发中, 存在并发缺陷的问题; 开发者无法控制某一个时刻的调度, 程序员创建线程后, 依赖操作系统的合理调度; 应用地方? 图形用户界面的应用 某些网络服务器, socket 阻塞和非阻塞? 阻塞(同步): 在返回给调用者之前完成所有的工作; 非阻塞: 接口开始一些工作后, 立即返回(将控制权让出), 让所 需要完成的工作都在后台进行; 其如何工作的? 事件循环 主程序等待某些事件的发生; event handle(事件处理程序): 依次处理事件; 显示调度: 决定处理哪一个事件 API: select() and poll() 1int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); select: 会依次检查文件描述符 0- ( nfds-1), 中满足后面三个条件的fds; 返回所有集合中就绪描述符的总数; FD_ISSET() 时间服务器可以查看哪些描述符已准备好数据并处理传入的数据; 基于事件的并发要求 无须锁: 基于单个CPU和事件的应用程序, 一次只处理一个时间, 属于单线程, 不存在并发问题; 要求一: 不允许使用阻塞调用 问题一: I/O请求会阻塞程序? 解决阻塞问题方法: 通过异步I/O进行处理 使用的接口: AIO control block 作用: 接口在接到I/O请求后, 在I/O完成之前, 将控制权返回在调用者; 另外的接口可以查询是否完成; 问题二: 状态管理 收官栈管理;]]></content>
      <categories>
        <category>Operate System</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS虚拟化]]></title>
    <url>%2F2019%2F07%2F15%2FOS%E8%99%9A%E6%8B%9F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[操作系统导论操作系统 程序运行的过程: 执行指令 内存中fetch（取址）– decode（解码） – excuse（执行）具体的操作 冯诺依曼计算机模型 操作系统作用： 程序运行需要内存调度, 设备交互; OS 作用: 确保系统易于使用且高效运行； OS 如何实现程序的高效运行： 虚拟化: 将物理资源(CPU, 内存, 磁盘)转换为更通用, 更强大的虚拟形式; 标准库API: 用户与OS交互的接口, 告诉操作系统执行哪些功能; 资源管理器: OS充当的角色, 合理高效的分配资源 时分共享 让每一个进程感觉到独占了CPU和很大的地址空间; 虚拟化 虚拟化的抽象模型: 假设有一个桃子(物理桃子), 但是有很多人想占有它 虚拟化: 将一个物理桃子, 变成多个虚拟的桃子, 造成一种假象. 虚拟化CPU : 机制 + 策略 硬件资源 + OS : 虚拟化实现多个CPU, 可执行多个进程; 实现方式: 采用多级反馈队列的调度方式, 在同级优先度的情况下采用轮转策略, 和上下文切换的机制, 完成进程的调度 虚拟化内存 OS 在单一的物理内存上为多个进程构建一个私有的, 很大的地址空间抽象; 用户程序生成的每个地址(能够看见的)都是虚拟地址; 实现方式: 通过最少最近使用LRU缓存替换策略, 使得总体TLB未命中的比例最小;采用分页的机制, 快速的从虚拟地址中得到物理地址; 进程是虚拟化的CPU, 地址空间是虚拟化的内存; 虚拟化CPU 机制的理解: 如何(how) 提供答案? 时分分享机制: 上下文切换 策略的理解: 那个(which) 问题? 轮转: RR时间片进行上下文的切换 调度策略存在为了优化机制的? 虚拟化CPU的机制 SJF / STCF : 周转时间; RR 时间片轮转: 响应时间 MLFQ : 优化周转时间和响应时间的指标 虚拟化内存的机制 base/bound : 内部碎片 1physical adress = virtual adress + base // 地址转换 分段: 外部碎片 1physical adress = base[segment] + offset 分割和合并: 减少内外碎片; 分页 + TLB: 实现快速的虚拟地址转换 1phyadress = PFN 组合 offset; (位连接) 除了物理内存之外, 还有硬盘; 进程 进程的定义: 从机器状态去理解: 进程是运行中的程序; 内存: 程序运行中读取和写入的数据就在内存中; 寄存器: 指令明确读取和更新寄存器; OS提供的基本抽象 程序是如何转化为进程的 通过OS进行控制: 将代码和静态数据, 加载到内存 为程序运行时的栈分配内存; 为程序的堆(heap)分配内存; 堆: 动态内存申请; 进程存在的状态? 进程运行在: CPU + I/O交互 基本的三种状态: 运行 + 就绪 + 阻塞 other: 初始化状态 + 结束状态 PCB 进程控制块: 记录进程的信息的数据结构, 进程列表 进程API – 用户如何调用进程 进程API接口 创建 , 销毁, 等待, 其他控制, 状态; fork() 创建新进程: 父进程返回新的pid, 子进程返回0; wait() 父进程等待子进程运行完时, 才运行自己; exec() 让子进程执行和父进程不同的功能; fork() - exec() 设计的API 给shell 在fork之后, exec 之前执行其他代码的功能 重定向的实现: &gt; 关闭了标准输出, 输出到文件中; 机制 受限直接执行 问题一: 如何解释受限? 进程必须能够执行I/O和其他的一些受限操作, 但又不能让进程完全控制OS. 如何实现受限执行 提供两种模式: 用户模式和内核模式 内核模式: 系统调用时, 进程执行前必须执行陷阱(trap) 指令和陷阱处理程序 问题二: 如何实现进程间的切换? a) 首先: OS 获取CPU的控制权 协作方式: 当进程在进行系统调用是, 将CPU的控制权转交给OS 非协作方式: 重启 / 时钟中断 b) 保存和恢复上下文文切换 OS 为正在执行的进程保存一些寄存器的值; 并为即将执行的进程恢复一些寄存器的值; 内核模式下, OS控制进程执行陷阱和陷阱处理程序, 时钟中断以及操作系统和硬件在程序间切换, 谨慎的保存和恢复上下文的状态. 策略 进程调度 概念: 工作负载的概念? 进程运行过程中: 既有运行时间短, 响应时间快, 频繁放弃CPU的交互型I/O工作; 也存在需要很多CPU时间, 响应时间并不是很重要的长时间计算型工作. 调度指标一 : 周转时间 1T(周转时间) = T(完成时间) - T(到达时间) // 一般使用平局周转时间,也就是完成所有进程时间 策略一: SJF shortest job first 使用最短任务优先策略的前提: 所有工作同一时间到达; 非抢占式 策略二: STCF shortest time-to-completion first 抢占式的: 最短完成时间优先的一种调度策略; 两种策略的问题: 只考虑周转时间; 而且需要提前知道工作完成的时间;(不可能实现的) 调度指标二 : 响应时间 1T(响应时间) = T(首次运行时间) - T(到达时间) // 使用的是平均响应时间 策略: 轮转 RR round- robin 衡量一种时间片RR(time slice)的大小; 让每一个进程交替运行RR时间片的长度, 直到所有工作完成 轮转策略问题 RR时间片很小的情况下, 上下文的切换成本将会影响整体性能; 只关注响应时间; 调度策略: 重叠 通过使用重叠, 更好的利用资源; 重叠的实现: 在进程A I/O申请时, 切换进程B; 然后当进程A I/O释放时, 由B进程切换到A; 调度: 多级反馈队列 MLFQ需要解决的问题 (multi-level feedback queue) 优化周转时间: 基于STCF策略 优化响应时间: 基于轮转策略 使用MLFQ调度规则的前提条件? MLFQ拥有许多独立的队列, 每个队列有不同的优先级 任何时刻, 一个工作只能存在与一个队列中; MLFQ 如何实现调度? 通过观察工作运行状态调整其对应的优先级; 对于不断放弃CPU等待键盘输入的工作, 保持其高优先级 对于长时间占用CPU的工作, 不断降低其优先级; 相同优先级采用的策略: 轮转 MLFQ最重要的一个工作就是设置优先级? 调度: 比例份额 比例份额调度算法: 确保每个工作获得一定比例的CPU时间, 而不是优化周转时间和响应时间 比例份额存在问题? 比例份额如何分配? 随机性: 不能很好的适应 I/O的操作; 调度 :多处理器调度 多处理器和单处理器(CPU)区别? 硬件缓存cache的使用 缓存的共享: 通过总线的方式实现一致性 多处理器之间共享数据的方式 同步: 通过加锁的将多个函数封装为原子操作; 多处理器和单处理器(CPU)切换的问题? C应用程序的问题 重写C应用程序, 大部分只用到一个CPU; 多线程并行执行, 将工作分散到多个CPU上 虚拟化内存 为什么要虚拟化内存? OS让每一个程序员觉得, 它是有用一个很大的连续地址存储空间, 用来存放其代码和数据; 隔离和保护: 不希望错误的程序读写或者覆盖其他程序的内存; 如何实现虚拟化? 硬件 + OS 将这些虚拟地址映射为内存中实际的物理地址, 从而读取内存中的数据; 机制: 地址转换 动态重定向和分段: 基于基址/界限寄存器进行转换地址 内存空间分页 : 基于TLB地址缓存, 根据VA中的VPN快速得到PA; 策略: 使用最少最近使用LRU缓存替换策略, 使得总体未命中的比例最小; 地址空间 地址空间的概念? OS 对物理内存的一个抽象. 如何实现有效的时分共享方法? 在进行上下文切换的时候, 将进程的状态信息保存在地址空间上; 这样能保证进程读写的效率; 虚拟内存 虚拟内存: 是OS操作系统的一个重要子系统; 虚拟内存的四个特点 透明: 为程序提供一个巨大的, 稀疏的, 私有的地址空间的假象, 其中保存了程序的所有指令和数据; 效率: 通过每一个虚拟内存的索引, 将虚拟地址转换为物理地址, 物理内存根据物理地址获取所需信息; 保护: 确保程序之间互不影响; 灵活性: 程序以任何方式访问自己的内存; 内存操作API 内存分为哪几种类型? 栈内存: 它的申请和释放由编译器隐式管理, 自动内存; 1int x; // 栈内存的申请, 用于存取临时的变量和值; 堆(heap)内存 : 它的申请是程序员显示调用库函数(不是系统调用); 程序员不主动释放, 即使进程关闭, 堆内存也会一直存在, 只不过会出现内存泄露问题 123int *x = (int *)malloc(sizeof(int)) // 栈和堆的分配在同一行int *x : 申请一个整形指针栈空间; malloc(sizeof(int)): 在堆上请求整数的空间, 成功返回一个整数地址, 并**存储在栈**上供程序调用; + 字符串的动态申请 1char *string = (char *)malloc(strlen(string) + 1); 字符串一定要加1, 存在'\0' 为什么堆内存要进行释放free(), 栈内存不进行释放? 系统中存在两级内存管理 第一级: 操作系统执行的内存管理, 会在进程关闭时进行回收; 第二级: 在每个进程中进行堆内管理; 内存泄漏: 长时间运行的服务器, 当内存不够使用时, 就会发生内存泄露问题, 导致系统崩溃; 1valgrind: 查找程序中内存泄露的问题 反复释放内存 重复释放内存: 会造成错误double free 其他内存申请的接口 mmap() 调用操作系统获取内存 calloc(): 内存分配库 realloc():创建一个新的更大的内存, 并将旧区域复制到新区域中; 机制 : 地址转换 ( 实现方式: 单基址/界限) 如何实现地址转换? 硬件: 程序运行时, 硬件对每次内存的访问进行处理, 将VA(vitrual)转换为PA(physical); 将应用程序重定向到物理内存, 读取相应的数据; OS: 在关键点进行介入, 设置好硬件, 管理内存; 记录占用/空闲的内存位置; 动态(基于硬件)的重定位 CPU包含两个寄存器 基址寄存器(base): 将虚拟地址转化为物理地址 1physical adress = virtual adress + base // 地址转换 界限寄存器(bound): 确保地址在进程地址范围内; 1初期的内存分配: 每个进程分配固定大小的bound内存空间 内存管理单元(MMU): 负责地址转换的部分 也就是 基址/界限的地址转换; 硬件产生异常 当用户尝试非法访问内存时, CPU能够产生异常 动态的重定位(OS的作用) OS正确设置硬件后, 只有在进程产生异常时才介入, 其余时间任凭进程运行在CPU上; 基址/界限 的地址转换方法存在的问题? 内部碎片: 地址空间的分配是固定大小的槽块; 解决方式: 分段的概念; 机制: 分段(多基址/界限) 泛化的基址/界限 地址空间中保存了三个段: 代码段, 堆段, 栈段 每一个段: 包含一对base/bound; ( 动态重定位是三个段: 只包含一对 ) 段寄存器的概念？ 段寄存器: 每个段中含有一对基址/界限 寄存器 段错误: 虚拟地址转化为内存地址时, 越过了界限值; 分段后: 如何进行地址转换? 虚拟地址的二进制形式; 120-2bit: 00- code -- 01 -- heap(n-2)bit: offset 地址转换 1physical adress = base[segment] + offset 地址转换 – stack 栈: 反向增长的; 确保反向偏移量的绝对值小于段的界限; 分段有哪些优势? 减少动态重定位中造成的内部碎片, 更好的支持稀疏地址空间; 代码共享: 增加段保护位, 这个段可以被映射到多个虚拟空间, 实现共享; 分段造成的问题? 由于段的稀疏分布, 造成地址空间中含有多个小的已分配的内存空间; 外部碎片: 无法找到一个连续大的空闲的地址空间; 空闲空间管理MMU 这里不思考虚拟化, 思考空闲的内存管理MMU. 针对外部碎片: 如何减少外部碎片的产生, 更好的维护空间内存? 内部碎片: 地址空间分给了进程后, 一部分未使用; 外部碎片: 地址空间没有分配给进程, 但是被分配的段空间隔成非连续的空间; 底层机制: 分割与合并: 对空闲内存的基本操作, 满足用户的空间需求; 追踪已分配的内存空间 在用户malloc申请堆内存时: 分配一个头部(记录了空间大小) + 用户空间; 在用户free()时, 根据这个头部指针能快速定位: 释放了头部 + 用户空间; 嵌入空闲列表 通过 头部 + 剩余空间数目：描述堆中空闲的内存块； 基本策略（在满足用户需求下，减少外部碎片） 需要额外的查找开销：最优/最差匹配 首次匹配：找到一个足够大的就返回给用户； 下次匹配：维护一个指针，指向上次查找位置； 空闲空间管理的模型: 伙伴系统 通过 2^N 进行分割合并; 其分配的空间大小: 按照一分为二的原则进行; 机制: 分页 分段: 将一个进程的地址空间, 分割成长度不一的逻辑段(代码, 堆, 栈); 代码 , 堆, 栈: 各自映射为一个虚拟内存; 分页: 将一个内存地址空间, 分割成固定大小的单元, 这个单元称为页; 每一个页 –&gt; 称为页帧; 物理页帧PFN (physical page frame number) 每一个页帧 –&gt; 包含为一个虚拟内存 分页后: 如何进行地址转换? 页表: page table 记录虚拟页放在物理内存中的位置; 是每个进程单独的数据结构; 保存在物理内存中的: 需要访问内存才能实现地址转换; 虚拟地址包含两个部分 虚拟页面号VPN: virtual page number 1计算VPN的大小: 总的地址空间(总的bit) / 每个页的大小 + 页内偏移量offset: 1offset(bit) = 总的(bit) - VPN(bit) 地址转换 12通过VPN找到物理内存中的PFN;phyadress = PFN 组合 offset; (位连接) 分页优化: 快速地址转换(TLB) 对内存地址分页后, 存在哪些问题? 页表记录单元页的地址映射信息, 保存在物理内存中的; 问题一: VA-&gt;PA , 需要对内存中的页表进行访问, 增加时间开销; 解决的方法 增加硬件: 地址转换缓存TLB (地址转换旁路缓冲存储器)translation-lookaside buffer; TLB: 记录的是 – 已经经过VA –&gt; PA 映射的记录; 1VPN | PFN | 其他位 分页 + TLB 模式 分页 + TLB 模式 : 如何实现地址转换 VA : 先从VA中得到VPN 虚拟页号; TLB命中 查找含有 VPN记录 : PFN 组合 offset –&gt; PA –&gt; 访问内存; TLB未命中 查找TLB的记录没有VPN: RISC 精简指令集, 软件管理TLB处理:??? a) 硬件 : 抛出异常 b) OS : 提升为内核模式, 跳转到陷阱处理程序, 完成页表的映射转换, 更新TLB, 从陷阱返回; c) 硬件: 再次查找, 此时TLB命中; 上下文切换时 – TLB的处理 问题: TLB 包含的物理地址映射只对当前进程有效(除非标识共享), 对其他进程无效( vaild 有效位标识); 解决方式 : 增加地址空间标识ASID TLB就可以记录不同进程的地址转换; 在上下文切换时, 根据ASID进行查找 TLB 替换策略 TLB 包含的内容 页表优化: 多级页表 问题二 : 分页过多, 造成页表记录太大的问题? 解决的问题: 如何降低页表的大小? 方法一: 分段 + 分页 虚拟地址解析: 1seg(2bit) + VPN(页的个数) + offset() 缺点: 还是存在分段, 因此空间分配不是那么灵活, 会造成外部碎片 方法二: 多级页表 实现方式 将页表分配成页大小的单元; 整页的页表无效, 就不分配页表; 页目录结构PDE(page directory entries)包含 有效位valid bit : 记录整页页表是否有效 页帧号PFN 虚拟地址解析三部分 1(VPN = )[页目录PDE + 页表索引] + offset 多级页表的缺陷 多级页表可以尽可能提供较小的表 但是当TLB未命中时, 需要从内存加载两次, 才能获取正确的地址转换信息; 一次用于页目录;(PDE) 一次用于页表索引(PTE) 超越物理内存 : 机制 上面的地址空间, 我们一直假设: 能全部放入物理内存? 内存层级: 用到的地址空间: 保存在物理内存中; 未用到的地址空间: 保存在硬盘上; 虚拟内存的实现 : 物理内存 + 硬盘 交换空间定义: 在硬盘上开辟出一块空间用于物理页PFN 的移入和移出; 两个概念 TLB: 地址转换缓存 (地址转换旁路缓冲存储器) 保存的是: 已经经过VA –&gt; PA 映射的记录; 1VPN | PFN | 其他位 PTE : 页表, 存储于物理内存 / 硬盘上的 列表 保存的是: 虚拟页VPN 和 物理页PFN 的对应关系; 物理页放在交换空间, 如何处理TLB未命中的情况? 存在位 valild bit 1 : 存在与物理内存中的PTE页表中; 0: 不存在物理内存中, 触发页错误; 页错误的处理 OS 进入内核模式: 发送请求给 交换空间的PTE页表 如果PFN 存在于PTE页表中: 将其物理页交换到内存中, 并将地址转换记录更新到TLB中; 然后硬件重新执行 如果PFN 不存在于PTE: OS kill杀死进程; 超越物理内存 : 策略 最优策略的目的是什么? 使得总体未命中的比例最小; TLB缓存未命中的三种情况 强制性: 缓存一开始为空, 第一次引用; 容量: TLB空间不足, 需要踢出一些记录, 更换新的记录 冲突: 出现在硬件中; 策略 先入先出FIFO 随机踢出 最少最近使用LRU(Least-Recently used) 如何实现LRU策略 增加一个使用位 use bit 时钟算法: 当找到一个use bit 为0 的记录, 就将其踢出替换; 注意: 脏页: 通过使用一个dirty bit 记录; 脏页: 是不进行替换的, 它改变的值要写入磁盘; 频繁分页到硬盘, 成本太高; 所以过度分页最好的办法 : 购买更多的内存;]]></content>
      <categories>
        <category>Operate System</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化时间和空间效率]]></title>
    <url>%2F2019%2F07%2F06%2F%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[优化时间和空间效率 Introduction 数据结构：对大量数据的组织和研究 算法分析：对算法运行时间的评估 运行时间最坏的计算。 数学知识 指数 和 对数之间的转换 级数公式 当 i 趋近于无穷时，得出一个公式的表达式 模运算 除法需要很高的时间复杂度 归纳法证明： base case 成立 k成立 – &gt; (k+1)成立 反证法证明 递归实现 Algorithm 对于一个问题：给定某种算法并且确定其是正确的 最重要的一步便是：计算时间和空间资源 相对增长率 四种增长关系的定义 将其放在坐标上表示： 1）常数：是直线 2）乘级：直线方程 四种定义：在坐标上理解其含义 1) 大O： &lt;= 的关系；是上限值 2) 小o : &lt;的关系 3) omega: &gt;= 的关系；是下限值 4) theta: = 的关系 相对增长率 算法分析中，相对增长率是很重要的度量 关系表达式中 大O：精度表示的时候 1）各种简化的方式都是可能发生的 2）低阶项可以忽略；常数项可以省略 取 lim [ f(N) / g(N) ] 极限的值，便能得到增长率的关系式 运行时间的计算 算法的时间复杂度：针对的是大量数据的计算，小量数据不用花费时间设计算法 1）考虑数据读入的时间效率； 2）低效的算法：虽然算法复杂度低，但是对数据的处理基本上处于停滞状态 2）算法足够有效，也不产生其他问题，这样的算法才是好的 最大O时间单元的计算： 大O：是上限值 1）一次赋值：一个时间单元 2）一次return value ：一个时间单元 3）+ - × / ：一种运算算一个时间单元 4）包括循环里面的：赋值，比较运算–&gt;一次一个时间单元 5）省去低阶和常数 计算时间成本：将O( ) 作为上限后，有几种简化的法则，不用一步步去加 1）for(;;) –&gt; 时间=测试语句 × 迭代次数;化简为O(N); 2）for(;;)嵌套 –&gt; O(N^2); 3) 计算任何一件事，都不要超过一次 最大子序列：只能顺序取一个序列，中间不能有跳过 几种常见算法的时间复杂度 对分查找： 在排好序的数组中进行的这半查找 它提供了在 O(log N)的时间内进行查找 幂运算 还是利用指数折半进行计算 线性程序：顺序执行的程序 O(N) 非线性程序：O( N * log(N) ) 时间效率优化时间效率编程习惯 传递复杂参数：使用指针； 值传递：需要产生一次复制的操作 循环和递归 循环：当递归中有大量的重复时，使用循环； 各类查找算法 数组中下标特性应用一： 面试题39：数组中出现次数超过一半的数字. 题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字 存在三种解题思路； 快速排序数组；改变数组值 考虑数组下标的特性；改变数组值 考虑数字超过一半这个特性，并且只遍历一边数组，不改动数组； 应用二：面试题40：最小的k个数。题目：输入n个整数，找出其中最小的k个数应用三：面试题41：数据流中的中位数。题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么 中位数就是所有数值排序之后位于中间的数值 题目注意：数据流中读出，数目随时间变化而增加；需要考虑数据容器。 数据结构的选择 ​ a. 数组：进行插入排序，需要移动O(n)个数, O(1)得到中位数； ​ b. 排序链表：和插入排序数组一样； ​ c. 二叉搜索树：插入 – 平均O(log(N))，最差O(N); 查找O(logN),最差O(N) ​ d. AVL树：让左右子树的高度差不超过1，插入O(logN), 查找O(1); 接口很难实现 ​ e. 最大堆和最小堆：保证数据平均分配到两个堆中； ​ 最大堆：保存着小于中位数的那些数； ​ 最小堆：保存着大于中位数的那些数；、 ​ 3. 代码没有实现 应用四：面试题42：连续子数组的最大和. 求所有子数组的和的最大值,并输出子数组 解题思路二：分析数组规律 连续子数组的最大和： 当前面的和小于0时，删除啊前面的序列，从当前位置开始； 应用五: 面试题49：丑数. 题目：我们把只包含因子2、3和5的数称作丑数（Ugly Number)将大数转化为字符串处理应用一：面试题43：从1到n整数中1出现的次数。题目：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数 解题思路：字符串的应用 将整数转换为字符串进行处理 将大数进行分段处理的实现 应用二:面试题44：数字序列中某一位的数字. 题目：数字以0123456789101112131415…的格式序列化到一个字符序列中 解题思路：对大数的位数进行区分； 通过对数字位数进行区分得到规律; 应用三: 面试题45：把数组排成最小的数. 题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 应用四: 面试题46：把数字翻译成字符串. 题目：给定一个数字，我们按照如下规则把它翻译为字符串哈希表应用一:面试题50（一）：字符串中第一个只出现一次的字符. 哈希表的实现: 以空间的消耗, 换得时间效率的提升; 应用二:[面试题50（二）：字符流中第一个只出现一次的字符. 有问题, 没有实现出来;]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>O(N)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F2019%2F06%2F26%2FString%2F</url>
    <content type="text"><![CDATA[数据结构–字符串字符串相关知识 字符串赋值给数组 字符串结尾影藏 ‘\0’; 字符串赋值给数组：数组要分配内存空间存储 1char str[100] = "fdslajfk"; // 数组的内从空间可以使动态分配,或者直接分配一个足够大的空间就行 字符串赋值给指针：指针指向字符串地址，不分配内存空间 网络编程中，URL参数含有 #，空格，则不能正常访问 将特殊字符进行替换 替换规则 ： % + ASCII(十六进制表示) 字符串表示一个大数的方式： 将大数转化为一个字符串: 123char string[50];int number = 21345;sprintf(string, %d, number); // 将大数number, 转化为字符串后, 保存在string中 字符串赋值和指针的关系 (1) 同一个字符赋值给两个指针；这两个指针保存的地址是一样的，所以改变其中一个的值，另外一个也会变 (2) 打印字符的首地址: 通过 %p的形式; 123456789101112char name = 'a';char *str = &amp;name;char *pbeg = &amp;name; printf("str adress is %p value is %c:\n", str, *str);printf("pbeg adress is %p value is %c:\n",pbeg, *pbeg); char temp = 'b' ;*str = temp; // 注意，这里赋值的是值；不能是地址 printf("str adress is %p value is %c:\n", str, *str);printf("pbeg adress is %p value is %c:\n",pbeg, *pbeg); 1234str adress is 0x7ffda0eefe36 value is a:pbeg adress is 0x7ffda0eefe36 value is a:str adress is 0x7ffda0eefe36 value is b:pbeg adress is 0x7ffda0eefe36 value is b: 字符串的动态空间申请 1char *number = malloc(strlen(str) + 1); //字符串不使用sizeof() 字符串的相关笔试题目 应用一：面试题5：替换字符串中的空格 (通过特殊字符替换字符串中的 “#”, “ “) 应用二：面试题17：打印1到最大的n位数(n==2 打印1-99) 应用三：面试题19：正则表达式匹配 根据题目的要求：举例子后找出规律； 应用四：面试题20：表示数值的字符串。判断字符串，是不是数值应用五：面试题38：字符串的排列 。题目：输入一个字符串，打印出该字符串中字符的所有排列 字符串的排列： ​ a. 将字符串分为两部分：第一个字符，后面的所有字符； ​ b. 通过第一个字符和后面的字符一一交换；然后固定第一个字符；（全排列的首字母） ​ c. 然后将后面的字符：再次分为两部分，递归过程a,b; ​ d. 直到后面的字符为 ‘\0’ 打印 字符串的组合： 应用六: 面试题58（一）：翻转单词顺序. 题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。应用七: 面试题58（二）：左旋转字符串. 题目：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。应用一：题目：字符串转换到int类型，使用atoi函数可以轻松完成类型转换应用二： 题目：Int型整数，转化为字符串]]></content>
      <categories>
        <category>data struct</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码质量]]></title>
    <url>%2F2019%2F06%2F26%2F%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[代码质量的要求代码编写的要求 代码的规范性 代码的完整性 需要进行三方面测试 边界值测试：循环条件是否正确 错误的处理方式 全局变量的处理方式：检查全局变量，进行相应的错误处理 代码质量完整性练习应用一： 面试题 16不使用库函数，实现pow函数的功能，求base的exponent次方 异常情况：需要异常处理 通过举例的方式，找出特殊的情况 base = 0.0; exponent &lt; 0; 需要异常处理 double 精度数的比较 12double d1=0.0000001，double d2=0d 由于精度不一样，一般不直接使用 “==” 设定一个允许的误差值，对两个double类型数据做差，求绝对值再和允许的误差做比较来判断是否相等。 C规定，float 类型必须至少能表示6位有效数字 全局变量对局部变量的修改 局部变量中的值修改，调用修改函数后，会对全局变量产生影响； 应用二：面试题17：打印1到最大的n位数 相当于考察数据结构[字符串]，算法实现[递归和循环] 大数的存储：采用字符串或数组进行表示 : char i : 表示 ‘0’ - ‘9’ 每一个字符，保存一位 如何打印 方法一：通过对数加1，进行循环打印 方法二： n位的十进制数，相当于 n 个从0到9的全排列，递归实现全排列 符合阅读习惯：098 只能答应 98；从第一个非0开始打印]]></content>
      <categories>
        <category>Sword offer</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕设的方向]]></title>
    <url>%2F2019%2F06%2F22%2FOpenLink%2F</url>
    <content type="text"><![CDATA[毕设的方向 基于物联网设备的边缘计算系统的搭建 研究背景​ 随着大数据、云计算、物联网、人工智能等技术的快速发展，万物互联时代加速到来，连接到网络的设备数量和数据量都呈现快速增长态势。 ​ 如果按照传统的方式，将嵌入式设备采集到的数组一起发送到云平台，将会造成网络的严重负载。云计算模式的缺陷日益突出，而边缘计算为解决工业互联网智能制造过程中数据分析和实时控制提供了有效手段。 ​ 在健康监测等领域，边缘计算可以让需要针对用户进行无监督机器学习的可穿戴设备获益颇多。此外，在未经事先学习的情况下，定制的应用程序若要实现迅速推理，通常需要极高的数据处理能力作为支撑，而这正是边缘人工智能的专长所在。 研究内容 边缘人工智能化：嵌入式设备方案 + 物联网云平台 + 边缘计算框架的搭建和部署 嵌入式设备方案 (嵌入式方案可以更换) 看物联网如何颠覆传统设计，这十个方案给你答案！ 题目一：基于STM32单片机的物联网远程数据监控系统 物联网云平台 通过WIFI无线通讯技术将数据上传到物联网云平台，通过物联网云平台将数据可视化， 可进行远程监控和计算 边缘计算框架的搭建和部署 研究边缘计算的相关框架，以及如何将模型迁移到物联网的基础设备上 将一部分的计算放在嵌入式设备上，减少云平台和嵌入式设备间的直接交互； 通过嵌入式设备本地的计算，发送控制信号； 物联网 + 边缘计算 ：是一种理论的研究。仿真或者是 边缘智能或将打通物联网应用之路的最后一公里 物联网+边缘计算：减少物联网设备中数据的发送，在边缘进行处理 我们能得到什么 计算的迁移 我们手机端 或者后台的算法可以迁移到嵌入式设备上； 嵌入式设备就不需要一直与后台交互才能得到指令； 我们的睡眠监测，如果用户不想打开手机的话； 我们就需要将数据的计算放在嵌入式设备上，让其计算后得到报警指令； 当我们嵌入式设备量很多的时候 比如：我们的空中检测仪，当数量很庞大时，一起使用是，必然造成蓝牙传输的阻塞，导致我们APP上波形显示延迟度高 我们就可以在嵌入式设备上，进行数据的筛选，将需要的数据发送到手机端后者后台，后台在用已选择的数据进行计算； 边缘计算 让嵌入式设备：不在只做数据的采集端和搬运工； 让嵌入式设备，在原有的基础上智能化；这也是5G商用后，物联网设备需要进行的革命 这次研究后 结合物联网平台的使用：在嵌入式设备采集到数据后，不是一直需要Android进行收集，而是通过物联网平台进行展示，通过物联网平台进行数据处理，从而缩短研发成本； 结合边缘计算： 将计算嵌入到物联网设备中，而不是脱离网络后，嵌入式设备就不能工作； 当嵌入式设备量很大时：我们能有效降低能耗，减小延迟 无线睡眠全态监视系统电路设计设计背景 眠呼吸暂停症是一种很常见的睡眠呼吸疾病，根据研究调查，在美国约有 24%的成年男性及9%成年女性或超过 200 万人口患有此疾病，在中国台湾至少有 35 万人也有此问题。一般在诊断患者是否罹患睡眠呼吸暂停症是指患者在睡眠中出现呼吸暂停和低通气的总次数超过每小时 5 次。 采集模块 心率和血氧采集 ：Max30102; 鼾声感测电路：检测呼吸暂停，呼吸阻塞时的声音 睡眠姿态检测电路：身体是否平躺； 判断和处理机制 通过三方面的数据判断用户是否处于呼吸暂停状态； 唤醒方式： 硬件唤醒：震动加蜂鸣器 软件唤醒：手机APP短信； 数据保存： 外挂FLASH进行保存； 蓝牙发送到手机； 应用 是关于睡眠呼吸暂停检测的；他的新方法是加了呼吸暂停时鼾声的检测； GLO：物联网智能灯设计背景 GLO 不仅仅是一种灯，您可以将其改变成您喜欢的任何颜色。 而 GLO也可以在您不在的时候充当您家中的安全监控器。 当任何人进入房间时，GLO 将自动打开灯。 当房间变暗时，GLO 可以自动打开灯。 应用场景 睡眠模式状态，或者工作模式下灯管的颜色切换； 当任何人进入房间时，GLO 将自动打开灯； 1（1）是一个比较新的GLO物联网灯，这个灯可以根据RGB混合出喜欢的颜色，以及作为自动开关的灯；（2）也可以作为室内预警检测；（3）是否能作为睡眠呼吸暂停的辅助设计，变成一个呼吸灯； 其他 加一个磁铁在底部，制作成悬浮的智能灯 制作一个迷你雷达，检测周围是否存在人； 室内环境传感器装置设计背景 如今，人们更关心他们居住的室内质量，因为这与他们的健康息息相关。拥有更好的生活质量的重要性包括知道您的生活条件得到改善。 一些办公室可能安装了自己的室内环境传感器，以便为员工提供更好的工作环境。但我怎么知道我住的楼宇甚至是我租的房间都能提供良好的生活条件？ 采集模块 温湿度传感器 SHT31 气压和海拔高度 BMP280 空气质量传感器 CCS811 光传感器 响度传感器 带适配器的 PM2.5 传感器（PM1.0，PM2.5，PM10） 应用场景 室内环境传感器装置，主要就是能够实时、便携的检测除室内的环境；]]></content>
      <categories>
        <category>毕业设技</category>
      </categories>
      <tags>
        <tag>毕设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一维数组和二维数组的查找]]></title>
    <url>%2F2019%2F06%2F15%2F%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[数组中元素的查找数组方法的应用 缺点 空间效率应用差 优点 内存连续：根据下标在O(1)时间读写任意元素； 数组实现简单的哈希表 一维数组 解决问题：在一个长度为n的数组里的所有数字都在0到n-1的范围内。找出重复的数字 和面试官交流的问题： 数组是否排序； 数组是够可以改变； 数组的情况 方法 时间 空间 数组排序 遍历下标和数组元素值 O(n) O(1) 未排序，可改变数组 先排序O(nlogn)，在遍历(O(n))： O(nlogn) + O(n) O(1) 创建哈希表，记录次数 查找O(1) O(n) 下标和值对应相等，不相等则进行交换 O(n) O(1) 未排序，不可改变数组 创建额外O(n)数组，复制条件：数值为m元素放在下标为m处的位置 遍历一遍O(n) O(n) 二分查找法：中间元素进行分半 O(nlogn) O(1) 时间和空间复杂度：查找元素时候的花费 创建哈希表的时候，以数组的下标进行分就行；扫描一遍数组，便能通过O(1)的时间查找出有无重复 二维数组 解决问题：二维数组中元素的查找 和面试官交流的问题： 数组是否有递增的规律； 数组的情况 方法 时间 空间 数组未有递增的规律； 遍历数组 O(n^2) O(1) left to right 递增 col : up to down 递增 从右上角进行遍历 O(row) or O(col) 数组注意事项 bool 类型 1#include &lt;stdbool.h&gt; //C中包含头文件 while 和for 循环 for : 准确知道循环次数； while：准确知道循环结束条件 数组的长度 1length = sizeof(array) / sizeof(int); /* 分32位和64位的系统，判断数组中一个元素占4个字节 */ 二维数组的表示 通过一位数组的方式，表示二维数组 1matrix[row*cols + col] == number) 题目强调不能修改数组中的元素 1const int *number; 数组越界情况 array [ N ] ：元素访问从 array[0] – array[ N-1 ] array [N] : 访问不到 %p 1printf("%p\t", (&amp;numbers)[col]); //printf函数族中对于%p一般以十六进制整数方式输出指针的值，附加前缀0x 数组作为形参传递后, 不能通过sizeof(array) / sizeof(int) 计算长度? a. 函数数组名作为参数传递后, 从数组的首地址退化为了一般的指针 b. 使用动态分配的数组; 这样就可行 123456// a. 数组作为形参传递 // int array[] = &#123;4, 5&#125;; // b. 动态分配数组 int *array = malloc(sizeof(int) * 2); array[0] = 4; 数组和指针一位数组 数组名的概念： 下表和数组名一起使用，用于标示该集合的某个特定值； 数组名的值：是一个指针常量，也就是数组第一个元素的地址； 常量：是不允许修改的 错误： 1int a[10]; int b[10]; a=b // 错误的，数组元素的复制要通过循环；数组名是一个指针常量 下表引用 下标应用 间接访问 :相互等价的； 12array[subscript]; *(array + (subscript)) // 首元素的地址，加上一个偏移量，间接访问某一个元素 在使用下标的地方，可以使用对等的指针表达式来替代； 效率问题 在正确使用的前提下：下标绝不会比指针更有效率，但是指针有时会比下标有效率； 可读性 &gt; 细微的时间效率； 数组和指针 数组声明：编译器将根据声明的元素数量，为数组保留内存空间；然后在创建数组名，指向这段空间的起始位置； 指针声明：只为指针本身保留内存空间，并不为任何整形值分配内存空间； 在未被初始化之前：指针变量并未初始化指向任何现有的内存空间， 作为函数参数的数组名 传递给函数的参数：传值调用—- 通过传递值的方式进行； 传址调用：传递一个指针，通过指针进行间接访问，实现对数据的操作； 字符数组的初始化 12char message1[] = "hello"; // 字符数组的初始化char *message2 = "hello"; // 表示字符串常量，指针指向其存储位置； 多维数组 多维数组： int array[3] [4] : 一维数组的一维数组；包含3行元素，每行包含4个元素 存储顺序 行主序存储：按照最右边下标率先变化的原则； 数组名： 一位数组名：值是一个指针常量，类型：是指向元素类型(int)的指针；int *p = array; 二维数组名：多维数组第一维的元素实际上是另外一个数组； matrix: 数组名表示一维中的第一个元素 1int matrix[3][3]; // matrix 下标 int matrix[3] [3] 第一维元素的地址和值表示：第一维其实是每一行数组的首地址 123matrix; //表示一维中的第一个元素的地址，指向包含3个整形元素的数组的指针 (matrix + 1); // 表示一维中的第二个元素的首地址；*(matrix + 1) -- &gt; matrix[1] ---&gt; matrix[1][0]; 间接访问第一维的元素，表示的是每行中首元素 第二维元素的地址和值的表示： 12*(matrix + 1) + 2 ---&gt; matrix[1] + 2 ---&gt; ; // 表示的是第一行第二列元素的地址*(*(matrix + 1) + 2) ---&gt;*(matrix[1] + 2) ----&gt; matrix[1][2]; // 间接访问：表示的是元素 指向数组的指针 123int matrix[3][10];int (*p)[10] = matrix; // 二维数组的表示；逐行访问；(*p)[10] --&gt; ( (*p) + 10) // 表示的是首行的地址 二维数组的列下标：必须是确定的 一维数组应用： 数组中查找重复元素的解题思路: 下标和下标对应值的关系 应用一： 面试题3(一): 找出数组中重复的数字 (交换元素直到number[j] == j应用二：面试题3(二): 找出数组中重复的数字 (递归二分遍历次数)应用三：面试题21：调整数组顺序使奇数位于偶数前面应用四： 面试题57（一）：和为s的两个数字应用五：面试题57（二）：为s的连续正数序列二维数组应用：应用一：题目：如何动态申请二维数组空间​ 1. 三种方式动态申请二维数组空间，并进行初始化，打印地址 应用一：面试题 4： 二维数组中元素的查找 (从矩阵右上角到左下角进行查找)应用二：面试题29：顺时针打印矩阵。题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字 考察边界条件的判断：全部梳理出来之后；就是顺序书写代码； 题目扩展： 逆时针打印呢？]]></content>
      <categories>
        <category>data struct</category>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表和双链表应用]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%2F</url>
    <content type="text"><![CDATA[链表节点的应用 动态分配的指针：使用后要进行销毁 对于需要判断的题目：使用bool类型创建函数； 比链表难得应用：就是树 链表插入的知识点 链表的插入：通过画图 链表的存储空间是不连续的，需要插入新的节点的时候 12#include &lt;stdlib.h&gt;$ malloc 双链表的插入：学会画图理解指针 链表出现的错误：指针变量定义，没有初始化 1error：memory access violation；segmentation violation 双等号 1return s-&gt;Next == NULL; // 这个 == 表示比较的意思；比较两个的值，返回值是0/1 插入 应用一 ：单向链表插入和删除的API 应用二：双链表节点的插入 应用三: 面试题6：从尾到头打印链表 删除应用一: 面试题18（一）：在O(1)时间删除链表结点 O(1)时间限制：不能按照常规思路，查找前驱节点； 将pToBeDeleted 的 Next_node 复制到删除节点位置，删除的是Next_node： 存在三种情况 a. pToBeDeleted 的下一个节点不为空； (n-1)O(1) –&gt; 不是尾节点的有n-1 b. 链表中只有一个头结点； – 指向指针的指针保证链表删除后，地址不会变 删除节点位于尾部： 需要遍历得到前驱节点 O(n) –&gt; 一个尾节点 应用二：面试题18（二）：删除链表中重复的结点 a. 如何删除：通过遍历时，节点值是否存在重复，进行节点的释放； b. 同一个值，赋值给两个不同指针时，两个指针的地址是一样的； c. 但是在删除重复节点时，需要一个节点一个节点的释放 链表的查找应用一:面试题22：链表中倒数第k个结点 当问题使用一个指针遍历一次解决不了问题时，通过两个指正进行快慢遍历 应用二：面试题23：链表中环的入口结点, 一个链表中包含环，如何找出环的入口结点？应用三：面试题52：两个链表的第一个公共结点. 题目：输入两个链表，找出它们的第一个公共结点。链表的反转应用一：面试题24：反转链表1. 题目一：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 2. 题目二：定义一个函数，输入一个链表头结点，从链表中的第 k 个节点到 m个位置进行反转，返回反转链表的头结点； 3. 题目扩展三：将链表前面k个节点进行反转； 用题目二的思路 应用二：面试题24(四)：从倒数第k个节点反转链表链表的合并应用一：面试题25：合并两个排序的链表 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 复杂链表应用一：面试题35：复杂链表的复制。将复杂链表复制，返回一个新的链表头指针]]></content>
      <categories>
        <category>sword offer</category>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sword_offer]]></title>
    <url>%2F2019%2F06%2F03%2FSword-offer%2F</url>
    <content type="text"><![CDATA[Sword_offer code 题目分析，判断条件，边界检测 总体规划 基础知识 编程语言：多翻阅几次C 的相关知识； LinuxC C Primer 数据结构：熟练掌握链表，树，队列，栈，哈希表； 链表的插入和删除 二叉树的遍历 算法：查找和排序算法 二分查找； 归并排序； 快速排序； 题目的分析方法 代码结构的布局 代码的检验 数据结构和算法 熟悉数据结构之间的特点，才知道如何选择 数据结构类型 类型 特点 数组和字符串 最基本 连续内存分别存储数字和字符 链表和树 出现频率最高 操作大量指针，留意代码鲁棒性 栈 算法采用方式 与递归紧密相关 队列 算法采用方式 与广度优先遍历算法相关 哈希表 解决问题：第一次只出现一次的字符 相关博客内容和题目汇集 数组 字符串 链表 栈和队列 树的应用 算法和数据描述相关问题 高质量代码需要考虑的方面 (16题-26题)) 优化时间和空间效率(39-52题 SwordOffer 面试题3(一): 一维数组, 可以修改数组的情况下 ，找出数组中重复的数字 面试题3(二):一维数组 :不可修改数组的情况下，找出数组中重复的数字 面试题 4： 二维数组中元素的查找，数组中重复的数字 面试题5：string– 替换字符串中的空格 面试题6：link – 从尾到头打印链表 面试题 7 ：tree – 根据前序遍历和中序遍历，构建一颗二叉树 面试题 8：tree– 找一颗二叉树中序遍历的下一个节点，节点有指向父结点的指针 面试题10：algorithm – 斐波那契数列，青蛙跳台阶 面试题11：algorithm查找排序 – 旋转数组的最小数字 面试题12：algorithm回溯法 – 矩阵中的路径 面试题13：algorithm回溯法 – 机器人的运动范围 面试题14: algorithm动态规划 – 剪绳子,给你一根长度为n绳子，请把绳子剪成m段 面试题15: algorithm位运算 – 计算一个整数转换为二进制后，1的个数 面试题 16: 高质量代码 – 不使用库函数，实现pow函数的功能，求base的exponent次方 面试题17：高质量代码 – 打印1到最大的n位数 面试题18（一）：link –在O(1)时间删除链表结点 面试题18（二）：link – 删除链表中重复的结点 面试题19：string – 正则表达式匹配 面试题20：string – 表示数值的字符串。判断字符串，是不是数值 面试题21：array – 调整数组顺序使奇数位于偶数前面 面试题22：link – 链表中倒数第k个结点 面试题23：link – 链表中环的入口结点, 一个链表中包含环，如何找出环的入口结点？ 面试题24：link– 反转链表(从第k-m个位置进行反转) 面试题24(二)：link– 从倒数第k个节点反转链表 面试题25：link– 合并两个排序的链表 面试题26：tree – 树的子结构 面试题27：tree – 二叉树的镜像 面试题28：tree – 对称的二叉树 面试题29：array: 顺时针打印矩阵 面试题30: stack – 包含min函数的栈 面试题31：stack – 栈的压入、弹出序列. 面试题32（一）：tree – 不分行从上往下打印二叉树。 层级遍历二叉树 面试题32（二）：tree – 分行从上到下打印二叉树。 每层打印之后换行 面试题32（三）：tree – 之字形打印二叉树 面试题33：tree – 二叉搜索树的后序遍历序列。输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果 面试题34：tree – 打印二叉树中和为某一值的路径. 面试题35：link – 复杂链表的复制 面试题36：tree – 二叉搜索树与双向链表. [面试题37: 序列化二叉树] 面试题38：string – 字符串的排列 面试题39：O(time) – 数组中出现次数超过一半的数字. 面试题40：O(time) – 最小的k个数 面试题41：O(time) – 数据流中的中位数 面试题42：O(time) – 连续子数组的最大和. 面试题43：O(time) –从1到n整数中1出现的次数 面试题44：O(time) – 数字序列中某一位的数字. 面试题45：O(time) –把数组排成最小的数 面试题46：O(time) –把数字翻译成字符串. 面试题47：algorithm动态规划 –礼物的最大价值 面试题48：algorithm动态规划 – 最长不含重复字符的子字符串. 扩展: 将这个长的字符串打印出来? 面试题49：O(time) – 丑数. 题目：我们把只包含因子2、3和5的数称作丑数（Ugly Number) 面试题50（一）O(time) –字符串中第一个只出现一次的字符. [面试题50（二）：字符流中第一个只出现一次的字符.] 面试题51：algorithm归并排序 – 数组中的逆序对 面试题52：list – 两个链表的第一个公共结点. ###]]></content>
      <categories>
        <category>offer</category>
      </categories>
      <tags>
        <tag>sword offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C_C++_test]]></title>
    <url>%2F2019%2F05%2F27%2FC-C-test%2F</url>
    <content type="text"><![CDATA[C/C++ testQuestion 数组和指针间的相互表示？ 用指针表示某一个数组元素 常量的表示 e 后面是指数，不能有小数：e0.4 关键字 全部都是C / C++关键字 关键字小写； C/C++ 没有太大区别 类型转换 假定x和y为double型，则表达式x=2，y=x+3/2的值是 3/2=1 3.0/2.0=1.500000 y = (double) 3/2; –&gt; 1.5 取余数 0 % 2 余数和商都是 0； printf 123以下程序段的输出结果是（ ）。int a=1234；printf("%2d\n",a); %d前面的数字表示打印格式的位数。 如果输出的内容位数不足将会在左边补足空格 如果输出的内容位数超过%d前面的数字会将内容全部输出，%d前面的数字相当于无效 typedef and #define 代码：判断哪个不是指针 1234#define INT_PTR int*typedef int* int_ptr;INT_PTR a,b;int_ptr c,d; typedef 给已有类型声明一个别名，故c和d都是int_ptr类型也即都是int *类型； #define宏定义，在预编译时直接进行简单替换，即原式变为：int* a,b; 这相当于是int *a, int b; define 宏定义时，加括号 define 后，应该是一个整体； 12#define FUN(A,B) A+B FUN(2,3)*4 = 2+3*4;#define FUN(A,B) (A+B) FUN(2,3)*4 = (2+3)*4; 12int``* p1, p2; ``// p1是指向int的指针，p2是intint *p1, *p2; // p1和p2都是指向int的指针 #define #define只是在预处理阶段将a替换为相应数值，具体替换的值只与define在文件中的位置有关； #define 将值替换后给最近的函数使用； 基本概念 一个 C 语言程序是由：函数组成 不是程序组成 创建对象，是否需要初始化 需要初始化 静态对象：需要初始化； 局部变量：需要初始化； 不需要初始化 全局变量，不初始化时为0； 循环 123do &#123; ... &#125;while(); / 加；号 / 关于 return 语句 在主函数和其他函数中均可出现 可以在同一个函数中出现多次 1# if else; /* 一个函数中可以出现多次，一次运行只能有一个return进行返回 */ 字符常量 用单引号 关于“深拷贝” 会拷贝动态分配的成员对象 32 位 的long and int 一样，占4个字节； C语言中最简单的数据类型包括 1整型、实型、字符型 不能作为重载函数的调用的依据是： 基类型相同的两个指针变量之间，不能进行的运算是 数组 数组a[3] [ 4 ] 不正确引用 1a[3] [ 4 ] /* 0-(N-1)：访问不到a[3][4],超出界限 */ 数组定义时候： 列必须确定，行可以不确定 数组越界问题 1a[2] = &#123;'0', '1', '2'&#125;; /* 数组越界了 */ 数组打印 1printf("%d\n", s); /* %d 只打印首地址 */ 数组的赋值： 在数组定义的时候进行赋值； 在被调用函数中，不需要考虑形参数组的大小; 形参和实参 实参和与其对应的形参各占用独立的存储单元 形参在编译时是不会分配存储容间，在调用时才在栈里分配 输入输出语句 输入和输出并不是C++语言中的正式组成成分｡ C和C++本身都没有为输入和输出提供专门的语句结构｡ 输入输出不是由C++本身定义的,而是在编译系统提供的I/O库中定义的｡ 用C程序实现的算法可以没有输入但必须要有输出 函数 sizeof and strlen 12$ sizeof(); /* 结尾包含字符 '\0' */$ strlen(); /* 结尾不包含 */ sizeof（str）:str中间有 \0 时，算作一个字符； strlen（str）: 遇到 \0时，便停止计算大小 123456789101112131415161718192021222324void strarray()&#123; char x[] = "abcde"; char y[] = &#123;'a', 'b', 'c', 'd','e'&#125;; printf("sizeofx[] = %ld\n", sizeof(x)); /* 包含末尾的\0 */ printf("strlenx[] = %ld\n", strlen(x)); printf("sizeofy[] = %ld\n", sizeof(y)); /* 字符长度 */ printf("strleny[] = %ld\n", strlen(y)); /* 包含所有字符 */ char *p = x; printf("p = %ld\n", sizeof(p)); /* 指针类型占得字节数 */ printf("strlen = %ld\n", strlen("std\n007\1\\")); char a[] = "a\0b\054de"; /* 是一个8进制数 */ printf("strlen = %ld\n", sizeof(a));&#125;sizeofx[] = 6strlenx[] = 5sizeofy[] = 5strleny[] = 10p = 8strlen = 9strlen = 8 malloc malloc函数进行内存分配是在什么阶段: 执行阶段 #include 12#include &lt;&gt; /* 从标准库文件目录下搜索，对于标准库文件搜索效率快。*/#include "" /* 从用户工作目录下开始搜索，对于自定义文件搜索比较快，然后搜索整个磁盘。 */ 结构体 32位系统中，结构体中的对齐 12345678struct A &#123; int a; char b; short c; /* 4, 1, 2 byte 内存对齐：4，2，2*/&#125;;struct B&#123; char b; int a; short c; /* 1, 4, 2 byte */&#125;; 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。 Token 划分 自加运算符 ++ ++运算符的操作数必须是左值；a++; a++ 之后便是表达式，不是左值了，因此在使用 a++ ++ 就是错误 位运算 按位与、或、异或、取反 C++ 基类的公有成员是其私有派生类的（ 私有 ）成员 C++ 不能重载的是 12$ '.*' ; '::' /* 不能重载的是 */$ '*' ; operator delete /* 可以重载 */]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[red_and_black_tree]]></title>
    <url>%2F2019%2F05%2F27%2Fred-and-black-tree%2F</url>
    <content type="text"><![CDATA[red and black tree摊还分析 摊还时间界 长时期运行中的这种数据结构的行为，就像是每次操作花费O(log N)时间一样； 每次操作花费时间； 自顶向下伸展树 伸展树的三种变换形式： 单旋转：Y成为新的root；X成为Y的right_child; 一字型：最左边的Z依次上升到root；X下降到右边； 之字形：双旋转；Z成为=root；其他的左边的是leftchild;右边的是rightchild 自顶向下 自底部向上：是一棵AVL树 1) 单旋转； 2）双旋转；dafa 自顶向下的展开：生成三棵树 1）L 左子树；&lt; 中间的树；&lt; R右子树； 自顶向下的算法： 1）应用：简化之字形展开； 2）一步步展开，旋转后分别存储为三棵树； 3）进行整理合并； 红黑树 红黑树是具有着色性质的二叉查找树： 二叉查找树： 左子树的所有关键字 &lt; X-root &lt; 右子树的所有关键字 红黑树着色： 1）黑色节点：一个圈表示；红色节点：两个圈表示； 2）root：黑色； 3）一个节点是红色，那么其子节点必须是黑色； 4）从一个节点到一个NULL指针的每一条路径必须包含相同数目的黑色节点 新元素的插入情况 插入节点的parent 是黑色 —&gt; 直接插入就完成； 插入点的parent是红色，且parent 的兄弟是黑色：—&gt; 自底向上插入 插入点的parent是红色，且parent 的兄弟是红色：—&gt; 自顶向下插入 自底向上插入 插入的节点满足条件： 1）二叉树的性质：left &lt; X &lt; right; 2）红黑树的性质：颜色和黑节点路径； 新节点的插入： 1）新项作为树叶放到树种； 2）插入操作进行：颜色的改变和树的旋转 插入点的parent是红色：parent 的兄弟是黑色 自底向上插入：先插入，在平衡 a.形式：一字链和之字链； b.平衡条件：单旋转和双旋转； c.颜色的改变：根节点由黑转红； 自顶向下插入 插入点情况：插入点的parent是红色：parent 的兄弟是红色 先平衡再插入 a. 执行一次颜色翻转：图； b. 单旋转（两个连续的红色节点）； c. 使得插入点的parent是黑色； 先进行一系列的操作，将插入节点的parent变成黑色；直接插入节点就行。 自顶向下删除 自顶向下的插入： 1）先平衡，保证插入节点的父节点再插入的时候是黑色节点； 2）不影响红黑树的性质三 自顶向下的删除： 1）先平衡，保证删除的树叶在删除期间是红色的； 2）不影响红黑树的性质四]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>red_and_black_tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algorithm_design]]></title>
    <url>%2F2019%2F05%2F25%2Falgorithm-design%2F</url>
    <content type="text"><![CDATA[algorithm design 算法的实现转为算法的设计；递归和循环实现算法 算法 适用场合 排序和查找 二分查找，归并排序，快速排序 回溯法 二维数组上搜索路径，回溯法通过递归实现（当限定不能递归时，用栈模拟） 动态规划 求某个问题最优解，(1)该问题可以分为多个子问题；(2)子问题的最优解组合成该问题的最优解自上而下进行分析，(3)子问题存在重叠现象；通过循环的方式避免重复计算 贪婪算法 在动态规划思路之后，提示某一个特殊选择后，得到最优解 位运算 数字的二进制形式对0/1的操作，有与、或、异或、左移和右移 递归和循环 递归的实现：通过调用函数自身 每一次函数的调用，需要在内存栈中分配空间用以保存参数，返回地址和临时变量； 每次往栈中压入数据和读取数据都需要时间； 应用动态规划解决的问题：递归分析，循环实现 可以使用递归的思路分析问题； 从下而上通过循环实现代码； 递归引起的问题： 调用栈溢出，每个进程的栈容量优先。 应用一：面试题10：斐波那契数列，青蛙跳台阶应用二: 面试题60：n个骰子的点数的概率应用三: 面试题61：扑克牌的顺子判断排序和查找 查找排序算法 适用场合 二分查找算法 在排序数组中（部分排序）：查找一个数字或者某个数字出现的次数 哈希表二叉排序树 考察重点在数据结构，不是算法 快速排序 最后得到的就是两个已排序的数组，加一个枢纽元 二分查找法的实现 quick_sort算法的实现 应用一：面试题11：旋转数组的最小数字应用二: 归并排序 面试题51：数组中的逆序对二分查找应用一: 二分查找 – 面试题53（一）：数字在排序数组中出现的次数应用二: 二分查找 – 面试题53（二）：0到n-1中缺失的数字数应用三: 二分查找 – 面试题53（三）：数组中数值和下标相等的元素回溯算法 回溯算法的定义：蛮力法的升级版 它从解决问题的每一步的所有可能进行尝试，选择一个可行的方案，一步步的得到最终的约束条件 适用的题目： 路径的选择，或者是背包问题； 二维矩阵上路劲的查找问题 解题的方法： 回溯法属于递归的性质，通过栈进行实现； 每一步的选择，对下一步将产生影响；如果一直没有找到路径，就回溯到上一个节点，从新选择路劲尝试； 应用一 :面试题12：矩阵中的路径应用二: 面试题13：机器人的运动范围 动态规划贪婪算法 动态规划：需要O(n^2)的时间和O(n) 空间； 贪婪算法：需要O(1)的时间和空间 动态规划类求解 动态规划的三个特点： 求某个问题最优解：该问题可以分为多个子问题； 子问题的最优解组合成该问题的最优解 子问题存在重叠现象；通过循环的方式避免重复计算 自上而下进行分析问题，从下往上解决问题； 动态规划从下往上解决问题，中间数据怎么存储 中间数据通过一维 / 二维 数组 进行存储； 贪婪算法 贪婪算法特点 希望在动态规划中的，每一个局部都是最优的； 然后组合起来才是最优的解； gcc 编译时：需要链接数学库 12Greedy_maxProduct: Greedy_maxProduct.o $(CC) $^ -o $@ -lm // 在链接成目标文件时，加上动态链接库函数 -lm 动态规划应用一: 面试题14: 剪绳子 :给你一根长度为n绳子，请把绳子剪成m段动态规划应用二: 面试题47：礼物的最大价值. 题目：在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）动态规划应用三: 面试题48：最长不含重复字符的子字符串. 扩展: 将这个长的字符串打印出来?贪婪算法应用一：面试题14: 剪绳子 :给你一根长度为n绳子，请把绳子剪成m段 位运算概念 了解进制的概念： 几进制：在一系列递增数中，一位能表示的最大值 &lt; “几”进制 比如：时分秒的六十进制 位运算： 与，或，异或，左移和右移 按位进行 右移：针对符号位时 正数：符号位为0；右移n位时，补n个0； 负数：符号位为1；右移n位时，补n个1； 1n = n &gt;&gt; 1; // 不能只写 n &gt;&gt; 1 应用一： 面试题15: 计算一个整数转换为二进制后，1的个数应用二： 面试题56（一）：数组中只出现一次的两个数字.题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。应用三： 面试题56（一）：数组中只出现一次的两个数字. 题目：在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。分治算法 分治算法： 至少含有两次递归才算是分治算法 分治算法 最大子序列； 线性时间树遍历方法； 归并和快排； 非分治算法：只使用一次递归 dijkstra 算法 随机化算法 定义： 在算法期间，随机数至少有一次用于决策。 该算法的运行时间不仅依赖与特定的输入，还依赖于所发生的随机数 贪婪算法其余的知识点 最小化处理 平均完成时间最小化：先处理需要时间更短的作业； 最后完成时间最小化：进行大小搭配，组合 huffman 算法 用于文件压缩：字符是不同频率出现，文件压缩才是可能的； Huffman 算法： 1）将树组合成森林； 2）一棵树的权中等于他的树叶的频率之和； 3）选择权值最小的两棵树，进行merge； 4）两棵老树成为新树的左右儿子； 5）新树的权总是那些老树权值和； 集装箱处理问题 联机装箱：必须把每一件物品放入一个箱子后才处理下一件物品； 脱机处理：将所有输入数据全部读入后才进行处理 联机处理： 下项适合算法：检查箱子空余空间是否还能装下刚刚处理的物品，不能就创建新空间； 首次适合算法： 1）一次扫描箱子，需要O（N）； 2）把新的一项物品放入足够能放入的第一个箱子中； 3）只有放不下时才创建新空间 脱机处理 将所有物品信息全部排序后，在进行处理‘ 首次适合递减算法和最佳适合递减算法]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[graph]]></title>
    <url>%2F2019%2F05%2F24%2Fgraph%2F</url>
    <content type="text"><![CDATA[Graph AlogrithmDedine graph 图Graph = [ 顶点（vertex），边（edge） ] 1）每一条边：点对（v,w）属于V，或者弧（arc） 2）点对有序：图是有向; 3）无向图的边：还具有第三种成分，权（weight） 考虑有向图和无向图中的边的区别 1）（u, v）和（v, u）; 2) 在无向图中，他们是相同的边，不是圈； 3）再有向图中，他们是不同的边，是圈 连通图：每一个顶点到其他顶点都存在一条路径； 1）强连通图：有方向的； 2）弱连通图：没有方向； 3）完全图：每一对顶点间都存在一条边的图； 邻接矩阵：一个二维数组表示每一条边； 1）每条边（u, v）：A[u][v] = 1，相邻; 2）有v个顶点，空间需求则是O( V^2 ); 图的标准表示：邻接表，通过散列表进行完成； 1）将每个顶点进行内部编号：1 - V; 2) 将有相邻边的内部编号和顶点名字存入指针数组中； 3）具有相同顶点指向关系的顶点存在同一个指针数组中 3）最终要输出顶点名字而不是内部编号 拓扑结构 拓扑排序：是有向的无圈图的顶点组成； 1）有向边（v, w）：v要在w之前弄完； 2）邻接表：找出任意一个没有入边的顶点，存的是V顶点的出边； 出队前的入度表：某个顶点，被其他顶点指向；则入度加1； 1）指向：分为直接指向；间接指向（v1 –&gt; v4）有路径完成指向 2）入队：将所有入度为0的顶点放入一个初始为空的队列中； 4）出队：每出队一个元素，删除该顶点 最短路径算法 赋权路径长：权重值的和； 无全路径长：从u -&gt; v 的边数 负值圈：边的权重是一个负值； 1）负值圈的出现：最短路径就不确定； 2）在没有负值圈时，从s到s的最短路劲为0 无权最短路径 方法 1）某个顶点s作为输入参数，找出s到其他顶点的最短路径； 2）最短路径：边数和最小；找相邻的顶点，边为1 广度优先搜索： 1）按照顶点s到其他顶点的距离，进行分层处理； 2）每个顶点追踪三个信息： 3) 距离d： s到其他顶点的距离一开始为无穷，不可到达； d=0的点是选中的点； 4）p(v)：簿记变量 – 显示实际的路径； 5）know：对应顶点被处理后置为1； Dijkstra 算法 解决单源最短路径问题的方法； 边有权重； 有向图； 此时d 的更新：权重之和； 1）每个顶点否会被申明，也就是出队； 2）此时表中的d路径是否更新：d保留的是最短路径； 3）更新的顶点：是被申明顶点直接指向的点 网络流问题 s称为发点，t称为收点 1）除了s点和t点外，其他的顶点v ：总的进入流 = 总的输出流； 2）根据上面的点：更新图中的值 3）算法结束时的最大的流量：s 到 t 可以通过的最大流量 G: 图 G(f)：流图：算法任意阶段包含的流信息； G(r): 残余图，每条边还能再添加多少流 要以路径上最小的流进行调整： G（f）:保存的是此次各边上流的信息； G（r）: 用G - G(f) 后的流的信息； 1）更新残留图G(r)的信息，直到t由s出发是不能到达的，算法中止 最小生成树 最小生成树： 无向图中进行; 最小生成树存在：当且仅当G是连通的 最小生成树：构成的是树，不是图 1）无向的图； 2）包含所有节点； 3）顶点只要被包含为节点就算成功，只考虑更新每个节点的最小值， prim算法 计算最小生成树的方法 把每一个节点当成root，往上加； 每一步添加一条边和一个顶点到树上； kruskal 算法 连续按照边的权重，由小到大开始选边；并且当选的边不产生圈时，确定这条边； 算法处理的是一个森林； Union/Find 的merge方法进行树的合并 深度优先搜索的应用 深度优先搜索：先序遍历的推广； 访问到该点，标记该点被访问过，并且对尚未标记的所有领接顶点递归调用深度优先搜索； 使用邻接表，保证每一条边被访问一次； 背向图 实线：递归调用有效； 虚线（背向图）：顶点被访问过，无效 边（v, w）：如果w被访问过，那么Num(w)便是有值的，此时称为背向边 双连通性 任意顶点删除后，图还是连通的； 割点：该顶点删除后，图将不在连通； Num / Low Num():访问到该顶点时的编号； Low(): 背向值指向的顶点编号 欧拉回路 附加条件： 1）每条边只能走一次； 2）笔不能离开纸张； 3）还要回到起点，终点和起点在同一个位置； 欧拉回路： 1）当图是连通的，并且每个顶点的度（边的条数）是偶数才能存在； 2）边为偶数：入度+出度 解决这个问题： 1）找出有尚未访问的边的路径上的第一个节点p； 2) p作为root进行另外一次优先搜索，得到一个圈，每个点的度为偶数，将此时的回路拼接到原来的回路上； 3）循环到所有边都遍历位置（一个顶点会出多次，多条边） 欧拉回路实现： 1）增加数据结构：保留路径作为一个链表，便面重复扫面； 2）邻接表：有一个指针指向后一个元素]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Union_ADT]]></title>
    <url>%2F2019%2F05%2F24%2FUnion-ADT%2F</url>
    <content type="text"><![CDATA[Union ADT等价关系 等价关系：满足三个条件 1）R：表示的是两个元素之间的关系； 2）电器连通性：是一个等价关系 动态等价性问题 S 是一个等价类：将与元素a有关的元素都放在一个等价类中 Union/Find 算法：查找合并算法 1）若要确定等价关系a~b：搜索a和b是否都在同一个等价类中 2）Find运算：返回包含给定元素的集合（等价类）的名字； 3）添加关系：a,b不在同一个类中，使用并运算Union，合并为新的等价类； 4）find(a) = find(b),当且仅当a和b在同一个集合中 Union/Find算法FInd 算法1.Find：为了实现find的查找 1）我们用树表示成一个集合，集合是森林； 2）数组中只需要保存的信息便是父指针； 3）数组中保存的元素为 P(i)：P[i] 表示元素i的父亲 Union 算法一：让第二棵树成为第一棵树的子树。（没有偏向） 算法二–按大小求并：总让较小的树成为较大的树的子树。 1）任何节点的深度不会超过O(log N) 算法三：按高度合并，时的深度前的书成为深的树的子树； 1）当两棵树的深度一样时，合并后深度才会增加]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>Union</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sort_ways]]></title>
    <url>%2F2019%2F05%2F22%2FSort-ways%2F</url>
    <content type="text"><![CDATA[Sort ways 数据结构：考虑数据的存储方式，数据的快速查找和取出 排序前提 假设： 1）数组中元素类型为整数； 2）内部排序：整个排序工作在主存中完成 3）外部排序：在磁盘上完成排序 算法： 1）每个算法都将接受一个含有元素的数组和一个包含元素个数的整数。 内部排序 代码链接 冒泡排序12345678910111213/* 冒泡排序 */void BubbleSort(int *array, int length)&#123; for(int i = 0; i &lt; length-1 ; i++)&#123; for(int j = i+1; j &lt;length ; j++)&#123; if( array[i] &gt; array[j] )&#123; int tmp = array[i]; array[i] = array[j]; array[j] = tmp; &#125; &#125; &#125;&#125; 插入排序 算法： 每次取后一个元素，和前面已排好序的数组进行比较； 1）每次都是取后一个元素p，和前面的数组进行比较，如果比p大，那么就往后移一位，替换覆盖； 2）前面的数组都是排好序的； 3）以前的想法：每一个元素：和所有的元素比较，先找出最小值 插入排序的运行时间 反序输入：O(N^2) 正序输入：O(N) – 元素不需要排序，将元素输入到数组需要花时间 插入函数的接口 123456789101112/* insert_sort */void InsertSort(int *array, int length)&#123; // 从第二个元素才需要插入排序 for ( int i = 1; i &lt; length; i++)&#123; int tmp = array[i]; // 设置哨兵元素 int j =i; // 前面已经排好序的( i - 1 )个元素 for(; j &gt; 0 &amp;&amp; array[j-1] &gt; tmp; j--) array[ j ] = array[j-1]; // 前面的大于 tmp, 则移动覆盖 array[ j ] = tmp; // 最后一个位置处理 &#125;&#125; 逆序对的性质 逆序性质 当 i &lt; j, a[ i ] &gt; a[ j ] ：这边是一个逆序对（ a[ i ] ， a[ j ] ） I = 是数组中的逆序对数； 排序好的数组是没有逆序的，所以插入排序运行时间 O(I + N); 交换相邻的两个元素，相当于交换逆序对。 插入排序 互异数：假设没有重复的数； 在插入排序的时候，每次比较交换删除的不止一个逆序对 希尔排序 算法： 比较相距一定间隔的元素来工作，各趟比较所用的距离h(k)，随算法的进行而减小，直到只比较相邻元素的最后一趟排序为止 shell缩小增量序列 1）用 a[i] 数组和 a[ i + h(k) ]进行比较； 2）初始值：h(k) = N/2 ; 3）递减：h(k) = h(k) / 2 希尔比较的方式 增量的选择 使用 shell 的希尔增量最坏情况 O(N^2)，类似插入排序 使用 hibbard 的希尔增量最坏情况 O(N ^ (3/2)) sedgewick 增量排序：其他的几种增量形式，降低运行时间； 希尔排序的接口 堆排序 算法： 通过优先队列方式：进行delete_min，得到排序数组； 优先队列花费时间O(N * log N)，只是需要附加数组 delete_min 实现 每次将最后的单元的值放到堆顶, 位置用来存放刚刚删除的元素; 得到从小到大的排序数组 1）delete_min 删除最后的元素后，整个堆以递减的顺序得到数组–max 堆； 2）现实中构建的堆：和二叉堆的性质相反之处 – （任一节点的关键字大于其儿子节点的关键字）； 3）delete_min：得到从小到大的排序数组 和二叉堆不同的是：0位置包含元素 堆排序的复杂度分析 本质: 利用完全二叉树的深度特性, 构建堆结构比较复杂; 时间消耗: 初始建立堆和在重建堆时的反复筛选上; 两种类型的堆: 最大堆和最小堆; 归并排序 算法 本质: 是一颗倒着的完全二叉树, 涉及到完全二叉树的结构, 效率一般都不低; 方法: 合并两个已经排序的表，将两个表插入到第三个表中完成排序 N 为元素的总数： 1）将N分为前 / 后半部分数据各自递归排序； 2）将排好序的两部分进行合并，两个指针分别指向A,B；每次比较后插入一个元素；直到最后一次比较，插入两个数据 3）得到一个排序数组 归并排序 运行时间：O(N * log N) 归并排序：递归排序 快速排序 快速排序 当枢纽元位于中间，平均时间 = O(N log N); 当枢纽元选择为最小元素，最坏的情况 = O(N^2); 类似于归并排序，快速排序也是归并排序； 快排算法 假设：元素互异 在数组中选择枢纽元 v； 将数组分割为三部分，a [left] = { x &lt; v }；a[center] = {v} ; a[right] = { x &gt; v }； 三部分各自排序后，组合在一起 枢纽元选择： 三数中值分割法 ：选择中间 v = [ ( left + right) / 2 ] 分割策略： 1）将枢纽元与最后元素交换，使得枢纽元离开要被分割的数据段； 2）i从第一个元素开始；j从倒数第二个元素开始；相对于枢纽元，i和j的元素才交换 3）将所有小元素移到左边，大元素移到右边； 4）当i 和j交错时，停止移动，此时 i指向一个大元素，j指向一个小元素； 5）将枢纽元和i的元素交换 6）分割策略注意：当i和j遇到和枢纽p相同时，i和j停止移动 排序的下界 – 决策树 决策树：用于证明下届的抽象概念； 决策树：一颗二叉树； 决策树表示： 只是用比较进行排序的算法，都可以通过决策树表示； 决策树：只有输入数据非常少的情况下决策树才是可行的。 画出 a, b, c三个元素的比较情况 每次是两个元素的比较，进行分支 决策树的性质 1）深度为k的决策树（二叉树），最多有(2^k)个树叶； 2）反之，具有L片树叶的深度至少是log L 比较次数 = 决策树的深度； 只使用元素间比较的任何排序算法，需要进行 桶式排序 桶式排序提供了一个前提： 输入数据都需要小于一个M的整数 外部排序 外部排序的限制 内部排序算法：将数据装入内存，这样数据的访问便可以不按顺序进行； 外部排序：数据的输入输出是在物理设备上，只能按照顺序访问； 外部排序的模型： 外部排序比内部排序对设备依赖性更高； 建立的模型：在磁带上进行； 访问某个元素时，需要把磁带转动到正确位置 算法： 使用归并排序的merge例程； 四个磁带空间：不停地将两个磁带中的数据（顺串）作为输入，另外两个磁带空间作为输出；直到所有的顺串合并为一个长的顺串； 顺串：将每组排过序的记录叫做顺串； merge算法进过的次数 这个算法是两路merge：两个输入，两个输出 算法需要 [ log( N/M )]趟工作，每次合并2^n个数据； 1）N：总得自己数； 2）M：内存的大小； 3）N/M：数据被分成多少个顺串； 多路合并merge 两路合并：只需要比较两个元素的最小值； k路合并： 每次需要比较k个元素的最小值； 1）优先队列的方法，delete_min 2) 算法需要 [ log(k) [ N/M ] ]趟工作，每次以2^n进行合并； 3）十盘磁带：k = 5；一半作为输入，一半作为输出； k路合并，需要2k盘磁带 多相合并 k 路合并，需要（k+1）盘磁带 为了减小磁带数量 顺串最初的分配有很大的关系，决定后续多少趟的进行； 顺串不均分在k个磁带上，第（k+1）个磁带用于输出数据 替换选择 目的：考虑顺串的构造 替换选择 1）首先读入M个记录放在队列上，然后delete_min将最小值输出到磁带上； 2）读入下一个记录是和 最小值比较，大于–放入优先对列；(二叉堆的构建) 3）优先队列少一个元素，将小于每次delete_min的元素，存入优先队列的死区，直到顺串完成构建； 4）这个元素用于下一个顺串；（堆排序的做法：最小值取出后放在最后一个位置） 5）持续上述做法，直到优先队列大小为0，完成顺串构建 总结 内部排序算法的选择： 插入排序；希尔排序；快速排序； 通过数据的输入量的大小决定 外部排序算法： 合并 merge 是中心思想]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[priority_queue]]></title>
    <url>%2F2019%2F05%2F19%2Fpriority-queue%2F</url>
    <content type="text"><![CDATA[priority queueIntroduction 优先队列： 具有队列的性质，进行insert and delete; 此时的delete 要删除最小值（某些元素具有优先级） 如何让队列实现优先级 优先队列的一些实现方式 链表实现优先队列： 1）插入是无序：insert – O(1); delete – O(N)，进行遍历 2）插入是有序：insert – O(N); delete – O（1） 二叉树实现 1）平均时间 O(log N); 2) 删除最小值：的时间不是平均时间 上面两种方式的运行时间太长 二叉堆 当堆（heap）不加任何修饰词使用时，就是值得该数据结构 二叉堆的性质 堆：是完全二叉树 性质 任意节点的关键字小于所有后裔的关键字 1）底层：元素依次从左到右填入； 2）高为h 的完全二叉树节点数：2^h — (2^(h+1) -1) 3) 完全二叉树的高是logN 4) 完全二叉树：用数组，不用指针 5) 0位置的数组不存储数据 堆序性质 任意节点的关键字小于它所有后裔的关键字； 堆的操作 insert: 1）完全二叉树的插入：从左边依次插入，所以不用考虑顺序； 2）上滤策略：插入 i 节点后，破坏了堆序性质：将其父节点的关键字交换到 i位置；原来i节点的关键字放到父节点 （i/2）的位置； 3）插入的关键字最小的话，i将是1；我们在数组的0位置放置一条哑信息（放一个很小的值 = 小于等于堆中的任意值） 4）这样插入和移动的时间高达 O(logN) delete_min 1）堆序性质：最小值应该是根节点的值； 2）下滤策略： + 删除根节点的值后，一步步的从根节点的儿子节点选出相对较小的关键字，放入root中； 将最后的元素，上升到被提到根节点的位置; 平衡树，满足堆序性质 Other decreaseKey 降低位置P处关键字的值 破坏序的平衡：采用上滤策略 increaseKey 增加位置P处关键字的值 破坏序的平衡：采用下滤策略 构建堆： 将N个节点以任意顺序放入树中，保持结构特性； 在调整成一棵有堆序的树 如果对一棵乱序的树，进行堆序化 最大的虚线条数：计算堆中所有节点的高度和，等于N的最大上限 O(N) 1）任意节点的高度 = 它到叶子节点的最大路径值； 2）理想二叉树：节点数 = 2 ^ (height +1) – 1 3）理想二叉树：节点高度和 = 2 ^ (height +1) – (height +1) 我们此时算的最大虚线条数：要调整的次数 通过理想二叉树 ，计算出最大上限 堆的应用 问题描述对于N个元素，读出第k个最小值： 1）N个元素得有序； 2）find 第k个最小值； algorithm 1A 1) double for cycle； 2）排序时间：O(N^2) algorithm 2A 1) 先取k个元素组成一个排序数组array_order； 2）每次去一个元素和array_order进行比较插入； 3)中位数的时间界限 = ：O(N^2) algorithm 6A – 堆排序（不用指针） 1) 构造堆最坏情况：O(N); 2) 每次的delete_min：O(log N); 3) k 次删除，总时间：O(N + k logN) 4) K = N/2; 运行时间：O(N * log N) 找出中位数的时间界限 = (N logN) d-堆 d-堆：是二叉堆，只是所有节点都有d个儿子 左式堆左式堆性质 合并merge：需要把一个数组拷贝到另外一个数组中，需要花费O(N)时间； 合并操作需要的数据结构：需要使用指针 左式堆：需要用到指针 左式堆性质 1）左式堆：也是二叉树，左式堆不是理想平衡的。 2）节点X的零路径长Npl：从X到一个没有两个儿子的节点的最短路径长。 3）任意节点X，左儿子的Npl &gt;= 右儿子的Npl，不满足便需要调节 1)树偏向左增加深度，存在有节点形成的长路径构成的树，更有益于合并操作。 2）节点个数：右路劲上有r节点，左式树至少有（2^r - 1）个 左式堆的操作 左式堆：实现堆之间的合并 1）左式堆和二叉堆的insert不兼容的； 2）二叉堆没有指针，插入后没有返回值 斜堆 斜堆：具有堆序的二叉树，只是不存在树的结构限制； 斜堆 merge： 不需要附接空间保存路劲长度 也不需要测试确定何时交换儿子 没有Npl零路径的限制 二项队列定义 二项队列： 不是一棵堆序树，而是堆序树的集合，称为森林 二项队列的实现 k 是二项队列的高度，包含的堆序树集合 = { B(0), B(1),……B(k-1) } 性质 : 每一个高度至多存在一颗二项树，超过就需要merge 实现方式：B(k)高度的二项树构成：将B(k-1)的树全部附接到B(k-1)的根节点； 二项队列的操作 insert 插入一个节点后 没有打破 性质，则保留为B(0)的堆序树； 打破了性质，进行合并 delete_min 按照堆序树：进行递归删除 Difference priority queue 性质 操作 二叉堆 1) 完全二叉树的性质：2) child 依次从左到右填满3) 通过数组存储，存储为树的形式； 1) insert: 进行堆序的平衡2）delete_min: 删除根节点，下滤策略平衡 d-堆 本质是二叉堆，只是所有节点都由d个儿子 同上 左式堆 1)用于堆的合并merge；2）任意节点X，左儿子的Npl &gt;= 右儿子的Npl3）需要指针进行 1）merge：根据性质—-确定何时交换儿子 斜堆 1）用于堆的合并merge；2）去除左式堆 Npl 的限制 二项队列 1）用于堆树的merge，森林；2）任意高度至多包含一棵二项树； 1）merge：B(k)树的形成— 将大的B(k-1)的树，依附在小的B(k-1)的root上]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hash_ADT]]></title>
    <url>%2F2019%2F05%2F19%2Fhash-ADT%2F</url>
    <content type="text"><![CDATA[Hash ADTIntroduction 散列表 以常数平均时间执行插入、删除、和查找的技术； 散列表的ADT 包含有关键字的具有固定大小的数组 散列 将关键字，通过散列函数映射到，0-tablesize 的表中存储 1）散列函数的选择； 2）分配到同一值的冲突解决； 3) 关键字：字符类型的不同，决定了散列函数 散列函数 散列函数的选择 key mod tablesize ：余数是几，放在相应的表中存储； tablesize：取素数，减少（key mod tablesize）为同一个值的概率 所以会造成冲突 分离链接法—解决冲突 构造链表数组：解决冲突 1) 分配一个存储空间：存储 0 - tablesize； 2） 每一个 tablisize:分配一个数组，存储相同的值的关键字； 3) 每个数组：分配一个头指针 header */ 保证素数：减少占同一个值的情况 表头：如果链表不涉及删除，那么可以去掉表头 开放定址法 分离链接法 每个新单元插入：需要指针；malloc分配存储单元 开放定址法 创建一个大的数组，对数据进行散列存储； 冲突：按照函数F 进行探测，查找空单元 线性探测法 探测函数： F(i) = i; // 一步步的往前探测，直到出现空单元 探测因子 介于0-1之间； 计算插入一个函数时：成功探测和不成功探测，需要的次数 出现问题： 一次聚集：占据的单元会形成一块区域 平均探测法 探测函数： F(i) = i^2 ; // 消除一次聚集的问题 tablesize 为素数 一旦表的填充过半，如果tablesize是素数，中能找到一个空的单元 问题： 消除一次聚集，产生二次聚集 双散列 探测函数： F(I) = i * hash(x) hash(x) = R - X mod R 再散列 当分配的 0-tablesize 空间产生冲突时： 选择创建一个 2 * tablesize 空间； 将原先的关键字，迁移到新的空间 散列表 二叉树 find 不能迅速找到一定范围内的所有项 快速找到 other 不需要存储有序的信息， 存储有序的信息 对图论是有效的；在线拼写检验程序]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tree]]></title>
    <url>%2F2019%2F05%2F17%2Ftree%2F</url>
    <content type="text"><![CDATA[Tree 文件系统：三种访问结构；前中后序访问 树的操作基本时间：O(logN) 通过递归的方式实现树 树的实现树的元素 – 节点 树中节点的关系 1）n(1) –&gt; n(2)：n(1) 是n(2)的祖先； 2）n(1) != n(2); n(1) 是n(2)的真祖先； 3）parent 、child、sibling、leaf、grandparents、grandchild 节点数的长度length：从1递增到n的 1)节点深度depth：从root到n(i)的唯一路径长；root(depth) = 0 2)节点的高度height：从n(i)到树叶leaf的最长路径; leaf(height) = 0 3)一棵树的深度 = 高度 树的一种表达方式 12345struct treenode&#123; ElementType element; struct treenode firstchild; //第一个儿子节点 struct treenode nextsibling; //下一个兄弟节点&#125;; 树的遍历 遍历的顺序 针对于父节点先处理还是后处理： 1）先序遍历：先父节点，在左儿子节点，最后右儿子。 打印出目录结构 2）后序遍历：先左儿子节点，然后右儿子，在父节点。 打印出每个文件占的块block大小（文件最小单位：块） 二叉树 二叉树：是一棵树，每个节点的child，不能多于两个。 平均深度的计算： 1）平均二叉树：depth = O( sqrt(N) ) 2）二叉查找树：depth = O(logN) 二叉树实现 二叉树的图形表示：圆圈加直线 二叉树的每一次插入： 调用malloc创建一个节点； 调用free删除后被释放； Null 指针： 每一棵N节点的二叉树，需要（N+1）个NULL指针 每一个叶子节点：包含两个NULL指针 二叉树应用–表达式树 编译器的设计领域，计算表达式的应用： 中序遍历策略：中缀表达式； 后序遍历策略：后缀表达式； 前序遍历策略：前缀表达式； 树定义：表达式 操作数：叶子节点 运算符：父节点 构造表达式树： 把后缀表达式 转化为中缀表达式，每一部分加上括号 方法相反：操作数压栈，读操作数时弹出操作数； a. 用指针指向：每个操作数，以及每次运算得到的大操作数 操作数的指针压栈，顺序是左child，右child； 读到操作符时弹出操作数：每次弹出两个操作数； 操作符做为父节点； 先弹出的做为右child；后弹出的为左child 将每次操作后得到的大操作数指针：压入栈中； 最后有一个指针指向这个树：将指针压入栈中 栈中只有一个指针 查找树 一 ： 二叉查找树ADT 二叉查找树： 1）每个节点：指定一个关键字值； 2）关键字互异，没有重复值； 3) 关键字：左子树的 &lt; 小于X节点 &lt; 右子树的 二叉树的创建 空间创建的时候：以节点数N来进行创建的。 平均深度是O(logN)，不用担心栈空间用尽 二叉树的删除： 当被删除节点：包含两个child节点时； 用该节点右子树的最小数据代替该节点的数据，并递归的删除那个节点； 懒惰删除： 当元素x的出现频率&gt;1时，当删除x一次，只是频率减一，树不发生变化 AVL 树：是带有平衡条件的二叉查找树 AVL树的平衡条件 平衡条件1：每个节点的左右子树具有相同高度 平衡条件2（最终）：一棵AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树 AVL 特性破坏：插入新的节点后，破坏了原来的AVL树特性 插入新的节点，破坏了AVL的深度，插入的节点会变大，导致不在同一层 旋转：重新平衡插入后树的深度 新的节点插入树的方式 四中插入方式： 单旋转 元素插入是：左左插入和右右插入 双旋转： 元素插入是：左右插入和右左插入 旋转 单旋转发生的操作： 插入节点n的：父节点p往上升一级，n的祖父节点g往下降一级； p的另外一个孩子，高度不变，换到相反的一边 形成新的AVL树； 插入节点n和父节点p，祖父节点g 进行比较： 1）n &lt; p &lt; g : 破坏AVL平衡的话，单旋转便能达到新的平衡； 2）p &lt; n &lt; g : 破坏AVL平衡的话，双旋转才行； 3）原先节点p 的另外一个孩子，调整到另外一边 4）插入多个数据的时候：单双旋转都需要进行； 5）旋转除了保证AVL高度平衡外；还需要满足二叉树关键字大小的特性 双旋转发生的操作 插入节点n的：父节点p往上升二级，到达n的祖祖父节点gg 的位置，往下降一级； p节点的其他孩子：在左边child的就分配到左边（做另外节点的右child）； 伸展树 伸展树的思想： 当一个节点被访问后，节点就要经过一系列AVL树的旋转到达根节点。 不需要考虑存储的花费 一棵伸展树每次操作的摊还代价是：O(log N) 进行M次操作的时间就是 O(M logN ) 展开： 类似于前面介绍的旋转的想法，旋转的实施上有了选择 情形一：之字形 zig-zag AVL那样的双旋转 情形二：一字形 zig-zig 查找树二：B-树 阶为M的B-树具备下列的结构 非root 和 非叶子节点：包含的儿子数 （M/2 – M） 所有节点的高度是一样的； 所有的关键字包含在叶子节点上； 内部节点：只包含判断信息； 内部节点： 以圆圈作为边框， 判断信息形式：( A : B ：C …) 具有的儿子数目：( child &lt; A ) and ( A &lt; child &lt; B ) and ( B &lt; child &lt; C ) … 判断信息的形式：( A: - ) 儿子数目：两个儿子，( child &lt; A ) and ( A &lt; child ) 3 阶 B-树 : 2-3 B树 非root 和 非叶子节点：包含的儿子数 （1 – 3） M=3阶 B树 插入新的关键字 增加内部节点：其儿子数目在 （M/2 – M）之间 同一层调整不成功的话：增加树的深度（保证叶子节点在同一深度） Difference tree 作用 时间复杂度 表达式树 分析树–编译器中分析树不是二叉树：表达式树的扩充 查找树一： – 二叉查找树 递归实现查找 O(logN) AVL树– 带有平衡条件的二叉查找树 要求每个节点的左右子树：height 差 &lt; 1插入关键字后：进行新的平衡–通过旋转 O(logN) 伸展树–不带平衡条件的二叉查找树 节点的深度：不做限制节点就要经过一系列AVL树的旋转到达根节点。 O(M logN) 查找树二：B-树 平衡M-路树，很好的匹配磁盘平衡的条件：内部节点的儿子数 (M/2 – M)； 平衡树方案 AVL 和 B-树 树的实现基础知识 树的几种特例 二叉搜索树：左边节点值 &lt; root &lt; 右边节点的值 二叉堆：任意节点的关键字小于它所有后裔的关键字； 完全二叉树的插入：从左边依次插入，所以不用考虑顺序； 红黑树：红黑树是具有着色性质的二叉查找树； 树实现的两种方法：递归和循环； 由于递归在尾部的算法出现(尾部递归)，所以使用迭代更加有效. 迭代：递归是不停的调用自身，迭代是通过叠加旧值产生新值 树的遍历： 前序，中序，后序，层次遍历 二叉搜索树的知识 二叉树中删除节点 代码中没有给出，实现太过复杂 情况1：删除没有孩子的节点； 不存在重新建立连接的问题 情况2：删除只有一个孩子的节点； 把这个节点的：双亲和孩子连接就行，仍然保持二叉树的特性； 情况3：删除有两个孩子的节点； 不删除这个节点，删除其左子树中值最大的那个节点 二叉搜索树的插入： 默认没有重复的节点 数组实现二叉搜索树： 最重要的条件：数组元素的下标，应该和树中节点的位置对应 对应关系：树的深度为 – depth，树最多能存储 2^(depth + 1) - 1 个节点 数组的空间大小至少是 2^(depth + 1) - 1 数组下标 数组下标：从0开始，所以我们假定0位置不存节点，从位置1开始存储； 节点N的双亲节点 N/2；左孩子 2N；右孩子2N+1; 序列化和反序列化二叉树 序列化： 二叉树遍历为前序遍历序列，中序遍历序列； 反序列化： 由前序和中序 序列：反序列化二叉树； 应用：面试题37 前序和中序 的反序列化 – 缺点 二叉树不能存在重复节点； 需要将两个序列都读入后才能进行反序列化 序列化规则：进行序列化和反序列化 序列化：前序遍历后输出一个规则的字符串 1"[1,2,3,null,null,4,5]" 反序列化：只根据前序遍历得到的序列构建二叉树； 二叉树 (用的同一个接口) 静态数组实现二叉搜索树，能实现节点的插入，搜索，前序遍历 链式构建二叉搜索树,实现节点的插入，递归遍历 这是C和指针上面的内容；实现节点插入，构建二叉搜索树 应用二相当于数组的实现； 应用三相当于链表的实现 面试题 7 ：根据前序遍历和中序遍历，构建一颗二叉树 面试题 8：二叉树中序遍历的下一个节点(节点有指向父结点的指针) 对称树判断应用一: 面试题26：树的子结构 题目：输入两棵二叉树A和B，判断B是不是A的子结构 没有说明是二叉搜索树，因此是普通树，存在重复节点； 树的值类型是double，判断相等的时候； 1-0.0000001 &lt; (num1 - num2) &lt; 0.0000001 应用二：面试题27：二叉树的镜像 。题目： 请完成一个函数，输入一个二叉树，该函数输出它的镜像 解题思路： a.镜像的概念：从根节点开始，根节点含有左 or 右子树；交换左右子树； b.判断条件：root-&gt;pLeft != NULL || root-&gt;pRight != NULL; 应用三：面试题28：对称的二叉树。题目请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的 如果是对称的树，树中的节点就存在重复，该树就不是二叉搜索树 解题思路： 123456789101. 思路一： a. 利用以前的代码：先将树A进行镜像，得到树B; mirror_recursively_binatyTree.c b. 然后判断 树A 和树 B 的结构是否一样 Substructure_inTree.c c. 也可以通过前序遍历得到两棵树的数组，比较数组是否相同； 2. 思路二： a. 不用直接得到镜像的树B，假定一种遍历方式：先遍历root，然后遍历右子树，最后遍历左子书； b. 在遍历的时候，同时判断和 A树的关系 c. 特殊情况 Aroot 树为空 ，镜像树对应相等 树中某一些节点为NULL，这时候镜像树是不对称的; 树和队列 将两种ADT数据抽象类型融合在一起； 应用一：面试题32（一）：不分行从上往下打印二叉树。 层级遍历二叉树 遇到的问题 入队的节点是树的节点：这个可以通过改变Queue接口中的QUEUE_TYPE, 修改成BinaryTreeNode * 这样解决； 但是入队后，队列执行一次后就判断为空: 我一开始写的queue.c有问题，queue-&gt;rear没有处理好； 题目扩展 广度优先遍历，或者是有向图，还是一棵树，都需要用到队列； 应用二：面试题32（二）：分行从上到下打印二叉树。 每层打印之后换行 解题思路： 和面试题32（一）是一样的思路； 在打印换行的时候，需要知道每一层有多少个节点，需要两个变量进行表示； 树和栈应用一：面试题32（三）：之字形打印二叉树 之字形打印的思路：通过画图能看出来 通过栈实现：两个栈结构进行打印 保存节点的顺序 打印奇数层：左子节点 –&gt; 右子节点 打印偶数层：右子节点 –&gt; 左子节点 之字型打印：默认要分行 把一个栈打印完了之后就可以分行，不用去记录每一层多少个 应用二：面试题34：二叉树中和为某一值的路径. 题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。 解题思路 ​ a. 路径：起始于根节点，结束于叶子节点； ​ b. 前序遍历：需要将路径中的节点进行入栈，作为路径的保存。 ​ c. 节点遍历后，需要回溯到上一个节点； 注意的是：打印条件–&gt; 1if( currentSum == expectedSum &amp;&amp; is_leaf(pRoot) ) 压入栈后的节点：如何顺序打印路径； 方法：通过双栈模拟队列，实现栈的打印 二叉树后遍历的判断应用一： 面试题33：二叉搜索树的后序遍历序列。输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果1.解题思路： ​ a.根据后序遍历中，root在最后一个，将序列分为两部分； ​ b.左半部分 &lt; root &lt; 右半部分 (当左半部分出现大于 root， 将后面的所有节点归于右半部分) ​ c.依次判断每一部分时候满足； （出现错误：右半部分出现了小于root的节点序列） 树和链表应用一：面试题36：二叉搜索树与双向链表.输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表 不能创建新的任何节点：意味着我们在遍历的时候，就需要对每一个节点进行转换（节点需要动态分配，指针初始化一个地址） 转换为的转换为的链表是排序：选择中序遍历 树的深度应用一: 面试题55（一）：二叉树的深度应用二: 面试题55（二）：平衡二叉树]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Abstract Data Type]]></title>
    <url>%2F2019%2F05%2F15%2Ftable-stack-queue%2F</url>
    <content type="text"><![CDATA[Abstract Data Type 数据结构与算法教程，数据结构C语言版教程 理解数据结构的三种类型：看代码实现的细微差别 函数设计，我就只给一个接口，外部看不到设计，保留头指针与否，取决于自己设计的习惯 内存分配 所有的ADT都需要确定，如何获取内存存储值； 静态数组：结构长度固定 动态分配的数组结构：重新构建一个数组，复制原先数组到新数组，并删除原先数组 动态分配：考虑创建，以及销毁 为了避免内存泄露 动态分配的链式结构：每个元素单独分配内存空间 Link_list 数组存储数据 插入和删除，时间成本很昂贵 简单数组一般不用来实现表这种结构 链表节点的插入和删除 Stack 堆栈的接口： push : 新值压入堆栈顶部； pop：只把顶部元素移出堆栈，不返回值 top：返回顶部元素，不进行元素的移除 实现堆栈： push：存储于数组中连续的位置，因此需要考虑empty and full 堆栈的实现方式： 动态分配数组实现 动态分配链表实现 静态数组实现– 我修改了头文件，先不使用 栈的应用应用一：面试题30: 包含min函数的栈:题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数1. 有几个难点： + 和链表一样，一开始没有code栈的操作，导致这道题目没有思路； + 栈和队列的数据结构：将会用于树的操作 应用二：面试题31：栈的压入、弹出序列. 题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序Queuequeue – array 静态数组实现循环队列麻烦之处： ​ a. 判断元素存储在队列循环的位置：(rear = (rear+1) % QUEUE_SIZE) ​ b. 判断何时为空，何时为满 ​ 数组中有一个位置空着不用，front出队后比rear大1； ​ (rear+1) % QUEUE_SIZE == front 队列为空 ​ (rear+2) % QUEUE_SIZE == front 队列为满 ​ c. a % b : if(a&lt;b),那么输出的直接是元素a 队列是否为空的方式 定义一个标志位 size，判断是否为空，或者满了 再循环数组中，空出一个位置不用 123456 数组中有一个位置空着不用； (rear+1) % QUEUE_SIZE == front 队列为空 (rear+2) % QUEUE_SIZE == front 队列为满 数组的初始化rear = 0; front = 1; // 空出下标为0的位置 queue 的实现 静态数组实现 , 现在还没有用 动态分配数组实现 链表实现 queue 的应用–&gt; 用于树的操作Tree 关于树的构建和遍历]]></content>
      <categories>
        <category>data_struct_algorithm</category>
      </categories>
      <tags>
        <tag>ADT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket]]></title>
    <url>%2F2019%2F05%2F08%2Fsocket%2F</url>
    <content type="text"><![CDATA[Socket socket：IP地址 + TCP/UDP 端口号 —– 唯一标识网络通讯中的一个进程 socket pair ：建立连接的两个进程各自有一个socket来标识，两个socket连接 socket API ：TCP/IP协议设计的应用层编程接口。 unix 网络编程 介绍TCP协议的函数接口 最后简要介绍UDP协议和UNIX Domain Socket （套接字）的函数接口。 Introduction网络字节序 多字节数据 多字节数据：看成一个整体，也就是数据流； 数据流：在内存、磁盘文件存储的时候都是存在顺序的，顺序分为大端和小端； 网络数据流的地址：先发出的数据是低地址，后发出的数据是高地址。 TCP/IP协议网络数据流 应采用大端字节序，即低地址 高字节。 低地址：数据在内存中的存储地址是由低到高的 高字节：字节在进制数表示时的位置 主机和网络字节序 考虑发送和接收数据方：大端、小端字节序—–需要统一 库函数 网络字节序和主机字节序的转换。 12$ uint32_t htonl(uint32_t hostlong);// h表示host,n表示network,to表示转换方向；l表示32位长整数,s表示16位短整数。 如果主机是小端字节序,这些函数将参数做相应的大小端转换然后返回, 如果主机是大端字节序,这些函数不做转换,将参数原封不动地返回。 socket地址的数据类型 socket API 是一层抽象的网络编程接口，适用于各种底层网络协议：IPv4、IPv6，UNIX Domain Socket。 然而,各种网络协议的地址格式并不相同 socket 地址结构体 1234$ #include &lt;sys/socket.h &gt; //介绍程序中用到的socket API函数$ #include &lt;netinet/in.h&gt; // IPv4和IPv6的地址格式定义$ sockaddr_in 结构体 // 表示IPV4的地址，,包括16位端口号和32位IP地址$ sockaddr_in6 结构体 // 表示IPv6地址包括16位端口号、128位IP地址 各种socket地址结构体的开头都是相同的； 前16位表示整个结构体的长度； 后16位表示地址类型 IPv4 – AF_INET、IPv6 – AF_INET6；Unix Domain Socket – AF_UNIX socket API可以接受各种类型的sockaddr结构体指针做参数 参数都用struct sockaddr *类型强制转换一下 bind、accept、connect等函数 IPV4 的socket网络编程 sockaddr_in中的成员struct in_addr sin_addr表示32位的IP地址。 我们通常用点分十进制的字符串表示IP地址 字符串(10进制) 转 in_addr (十六进制)的函数: 其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr,还可以转换IPv6的in6_addr 函数的接口是void *addrptr。 基于TCP协议的网络程序 client to server 函数操作过程中：没有数据到达时，进行阻塞等待 关闭连接 调用close()：任何一方调用close()后,连接的两个传输方向都关闭,不能再发送数据了。 调用shutdown()：如果一方调用shutdown()则连接处于半关闭状态,仍可接收对方发来的数据。 学习socket API时要注意应用程序和TCP协议层是如何交互的: 调用connect()会发出SYN段 如read()返回0就表明收到了FIN段 TCP 网络程序 socket / server.c server 完成server的全过程 socket()函数 socket()打开一个网络通讯端口，成功返回的文件描述符 网络通讯端口：就像是一个文件一样，有了文件描述符，便能对一个文件进行读写操作 bind()函数 服务器程序：需要调用bind绑定一个固定的网络地址和端口号，为了方便客户端的连接 内核分配的话：每次都会发生改变 12int bind(int sockfd, const struct sockaddr *myaddr, socklen_taddrlen); bind()的作用是将参数sockfd和myaddr绑定在一起,使sockfd这个用于网络通讯的文件描述符监听myaddr所描述的地址和端口号。 struct sockaddr *是一个通用指针类型，myaddr参数实际上可以接受多种协议的sockaddr结构体 myaddr 初始化之后，才能用bind()函数 网络地址 IPV4 或者是IPV6 INADDR_ANY 参数目前还不知道哪里找到的； 表示本地的任意IP地址, 两个文件描述符 accept()的参数listenfd是先前的监听文件描述符； 而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯 之后与客户端之间就通过这个connfd通讯, 再次回到循环开头listenfd仍然用作accept的参数 client connect() connect和bind的参数形式一致 区别在于bind的参数是自己的地址 而connect的参数是对方的地址。 运行 123$ ./server // 启动server$ netstat -apn|grep 8000 // 得到此时开启的tcp的源地址和端口号$ ./client advvv // 启动客户端 socket文件描述符 一个socket文件描述符对应一个socket pair ,也就是源地址:源端口号和目的地址:目的端口号,也对应一个TCP连接。 错误处理和读写控制 socket / wrap.c 针对文件读写的一个错误信息跳转 信号重连接 慢系统调用accept、read和write被信号中断时应该重试。 connect虽然也会阻塞,但是被信号中断时不能立刻重试。 如果应用层协议的各字段长度固定,用readn来读是非常方便的。 字段长度固定的协议往往不够灵活,难以适应新的变化。 TFTP协议的各字段是可变长的 常见的应用层协议都是带有可变长字段的 可变长字段的协议用readn来读就很不方便了,为此我们实现一个类似于fgets的readline函数 server and client 多用户处理 client改为交互式输入 不断从终端接受用户输入并和server交互 修改 [socket_api/TCP/client.c] server 修改，可以多次处理同一客户端的请求。 fork() 并发 处理多个client的请求 父进程专门负责监听端口，每次accept一个新的客户端连接就fork出一个子进程专门服务这个客户端。 setsockopt 在同一个终端，关闭server后，还能重新开启server 表示创建端口号相同，但IP地址不同的多个socket描述符。 select * 1)select是网络程序中很常用的一个系统调用,它可以同时监听多个阻塞的文件描述符 * 2)不需要fork和多进程就可以实现并发服务的server。 * 3) 未使用 基于UDP的网络编程 udp 中的采用的是数据报文，并非流 SOCK_STREAM –&gt; SOCK_DGRAM UDP 不用考虑多个client的链接 不用考虑同意终端关闭server后不能重新开启的现象 UNIX Domain Socket IPC 网络socket 用于同一台主机的进程间通讯(通过loopback地Domain Soc址127.0.0.1) UNIX Domain Socket socket API原本是为网络通讯设计的，但后来在socket的框架上发展出一种IPC机制 不需要经过网络协议栈,不需要打包拆包、计算校验和、维护序号和应答等 只是将应用层数据从一个进程拷贝到另一个进程 IPC机制：本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。 UNIX Domain Socket 提供面向流和面向数据包两种API接口，类似于TCP和UDP 但是面向消息的UNIX Domain Socket也是可靠的,消息既不会丢失也不会顺序错乱。 区别 | | UNIX Domain Socket | 网络socket || —————- | —————————————————- | —————- || socket文件描述符 | fd = sock() | fd = sock() || address family | AF_UNIX | AF_INET || type | 择SOCK_DGRAM或SOCK_STREAM | tcp/udp 区分 || 地址格式 | sockaddr_un | sockaddr_in || socket地址 | socket类型的文件在文件系统中的路径 | 是IP地址加端口号 || connect() | 客户端要显式调用bind函数，而不依赖系统自动分配的地址 | | 客户端bind一个自己指定的socket文件名的好处是： 该文件名可以包含客户端的pid以便服务器区分不同的客户端。 Web server web服务器对浏览器的处理方式 浏览器 —-&gt; 发送http协议请求 —&gt; web server input ：IP + Port HTTP 的协议头 1$ GET / HTTP/1.1 // 第一行是GET请求和协议版本 web server —&gt; 将对应目录下的索引页(默认的根目录/(在是index.html) —- &gt; 发送给浏览器 格式应答 123456789HTTP/1.1 200 OK // 是协议版本和应答码；200--标示成功，ok可以随意写Content-Type: text/html //为MIME类型--text/html；纯文本是text/plain；图 片则是image/jpg&lt;html&gt;&lt;head&gt;&lt;title&gt;Test Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Test OK&lt;/p&gt; &lt;img src='mypic.jpg'&gt;&lt;/body&gt;&lt;/html&gt; 而HTTP协议规定服务器主动关闭连接]]></content>
      <categories>
        <category>LinuxC</category>
        <category>socket</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tcp/IP]]></title>
    <url>%2F2019%2F05%2F06%2FTcpIp%2F</url>
    <content type="text"><![CDATA[TCP / IP 协议网络基础知识 计算机网络的作用? 提供一种网络形态, 将单用户工作模式,转化为多用户信息共享, 互联模式; 分时系统 通过多个终端与同一计算机相连, 允许多个用户同时操作一台计算机; 通过分时系统, 虚拟的实现了”一人一机”; 特性: 独占性 实现方式: 多任务调度 协议 不同计算机之间通信的基本要求; 举例: 人与人交流的语言 – 中文/ 英语 电路交换和分组交换 网络通信的方式 电路交换：通信双方独占一条线路进行数据传输，其与用户只能等待； 分组交换：通信双方将数组包分组，在一条通信线路上实现多组用户通信； 接收端的数量进行分类 单播: (一年级, 一班的小李) 广播: 同一个链路中相互链接主机间通信( 一年级所有同学 ) 多播：特定组内进行的通信; (一年级一班, 一班的所有同学) 任播：特定组内任意一台主机；(一年级一班, 任意一个同学) 传输速率和吞吐量 传输速率：单位时间内传输的数据量，单位是bps；也称之为带宽； 吞吐量：主机间通信过程中实际的传输速率； 衡量CPU处理能力和网络拥塞程度 OSI 7层参考模型（Open System Interconnection Reference Model） 计算机通信的前提：能上网 网卡：计算机连网的设备 OSI 参考模型的作用？ OSI协议的作用：让异构计算机之间能互相通信； OSI 分层的作用：抽象出每一层的接口，让网络间通信更简单； 同一层之间的通信: 遵循相同的协议; 上下层之间通信: 调用接口 分层 功能 硬件设备 应用层 针对特定应用的协议邮件协议–&gt;电子邮件 表示层 数据格式转换：转化为网络标准格式 网关：协议翻译, 数据转换；代理服务器 会话层 通信管理：决定何时建立/断开连接采用何种连接方式(TCP/UDP) 传输层 管理两个通信节点之间的数据传输；实际建立逻辑上的通道 4-7层交换机：分析收发数据，进行特定处理负载均衡器(窗口大小啥的) 网络层 完整数据包发送，进行数据链路转换(完整行程列表) 路由器/３层交换机：分组数据转换 数据链路层 负责一个数据段帧的发送 网桥/２层交换机：连接两个网络以太网使用：交换集线器hub 物理层 将0/1数据转换为不同介质间的信号量进行传送 中继器：信号整形放大,延长网络；中继集线器, 多个端口的中继器 TCP/IP 基础知识 TCP/IP协议 ARPANET 指定的协议 网际协议族: 通信必须用到的协议群统称; RFC概念 Request for Comment TCP/IP 由IETF讨论制定, 需要标准化的协议, 被列入RFC文档并在互联网上公布; 标准化流程 RFC提议标准(6 month) – 草案标准(4 month) – 标准 互联网 The Internet / 网际网 Internet ISP Internet server provider : 不同的区域网ISP, 相互连接称互联网 NOC network operation connect : 同一个ISP 中不同网络之间的连接 IX Internet Exchange: 不同的ISP区域网之间的链接 TCP/IP 协议分层模型 OSI 模型和TCP/IP模型区别 OSI模型: 注重通信协议具备的功能是什么; TCP/IP : 注重计算机上实现协议应该开发哪些程序 模式和使用的协议 Client –&gt; Server : 使用TCP/IP协议 Wed –&gt; Server: 使用HTTP协议 属性 分层 功能 / 协议 数据单位 应用程序 应用层(会话层以上) HTTP: 万维网(WWW) web; 数据格式 – HTML 消息 SMTP: Email使用(simple mail transfer protocol) FTP: 文件传输(file…); 建立两个TCP连接– 控制和数据 TELENT SSH 远程连接 (secure shell)(更安全) SNMP 网络管理: (simple network management) 操作系统 传输层 端口号: 标识不同的应用程序 段 TCP : 面向连接的传输协议; 有重传机制 TCP数据流 UDP: 面向无连接; 主要用于多播, 广播和视频 互联网层(网络层) 通过路由器: 实现数据包的分组转发, 实现IP协议 数据报 IP协议:根据IP地址进行转发分包数据, 不具备重发机制 (IP UDP) ICMP: IP数据包出故障时, 发送异常通知给发送端 ARP: 从IP地址中解析MAC地址 设备驱动程序与网络接口 网络接口层(数据链路层) 网卡层 根据MAC地址, 通过以太网中的数据链路进行通信驱动程序: 在操作系统和硬件起桥梁作用 帧 WLAN : 无线局域网 PPP: 点对点协议 物理层 负责数据传输 数据封装 每一层都会加一个首部: 数据链路层: 除了加首部, 在尾部加包尾, 循环冗余检测 数据包处理 数据链路层和网络层: 根据协议进行转发; TCP处理: 先检查校验和 – 序列号 – 端口号; 确认数据无误: 发送确认回执 TCP/IP 抽象模型 抽象为一个送快递模型 发货方: 云南的小李 接收方: 北京的张先生 通信双方都会通过TCP/IP的这个过程, 一个是封装数据, 一个是解压数据 传输层 运送给具体的收件人; 网络层 从云南到北京 : 要经过哪些其他省份; 相当于一个行程表 数据链路层: 根据不同的省份划分的区间; 每个区间采用货车大小不同: 最大传输单元MTU(maximum transmission union) 数据链路层 提供直连两个设备之间的通信功能; 网络拓扑结构 网络连接和构成的形态 总线型 ，环形，星型，混合型； MAC地址 48bit 第一位 和 第二位 介质型网络传输 共享介质中传递方式: 多个用户采用一条传输线 争用方式: CSMA/CD 载波监听多路访问 + 碰撞检测 令牌传递方式: 每一个用户能占有一段时间 非共享介质: 通过2层交换机: 与交换机直连, 构建每个用户的独享; 缺点: 交换机故障,所有用户不能通信 以太网 以太网: 最具兼容性的一种数据链路; 介质模式: 非共享介质, 冲突检测不在必要, 让网路变得更加高速; 传输速度: 1K = 1000 ,并非二进制的1024; 协议: IEEE 802.11 以太网帧格式 类型(2byte): 代表上一层协议 FCS(frame check sequence): 数据帧在传输过程中,收到电子干扰,导致0/1错码, 需要进行检测; 无线通信 使用介质: 电磁波 几种类型: 分类 技术 短距离无线 RFID 无线PAN Person Area Network Bletooth 无线LAN Local Area Network Wifi 无线WAN Wide Area Network 3G, 4G 使用协议 IEEE802.11 : 定义了无线LAN协议与数据了链路层的一部分; 介质上采用CSMA/CA PPP 协议 与以太网的区别: 纯数据链路层, 与物理层没有任何关系; 仅有PPP协议是无法通信, 需要物理层的支持 PPP协议的数据发送: 建立PPP级的连接, 建立以后进行身份认证, 加密 和压缩 应用: 用户使用拨号接入英特网; LCP: link control protocol, 负责建立和断开连接; NCP: network control protocol. 负责IP地址的设置以及TCP/IP首部压缩; PAP: password authentication protocol, 用户身份的认证协议, 两次握手进行验证, 密码明文传输 CHAP: challenge handshake authentication protocol, 一次性密码,建立连接后定期换密码 数据包大小: 0-1500 byte FDDI fiber distributed data interface FDDI: 分布式光纤数据接口; 采用令牌环进行通信 ATM ATM: asynchronous(异步) transfer mode : 以信元为单位进行数据连接; 特点: 面向连接的数据链路; 允许同时与多个对端建立通信连接, 时分多路复用技术 IP协议 提供尽力服务, 没有数据包重传机制 网络层和数据链路层关系: 数据链路层: 相当于每一站的车票; 网络层: 从起点到终点的行程安排; 抽象: 只有同时拥有行程表 和每一站的车票, 才能达到终点; IP三个模块 IP寻址: IP地址, 唯一性和层次性 路由控制: 将分组数据发送到最终目标地址的功能; 数据报: 分包和组包( 路由器进行 ) IP 地址 作用: 标识主机和路由器, 使用不同的主机之间通信; IP地址由两部分组成 网络地址: 互联的每个段地址(不同的数据链路)不能重复; 路由器: 包含不同段的网络地址, 数据在不同的网段之间传播 主机地址: 标识同一个段地址中的不同主机; 引入子网掩码的IP地址 子网掩码: 由1组成的一个序列, 用于表示网络地址的位数 IP地址 / 网络地址的位数 CIDR: 路由聚合 减少一位网络地址,增加一位主机地址; 作用: 可以减小路由控制表; IP地址分类: 4类地址 注意四类中网络地址的区间 D类地址: 没有主机标识, 全部用于多播(某些组内) 每一类地址的主机地址个数 123IP个数 = 2^n - 2 主机地址全为0: 用作的是网络地址, 主机地址全为1: 用作同一个链路之间的广播地址; IP多播实现: D类地址 + IGMP(组内控制协议) 224.0.0.0 - 223.255.255.255 多播地址可用范围 全局地址和私有地址 私有地址分为三类: 其主机数 /8 /10 /12; 全局地址: 由ISP进行管理 路由控制 路由协议 : 生成路由控制表 , 控制数据包的下一跳, 最终实现IP通信 Hop 一跳 IP数据包在一个链路区间的传递; 到达的应该是下一个路由器; 路由控制表 从源主机到目的主机的路由控制表 也就是下一个路由到哪里; 路由 地址 功能 默认路由 0.0.0.0/0 /0 不是表示的主机IP 路由表中任一地址都能匹配 主机路由 IP地址/32 整个IP地址都参与路由,不通过网络地址路由 环回路由 127.0.0.1 localhost 主机内部路由 IP 数据报分割与重组 IP数据报为什么要进行分包? 不同的数据链路有不同的传输单元MTU; 以太网: (46 - 1500)byte PPP : 1500byte FDDI : 4352; byte ATM: 9180 byte IP数据包分割与重组 IP/UDP 数据分割: 路由器完成 IP/UDP 数据片重组: 目标主机 TCP的数据分割和重组: 由TCP层自己完成; IPv4 首部 地址格式含义 名称 ( 32bit一组) 长度 bit 值 版本号 0-3(4bit) 4 = 0100 首部长度 : 首部字节数 5*4 =20 4-7(4bit) 5 = 0101 前20个字节代表首部 区分服务: 网络状况 8-13 (DSCP) 14-15(ECN) DSCP: 表示优先度;ECN: 表示网络拥塞 总长度: IP数据包的总长度 16-31 (16bit) 2^16 = 65535字节; 包含首部长度 32bit一组 标识:用于分片重建, 记录分片的顺序 0-15(16bit) 2^16 大小, 分片就递增加1 标志: 是否可以分片/ 最后一个分片 16-18 (3bit) 16bit: 0; 17bit: 0–分片; 1–不能分片18bit: 0–最后一个包; 1–中间的包 片偏移: 表示IP数据包中的位置 19-31(13bit) 2^13 (8192)*8 = 65536; 单位是8byte 32bit一组 生存周期: 经过路由器个数 0-7 (8bit) 2^8:= 255 每经过一个路由器, TTL减1 协议: 表示上层协议TCP/UDP 8-15 (16bit) TCP = 6 ; UDP = 17 首部校验和 16-31 (16bit) 校验数据包的首部,不校验数据 32bit一组 源地址 0-31 目标地址 0-31 IPv6 IPv6地址大小 128bits 8个 16bit 的字节进行表示; :: 双冒号 : 表示省略多个0, 只能用一次 包首部 首部40 bytes 路由器不参与分片处理, 直接以最小MTU 1280字节进行发出 地址结构 IPv6 首部 地址格式 名称(32bit一组) 长度 bit 值 版本: 6 0-3 0110 通信量类 = 区分服务 4-11(8bit) 占时没用 流标号: + 源/目的地址 == 判断是同一个数据流 12-31(20bit) 进行服务质量时, 设置为随机数 32bit一组 有效负载长度: 能包含的数据包长度 不包含首部长度 0-15 2^16=65535 bytes: 不包含首部 下一个首部 = 协议 16-23(8bit) 表示上一层协议 调数限制 = TTL 24-31(8bit) 可经过的路由器个数, 每进过一个减一 32bit一组 源地址 4个32bit 目的地址 4个32bit 32bit一组 IPV6的首部是可以扩展的 IP 协议相关技术 原因: 仅凭IP地址是无法通信的 DNS Domain(域) name System 域名解析系统作用: 将域名(主机名) –&gt; 解析为 IP地址(4/6) 例子: 将应用层的网址, 解析为IP地址才能正常访问, 因为IP地址是区分不同主机的标识; 域名的构成和分层 构成：由英文字母 + 点构成 1piyo.kusa.ac.jp // jp 根域名 分层: 根域名 + 第1层域名 + … + 主机域名 域名服务器: 用于管理域名的主机和相应软件; 每一层都有一个域名服务器; 注册: 每一层的域名服务器都必须注册根域名服务器的IP地址 上一层的域名服务器: 注册了下一层的IP地址 原因: 本层没有: 向根域名请求查询, 从根域名顺序向下查找 DNS查询 工具: 解析器 先在本层的域名服务器查找相关域名; 从根域名顺序向下查找 DNS解析情况 主机名 –&gt; 检索IP地址: “A类” — 正常的DNS解析 IP地址 –&gt; 检索主机名: “PTR类” — IP地址的反向解析 ARP Adress resolution protocol IPv4 – ARP协议: IPv6 (ICMPv6) 以目标IP地址地址为线索, 定位下一个接收数据包的网络设备对应的MAC地址; 网络设备: 目的主机, 或者路由器 ARP工作机制, 如何获得MAC? ARP 请求(广播) : 携带目标通信的IP地址; ARP 响应: 获取下一个的MAC地址; RARP : Reverse 从MAC地址定位字节的IP地址; 例子: 嵌入式设备接入网络得到IP地址 ICMP Internet control message protocol ICMP :消息协议 ICMP的通知消息会使用IP进行发送; 一类: 通知出错原因的 错误消息; 另一类: 用于诊断的 查询消息; 主要的ICMP消息 traceroute应用软件 : 显示数据发送过程中经过了多少个路由 ICMP目标不可达消息 | 错误号 | 错误消息 | 原因 || —— | —————————— | ——————————————— || 0 | Network Unreachable 网络不可达 | TTL生存周期减到0时, 经过了2^8个路由器, 有错误 || 1 | Host Unreachable 主机不可达 | 目标主机的IP地址不存在 | ICMP回送消息(本地消息) 用途: 用于正在进行通信的主机之间 或者 路由器之间; 作用: 判断数据包是否发送到对端; command: ping IP ICMPv6 用于IPV6中的消息机制 邻居探索: 用于查询IPv6地址与MAC地址对应关系, 并向邻居宣告的得知的MAC地址 实现: 利用多播地址实现传输 DHCP dynamic host configure protocol DHCP: dynamic host configuration protocal 通过DHCP自动分配获取IP地址 DHCP 功能: 实现用互上网的即插即用, 自动获取相应的IP地址; DCHP 如何实现: DHCP client : 广播发送DHCP发现包(请求分配IP) DHCP server: 回复DHCP提供包(提供能分配的ip) DHCP client: 发送DHCP请求包(进行设置) DHCP server: 回复DHCP提供包(允许) DHCP client server具备的 功能: server: 在分配IP之前, 发送ICMP回送请求包 client : 针对获取的IP地址, 发送ARP请求包; DHCP 中继代理 作为客户端和服务器之间的桥梁; 避免每一个客户端都需要与服务器直连 NAT network address translator NAT作用 在本地网络使用私有地址, 在连接互联网时使用全局地址; 实现一个全局IP与多个主机通信; NAT-PT 在IPv4 和 IPv6 之间通信; other IP隧道: 不支持路由器就可以采用这种技术; IGMP: 实现多播技术 路由协议 网络层路由器使用的协议: 传输数据报 网路层存在两个网络设备: 主机 + 路由器 路由协议的作用: 所有的路由协议, 目的都是生成路由信息控制转发表; 路由控制的定义? 根据目的IP地址, 构成目的可达的路由控制转发表, 使得数据包能按照正确的方向转发数据; 路由的分类 静态路由: 手动设置主机和路由器的IP信息; 动态路由: 首先选定路由协议, 由自制系统内部的路由生成路由控制信息表 动态路由基础 动态路由如何生成路由控制表? 相邻路由会发送已知的网络信息, 像接力赛一样一直传递, 直至整个网络都了解; 路由控制范围? 分为内部和外部: IGP (Interior Gateway protocal) 和 EGP(Exterior Gateway protocal) 抽象对比: 主机IP地址 + 网络IP地址 原因: 只有一种存在, 是无法完成数据传递的; 自治系统AS(autonomous system) 和路由选择域? AS 内部采用的协议是IGP域内路由协议; AS 自制系统之间采用的是EGP 域外路由协议; 路由算法 距离向量算法 根据距离( hop 数量)和转发方向决定下一跳的网络设备, 目的是经过较少路由器的个数 代价: 不同的转发方向, 决定了不同的距离; 链路状态算法 每个路由都保存整个网络的拓扑结构, 根据链路代价进行选择; 代价: 每个链路的权重和 路径向量算法 以AS自治网路的个数进行选择 经过较少的AS 主要的路由协议 RIP Routing Information Protocol RIP的特点 距离向量型的路由协议: 最少路由器为选择 定期 和 广播交换路由信息;(即使网络状态稳定) 不与子网掩码进行交互; 链路出问题时处理方式: 不确定是哪一个链路出问题就进行路由控制, 稳定周期很长 RIP如何生成路由控制信息表? 首先: 路由器每30秒为一个周期, 广播已知的路由信息; 等待6个周期后没有反馈则断开网络; 然后: 从距离向量数据库中, 抽出距离短的作为新的控制向量表; 路由变更的时候,如何更新? 定期进行广播, 下一个路由在原基础上加1后, 传给下一个路由; ( 要传回发送路由, 不然6个周期认为断开 ) RIP如何解决无限计数的问题? 方法一: 定义最长条跳数为16, 超过后还未达到, 认为链路处于断开状态; 方法二: 水平分割, 接收端不把收到的信息返回给发送端; 环路问题的解决? 毒性逆转: 当链路中有断开时, 发送距离为16的消息(网络不可达) 触发更新: 当链路变化时, 为了链路尽快收敛, 不再是定期广播, 而是立刻发送; RIP2 采用多播的形式; OSPF open shortest path first OSPF 的特点? 链路状态算法型的路由协议: 以最小权重代价进行选择; 路由控制表实现生成: 路由与中心路由交互得到控制信息; 每个路由器都包含整个网络的拓扑结构, 得到最优路径; OSPF 如何得到路由控制表? 首先发送HELLO协议: LAN每10秒发送hello包, 确认链路是否处于连接状态 未收到链路状态确认包, 空等3次, 第4次还未收到则确认断开 然后: 链路变化, 如何更新? 发送链路状态请求包和 更新包 NLSA network link state advertisement : 以网络为中心生成的信息, 与那些路由器相连; RLSA Routing : 以路由器为中心 最后: 生成网络结构的链路状态信息库; 在AS自治系统内引入区域 将路由器划分为5种; BGP border gateway protocol BGP的特点? 路径向量的协议; 边界网管协议, 连接不同的AS 自治系统 AS路径信息访问列表 包含转发方向和距离(RIP), 还涵盖途经所有AS编号; BGP路由控制表生成? 通过BGP扬声器, 创建BGP链接, 在AS之间交换信息; 得到一个经过AS数量最少的路径 MPLS multi protocol label switching 特点 多协议标记交换技术; 每个IP包都含有一个标记值 传输层 TCP/UDP 传输层的作用? 将IP数据包, 发送给具体的应用程序; 传输层的标识/抽象 ? 端口号 ( 快递中的姓氏 ) client and server 如何处理通信过程? client: 向端口号为80的应用程序请求连接 server: 服务器程序充当守护进程, 接收client的请求; 启动一个可以代表所有守护进程的inetd(超级守护进程); inetd 监听到请求后, 通过fork exec 转换成对应server的守护进程 http server –&gt; 守护进程 httpd; 能够认为是TCP/IP 通信过程? IP(源/目的) + 端口号(源/目的) + 协议 TCP和UDP的区别总结 角度 TCP UDP 连接 面向连接（发送数据前需要建立连接） 无连接（发送数据无需连接） 丢包重试 实现了数据传输时各种控制功能:丢包重发控制，顺序控制 不会进行丢包重试，也不会纠正到达的顺序 模式 流模式（面向字节流） 数据报模式（面向报文） 对应关系 一对一 支持一对一，一对多，多对一和多对多的交互通信 头部开销 最小20字节 只有8字节 可靠性 全双工非常可靠、无差错、不丢失、不重复、且按序到达 不保证可靠交付，不保证顺序到达 拥塞控制 有控制 有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 资源要求 TCP程序结构较复杂，较多 UDP程序结构简单，少 端口号 端口号标识符的作用 识别同一台计算机中进行通信的不同应用程序; 另一个名称: 程序地址; 端口号的定义: 有传输层的协议确定 静态定义: 标准既定的端口号; 50 - DNS ; http-80 ; ssh-22 时序分配法: 操作系统进行加1 TCP transfer control protocol TCP 传输协议: 可靠的数据流传输协议; 传输, 发送, 通信, 进行控制的协议; 建立通信的虚拟电路 重发超时时间设定 需要动态: 不同LAN 通信距离不同; 时间大小( min 1s) = 传输往返时间(0.5s) + 偏移量(0.5s) 以指数形式增加等待时间; (当TTL为0时就结束) TCP 连接和断开 连接: 3次握手; 第三次握手: 确认了TCP数据的最大消息长度MSS; 断开: 4次握手 断开的时候, 客户端要等待2MSL才关闭 TCP为什么需要第三次握手? 为了防止已失效的连接请求报文段又突然传送给服务器，从而产生了错误 如果没有三次握手，那么服务器发送确认后，连接就建立了，而此时客户端没有发送建立连接的请求报文段，于是不理会服务器的确认，也不会给服务器发送数据，而服务器却一直等待客户端发送数据，因此服务器的许多资源就浪费了，采用三次握手的方式就可以防止这种事情发生。 TCP第4次挥手为何要等待2MSL才关闭？ MSL(Maximum Segment Lifetime)报文最大生存时间 任何报文在网络上存活的最大时间，一旦超过该时间，报文就会被丢弃。 TIME_WAIT = 2MSL也就是指的2倍MSL的时间。 保证客户端最后一次挥手的报文能够到达服务器，若第4次挥手的报文段丢失了，服务器就会超时重传第3次挥手的报文段, client是保持TIME_WAIT 建立连接目的 以段为单位: 确认最大消息长度MSS maximum segment size 确保消息不会被IP路由分割 段数据发送 , 如何增加吞吐量? 滑动窗口: 将n个段一起发送, 收到某个段的应答时, 滑动窗口下移; 窗口控制和重发控制? 窗口大小控制 ( 数据流控制 ) a)窗口探测机制: 发送探测字段(1byte), 获取接收方容纳空间, 从而增加窗口大小; b) 拥塞控制: 先设置窗口为1, 当收到ACK确认后, 递增窗口大小; 遇到超时重发时, 设置慢启动阀值, 将拥塞窗口减小为一半; 重发控制: 重发的两种情况 ACK确认应答丢失, 此时数据收到; 无需重发, 只需要确认下一个序列号就行 数据包丢失: server 重复三次发送同一数据段的确认消息 高速重发机制: client 收到3次确认应答时, 重发数据; 超时重发机制: 以重发超时时间进行等待; 提高网络利用率? Nagle 算法: 针对 发送方 机制: 当发送端数据很少时, 延迟发送 何时进行数据发送? 已发送数据都收到应答时; 发送消息发到最大的MSS; 延迟确认应答 : 接收方 何时发送回复确认: 收到 2* MSS消息段时; 延时发送回复确认, 最大延时0.5秒 捎带应答 启用延迟确认应答机制后, 才能使用; TCP 首部 TCP首部: 20bytes 名称(32bit为一组) 长度 bit 作用 源端口号 2^16 标识发送端 目的端口 2^16 标识接收端 序列号: 发送数据的位置; 2^32 序列号不会从0/1开始, 随机生成,;SYN和FIN 不包含数据,但是会增加一个字节的序列号 确认应答号 2^32 发送方设置: 下一次应该收到的序列号;在这之前的数据确认都被收到了 数据偏移 : 5 2^4 将首部 和 数据的位置分开, 从第二十的字节后才是数据 保留位 2^4 0 还未用 控制位 2^8 每一位使用的时候设置为1ACK = 1 : 用于确认时一直为1SYN = 1: 确认建立连接FIN = 1: 断开连接 窗口大小 2^16 指示发送端从确认应答号所指处, 能接受的数据大小(8bit)窗口为0时: 可以发送探测窗口; 校验和 2^16 TCP的校验和无法关闭, 和udp一样需要TCP伪首部 紧急长度 2^16 没有用 UDP user datagram protocal UDP提供的通信方式 通过IP提供一种无连接的通信服务; UDP的首部: 8byte 名称 长度 作用 源端口号 2^16长度= 65536 设置为0: 不需要返回的通信中 目的端口号 2^16 标志计算机通信中不同的应用程序 包长 2^16 UDP首部 + data 总长 校验和 2^16 校验和字段在内的所有数据之和 = 16位全为1, 数据是否正确UDP的校验和可以关闭, 减少时间 校验和的计算需要UDP伪首部 UDP的伪首部概念: 标识一个TCP/IP通信需要5各部分, IP(源/目的) + port(源/目的) + 协议; udp中只包含两个端口号, 其余的在IP中; 实现UDP在IP首部并不可靠的情况下, 仍能提供可靠的通信传输 传输层其他协议 UDP - Lite 当收到的数据校验和出错时, 不一定丢掉数据; DCCP 数据拥塞控制协议 辅助UDP传输的协议, 不能提供可靠性传输 能提供拥塞控制, 确认应答 SCTP 流控制传输协议 : 类型: 是一种对数据可靠性检验的协议 应用: 应用程序之间发送众多较小的消息(数据块); 应用层协议 应用层协议定义: 根据具体应用, 由不同用户研发出来的协议; 应用可以享受传输层以下的基础部分, 应用层不需要考虑数据如何传输 在命令的发送和应答 末尾加上换行: CR+LF 远程登录 TELENT 应用: 登录路由器或交换机进行相应的设置. 数据传输模式: 行模式 和 透明模式 (无需加密) tcp连接: 建立一条; SSH 应用: 加密的远程登录系统; 端口转发: 将收到的消息发送给特定的IP地址和端口号码的一种机制 TCP连接: 建立三条, 一条加密, 两条不加密 SSH的端口号: TCP22 FTP (File transfer protocol) 文件传输 FTP传输的需求 先在远程登录的前提下: 计算机之间进行文件传输的协议; FTP工作机制 建立两条TCP连接; TCP21 数据传输的TCP 和 控制的TCP按照相反的方向建立连接 FTP连接断开机制 文件传输过程中是不会断开的, 只有当用户长时间未输入命令是才会断开连接; 通过ASCII字符串进行交互处理 电子邮件协议 电子邮件的机制: 邮件地址, 数据格式, 发送协议; 数据格式 通过MIME扩展了数据格式, 不只是单一的文本格式; SMTP simple mail transfer protocol: 发送电子邮件的协议 引入邮件服务器: 发送端与服务器进行通信; TCP25 建立通信链接 client : 发送文本请求 server: 回复3位数字进行应答 POP协议 解决问题 用户需要一上电, 就能接收到协议; POP服务器主动向用户发送链接请求(OK), 用户需要进行验证(user + password) IMAP Internet message access protocol 邮件由服务器进行管理; 用户不用保存到本地就可以进行查看 WWW world wide web www 协议作用 将互联网的信息以超文本(文本+ 文本相关内容)进行展示的系统; www万维网的三个概念 URI: 访问信息的手段与位置 uniform resource identifier URI所表示的组合叫做方案 HTML: 信息的表现形式 处于表示层 具有纯文本的功能 HTTP: 信息转发 当用户输入URI访问时, http就开始工作 TCP80 建立连接, 进行请求, 应答, 数据发送 http1.0 : 每发送一次就建立断开一次tcp http1.1: 建立一次可以发送多次 多媒体通信实现 UDP + 呼叫控制协议 呼叫控制协议 SIP 协议: 事先解析对方的地址, 呼出对方号码并对所要传输的信息进行处理 RTP: 加入表示报文顺序的序列号字段 数字压缩 访问目录的协议 LDAP lightweight directory access protocol 网络安全方式 网络防火墙 加密认证 安全协议]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread]]></title>
    <url>%2F2019%2F05%2F05%2FThread%2F</url>
    <content type="text"><![CDATA[ThreadIntroduction Why? 有些情况需要在一个进程中同时执行多个控制流程； 比如实现一个图形界面的下载软件：下载和交互多个线程 main 函数和信号处理函数是同一个进程地址空间中的多个控制流程 信号处理函数的控制流程只是在信号递达时产生 在处理完信号之后就结束 多线程的控制流程 可以长期并存，操作系统会在各线程之间调度和切换,就像在多个进程之间调度和切换一样。 同一进程的多个线程共享同一地址空间 Text Segment、Data Segment都是共享 文件描述符表；每种信号的处理方式；当前工作目录；用户id和组id 线程独立的资源 线程id …. Complie 在Linux上线程函数位于libpthread 共享库中,因此在编译时要加上-lpthread 选项 1$ gcc main.c -lpthread 线程库函数是由POSIX标准定义的,称为POSIX thread或者pthread。 1$ man pthread_ Thread Control 变量类型 pthread_t thread_create thread_create() 线程 –&gt; pthread_create( )，当前线程从pthread_create()返回继续往下执行; 新线程执行代码： 由函数指针start_routine决定 start_routine 函数接收一个参数,是通过pthread_create的arg参数传递给它 类型为void * start_routine 返回时,这个线程就退出 其它线程可以调用pthread_join 得到start_routine的返回值 Process vs Thread Process id 的类型是pid_t ，id在整个系统中是唯一的； 调用getpid(2)可以获得当前进程的id , 是一个正整数值。 Thread 线程id的类型是thread_t，它只在当前进程中保证是唯一的 id 值类型不唯一，不能简单地当成整数用printf打印,调用pthread_self(3) 可以获得当前线程的id pid and tid 多个线程调用getpid(2) 可以得到相同的进程号 而调用pthread_self(3) 得到的线程号各不相同。 error fork : 错误码保存在errno 中，直接用perror(3) 打印错误信息, thread：先用strerror(3)把错误码转换成错误信息再打印。 中止 如果任意一个线程调用了exit 或_exit ,则整个进程的所有线程都终止 make 编译 12$ gcc -g -c thread.c -o thread.o$ gcc thread.o -plthread -o thread // -plthread 位置要在后面，才能正常link thread_exit 三种终止线程的方式 pthread_join() 在Linux的pthread库中常数PTHREAD_CANCELED 的值是-1。可以在头文件pthread.h 中找到它的定义。 pthread_detach 线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止 线程置为detach状态：这样的线程一旦终止就立刻回收它占用的所有资源,而不保留终止状态。 一个线程调用了pthread_detach 就不能再调用pthread_join 了。 thread time synchronizemetux 变量类型：pthread_mutex_t 多个线程同时访问共享数据时可能会冲突,这跟前面讲信号时所说的可重入性是同样的问题。 Mutual Excludive Lock 互斥锁 获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据 这样“读-修改-写”三步操作组成一个原子操作，中间不会被打断 Metux init 1$ pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //:成功返回0,失败返回错误号 metux lock and unlock 123int pthread_mutex_lock(pthread_mutex_t *mutex); // lockint pthread_mutex_trylock(pthread_mutex_t *mutex); // don't hang upint pthread_mutex_unlock(pthread_mutex_t *mutex); //unlock pthread _mutex_trylock 如果一个线程既想获得锁,又不想挂起等待 如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。 lock and unlock 互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。 unlock操作中唤醒等待线程 对Mutex变量的读取、判断和修改不是原子操作 为了实现互斥锁操作,大多数体系结构都提供了swap或exchange指令 避免死锁 A 挂起等待B的锁；B也挂起等待A的锁；造成死锁状态 尽量使用pthread_mutex_trylock调用代替pthread_mutex_lock调用,以免死锁。 Condition Variable 条件时间同步 通过条件变量(Condition Variable)来阻塞等待一个条件,或者唤醒等待这个条件的线程。 用pthread_cond_t 类型的变量表示 cond_init 1$ pthread_cond_t cond = PTHREAD_COND_INITIALIZER; //成功返回0,失败返回错误号。 cond_funcation 1234$ pthread_cond_timedwait() //可以设置超时时间$ pthread_cond_wait()$ pthread_cond_signal() // 唤醒在某个Condition Variable上等待的另一个线程$ pthread_cond_broadcast() //唤醒在这个Condition Variable上等待的所有线程。 一个Condition Variable总是和一个Mutex搭配使用的。 阻塞等待 code 节生产者-消费者的例子是基于链表的,其空间可以动态分配 Semaphore man sem_overview semaphore变量的类型为sem_t, Mutex and Semaphore Mutex ：变量是非0即1的，可看作一种资源的可用数量 0/1 Semaphore：可用资源的数量，和Mutex不同的是这个数量可以大于1。 semaphore funcation 12345$ int sem_init() // sem_init()初始化一个semaphore变量$ int sem_wait() // 调用sem_wait()可以获得资源,使 semaphore--$ int sem_trywait() // semaphore = 0；如果不希望挂起等待$ int sem_post() // 释放资源,semaphore++,同时唤醒挂起等待的线程。$ int sem_destory() // 销毁变量 code 现在基于固定大小的环形队列重写这个程序。 Other 线程冲突概念： 共享数据只读：那么各线程读到的数据应该总是一致的,不会出现访问冲突。 一个线程可以改写数据：就必须考虑线程间同步的问题。 读者写者锁(Reader-Writer Lock) Reader之间并不互斥,可以同时读共享数据 而Writer是独占的(exclusive) ,在Writer修改数据时其它Reader或Writer不能访问数据, 可见Reader-WriterLock比Mutex具有更好的并发性。 并发性 用挂起等待的方式解决访问冲突不见得是最好的办法,因为这样毕竟会影响系统的并发性 例如Linux内核的Seqlock、RCU(read-copy-update)等机制。 死锁问题 微秒级延时：加快仿真速度。 1$ usleep(3)]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RidingBicycle]]></title>
    <url>%2F2019%2F04%2F29%2FRidingBicycle%2F</url>
    <content type="text"><![CDATA[RidingBicycle骑行木兰草原骑行路程安排 日期 骑行目的 骑行公里 天气 住宿 5.1 hust - 黄陂 - S108 - 枫树驿站 97.1 多云 5.2 游玩 木兰天池 5.3 枫树驿站 - 锦里沟 15.12 5.4 锦里沟 - hust 110 花费 项目 花费 枫树客栈 218 衣物携带 物品 数量 用途 一套骑行的衣服裤子 1 只用来骑行 一套休闲的衣服– 木兰草原要走很多路 1 y用来木兰草原游玩 两双袜子和内衣裤 2 生活用品 物品 数量 用途 牙刷 1 宾馆不好用 急救用品 物品 数量 用途 创口贴 5 小伤口 云南白药 1 扭伤 修车工具 物品 数量 用途 内胎 2 换和补 链条油 1 润滑 修车工具包 1 急救]]></content>
      <categories>
        <category>Riding</category>
      </categories>
      <tags>
        <tag>RidingBicycle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DaemonControl]]></title>
    <url>%2F2019%2F04%2F28%2FDaemonControl%2F</url>
    <content type="text"><![CDATA[Daemon Control 作业控制：将进程放在前台或者后台执行 守护进程：即使关闭了terminal，进程也能继续执行 TerminalIntroduction 控制终端(Controlling Terminal) 用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端 控制终端是保存在PCB中的信息 每个进程的标准输入、标准输出和标准错误输出都指向控制终端 在控制终端输入一些特殊的控制键可以给前台进程发信号 例如 Ctrl-C表示SIGINT Ctrl-\ 表示SIGQUIT ttyname 函数 文件描述符查出对应的文件名 该文件描述符必须指向一个终端设备而不能是任意文件 1$ printf("fd 0 : %s\n", ttyname(0))； Terminal Login 登录用户模式，或者root模式 一台PC通常只有一套键盘和显示器,也就是只有一套终端设备/dev/tty0 虚拟终端(Virtual Terminal)：设备文件分别是/dev/tty1~ /dev/tty6 1$ Ctrl-Alt-F1 ~ Ctrl-Alt-F6 // 切换到6个字符终端 内核中处理终端设备的模块 包括硬件驱动程序 硬件驱动程序负责读写实际的硬件设备 线路规程(LineDiscipline) 线路规程像一个过滤器 某些特殊字符并不是让它直接通过，而是做特殊处理 终端设备有输入和输出队列缓冲区 命令行键入字符时,该字符不仅可以被程序读取,我们也可以同时在屏幕上看到该字符的回显。 Terminal Login 系统启动时，init进程根据配置文件确定需要打开哪些终端。 把文件描述符0、1、2都指向控制终端，然后提示用户输入帐号。 login 程序提示用户输入密码(输入密码期间关闭终端的回显),然后验证帐号密码的正确性。 Network Login 虚拟终端或串口终端的数目是有限的。 伪终端(Pseudo TTY) 实现：网络终端或图形终端窗口的数目却是不受限制的 一套伪终端由一个主设备(PTY Master)和一个从设备(PTY Slave)组成。 主设备在概念上相当于键盘和显示器,只不过它不是真正的硬件而是一个内核模块,操作它的也不是用户而是另外一个进程 从设备和上面介绍的/dev/tty1 这样的终端设备模块类似,只不过它的底层驱动程序不是访问硬件而是访问主设备。 Network Login 用户通过telnet客户端连接服务器；服务器监听连接请求是一个telnetd进程。 telnetd子进程打开一个伪终端设备,然后再经过fork 一分为二:父进程操作伪终端主设备,子进程将伪终端从设备作为它的控制终端 当用户输入命令时,telnet客户端将用户输入的字符通过网络发给telnetd 服务器,由telnetd 服务器代表用户将这些字符输入伪终端。 交互 我们每按一个键telnet客户端都会立刻把该字符发送给服务器 这个字符经过伪终端主设备和从设备之后被Shell进程读取，同时回显到伪终端从设备 回显的字符再经过伪终端主设备、telnetd服务器和网络发回给telnet 客户端,显示给用户看。 设备 ptyXX 是主设备,相对应的ttyXX 是从设备 Jobs ControlSession 和进程组 Shell分前后台来控制的不是进程而是作业(Job)或者进程组(Process Group)。 Jobs Control Shell可以同时运行一个前台作业和任意多个后台作业 12$ proc1 | proc2 &amp; //proc1 和proc2 属于同一个后台进程组$ proc3 | proc4 | proc5 //前台进程组 从Session和进程组的角度重新来看登录和执行命令的过程 Session Leader getty 或telnetd进程在打开终端设备之前调用setsid函数创建一个新的Session 该进程的id也是进程组的id。 命令 12$ ps -o pid,ppid,pgrp,session,tpgid,comm | cat$ ps -o pid,ppid,pgrp,session,tpgid,comm | cat &amp; 这个作业由ps和cat 两个进程组成，分别在前台和后台运行 与作业控制有关的信号 后台进程 不能读终端输入的, 因此终端有输入时，内核发SIGTTIN信号给进程； 该信号的默认处理动作是使进程停止。 jobs and fg 12345$ jobs // jobs 命令可以查看当前有哪些作业$ fg %1 // fg命令可以将某个作业提至前台运行，或者将停下的进程开启 // 参数%1表示将第1个作业提至前台运行。$ bg %1 // bg 命令可以让某个停止的作业在后台继续运行$ ps // 查看当前的控制信号 cat 1$ cat &amp; // 后台运行进程 Daemon Process 守护进程(Daemon) 用户关闭终端窗口或注销也不会影响守护进程的运行。 $ ps axj 查看系统中的进程 参数a 表示不仅列当前用户的进程,也列出所有其他用户的进程 参数x 表示不仅列有控制终端的进程,也列出所有无控制终端的进程 参数j表示列出与作业控制相关的信息。 进程信息 守护进程：没有控制终端的进程，TPGID = -1 守护进程：通常采用以d结尾的名字,表示Daemon。 内核线程Kernel：用[]括起来的名字，采用以k 开头的名字 创建守护进程 最关键的一步是调用setsid函数创建一个新的Session,并成为Session Leader。 调用这个函数之前,当前进程不允许是进程组的Leader,否则该函数返回-1。 要先fork 再调用setsid，保证当前进程不是Leader。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>Daemon</tag>
        <tag>Control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Signal]]></title>
    <url>%2F2019%2F04%2F26%2FLinuxCSignal%2F</url>
    <content type="text"><![CDATA[LinuxC Signal 进程在执行代码时，收到内核的Signal，使得进程终止 代码遇到一个问题：头文件包含函数，但是函数调用不成功 Signal 查询 1$ man 7 signal //详细说明 Ctrl-C产生的信号只能发给前台进程。 “wait和waitpid函数”中我们看到一个命令后面加个&amp; 可以放到后台运行 这样Shell不必等待进程结束就可以接受新的命令 信号： 使用该进程，执行用户空间代码时，执行到任何地方都有可能收到SIGINT信号终止进程。 信号相对于进程的控制流程来说是异步(Asynchronous)的。 ｛% asset_img signal_start.png %｝ 不想按默认动作处理信号 用户程序可以调用sigaction(2) 函数告诉内核如何处理某种信号 SIGINT的默认处理动作是终止进程 SIGQUIT的默认处理动作是终止进程并且CoreDump 产生信号通过终端按键产生信号 CoreDump (核心转存) 当一个进程要异常终止时,可以选择把进程的用户空间内存数据全部保存到磁盘上； 文件名通常是core，这叫做Core Dump 进程异常终止 有Bug,比如非法内存访问导致段错误； 事后可以用调试器检查core 文件以查清错误原因，做Post-mortem Debug。 Core 文件 一个进程允许产生多大的core 文件取决于进程的Resource Limit 默认是不允许产生core 文件的,因为core 文件中可能包含用户密码等敏感信息,不安全。 1$ ulimit -c 1024 // ulimit命令改变这个限制,允许产生core文件，最大值是1024 按键产生signal 123$ ./a.out // press ctrl+c $ ./a.out // press ctrl+\$ ls -l core //core dump 调用系统函数向进程发信号 后台运行程序 123$ ./a.out &amp; //首先在后台执行这个程序;数字代表进程的id$ kill -SIGSEGV 7940$ 再次回车 // ,Shell不希望Segmentation fault 信息和用户的输入交错在一起 以往遇到的段错误都是由非法内存访问产生的,而这个程序本身没错,给它发SIGSEGV 也能产生段错误。 也可以调用函数 12int kill(pid_t pid, int signo);int raise(int signo); abort函数 abort 函数使当前进程接收到SIGABRT 信号而异常终止。 就像exit 函数一样,abort 函数总是会成功的,所以没有返回值。 由软件条件产生信号 SIGPIPE是一种由软件条件产生的信号 alarm 和SIGALRM 信号 调用alarm 函数可以设定一个闹钟,也就是告诉内核在seconds秒之后给当前进程发SIGALRM 信号 该信号的默认处理动作是终止当前进程。 阻塞信号信号在内核中的表示 信号递达Delivery 而实际执行信号的处理动作 信号未决 Pending 信号从产生到递达之间的状态 阻塞Block：进程可以选择阻塞某个信号 被阻塞的信号产生时将保持在未决状态,直到进程解除对此信号的阻塞,才执行递达的动作。 忽略某个信号 只要信号被阻塞就不会递达,而忽略是在递达之后可选的一种处理动作。 每个信号包含三个要素 都有两个标志位：分别表示阻塞block和未决pending 还有一个函数指针sighandler表示处理动作。 信号产生时，内核在进程控制块中设置该信号的未决标志,直到信号递达才清除该标志。 sigset_t 称为信号集 sigset_t来存储：未决和阻塞标志 阻塞信号集中：“有效”和“无效”的含义是该信号是否被阻塞, 未决信号集中：“有效”和“无效”的含义是该信号是否处于未决状态。 阻塞信号集 也叫做当前进程的信号屏蔽字(Signal Mask) 信号集操作函数 sigset_t 类型对于每种信号用一个bit表示“有效”或“无效”状态 sigemptyset 初始化set 所指向的信号集,使其中所有信号的对应bit清零 在使用sigset_t 类型的变量之前,一定要调用sigemptyset或sigfillset 做初始化,使信号集处于确定的状态。 sigprocmask 调用函数sigprocmask可以读取或更改进程的信号屏蔽字。 如果调用sigprocmask解除了对当前若干个未决信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。 sigpending sigpending 读取当前进程的未决信号集,通过set参数传出。 捕捉信号内核捕捉信号 捕捉信号 如果信号的处理动作是用户自定义函数,在信号递达时就调用这个函数 用户注册SIGQUIT信号的处理函数：sighandler 内核捕捉函数 第一次进入内核：发生中断或异常切换到内核态。 第二次进入内核：中断处理完后，检查到有信号SIGQUIT递达，执行sighandler 函数；系统调用sigreturn 再次进入内核态。 如果没有新的信号要递达,这次再返回用户态就是恢复main 函数的上下文继续执行了。如果有信号递达，在执行（第二次进入内核） sigaction sigaction 函数可以读取和修改与指定信号相关联的处理动作 sigaction：两个参数指向 struct signaction 结构体 sa_sigaction 是实时信号的处理函数。 pause pause 函数使调用进程挂起直到有信号递达。 如果信号的处理动作是捕捉,则调用了信号处理函数之后pause 返回-1,errno 设置为EINTR ,所以pause 只有出错的返回值 如果信号的处理动作是终止进程,则进程终止,pause 函数没有机会返回; 可重入函数 引入了信号处理函数sighandler：使得一个进程具有多个控制流程。 重入函数： 如果一个函数只访问自己的局部变量或参数,则称为可重入(Reentrant )函数。 函数被不同的控制流程调用 有可能在第一次调用还没返回时就再次进入该函数(两次进内核函数) 不可重入函数： insert函数访问一个全局链表,有可能因为重入而造成错乱,像这样的函数称为不可重入函数, sig_atomic_t类型与volatile限定符 在使用sig_atomic_t类型时，加上volatile限定符 为了避免重入造成的链表错乱现象 线程会讲到如何保证一个代码段以原子操作完成。 在使用sig_atomic_t类型时，加上volatile限定符，也能保证原子操作 编译器无法识别 只能说编译器无法识别程序中存在多个执行流程。 比如sigaction 、pthread_create ,这些不是C语言本身的规范,不归编译器管,程序员应该自己处理这些问题 竞态条件 竞态条件(Race Condition): 由于异步事件在任何时候都有可能发生(这里的异步事件指出现更高优先级的进程) 如果我们写程序时考虑不周密,就可能由于时序问题而导致错误 sigsuspend 函数 要是“解除信号屏蔽”和“挂起等待信号”这两步能合并成一个原子操作的功能。 进程的信号屏蔽字由sigmask参数指定,可以通过指定sigmask来临时解除对某个信号的屏蔽,然后挂起等待 SIGCHLD 信号 为了避免僵尸程序的产生 子进程在终止时会给父进程发SIGCHLD信号 方法 父进程调用sigaction 将SIGCHLD 的处理动作置为SIG_IGN ,这样fork 出来的子进程在终止时会自动清理掉,不会产生僵尸进程,也不会通知父进程。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular_Expression]]></title>
    <url>%2F2019%2F04%2F25%2FRegular-Expression%2F</url>
    <content type="text"><![CDATA[Regular_Expression POSIX规定了正则表达式的C语言库函数,详见regex(3) 。 本章介绍了正则表达式在grep 、sed、awk 中的用法,学习要能够举一反三, 例如验证用户输入的IP地址或email地址格式是否正确。 正则表达式概念 概念 规定一些特殊语法表示字符类、数量限定符和位置关系,然后用这些特殊语法和普通字符一起表示一个模式,这就是正则表达式(Regular Expression)。 “正则表达式”就像“变量”，是一个广泛的概念，而不是某一种工具或编程语言的特性。 grep 用grep 在一个文件中找出包含某些字符串的行 找出符合某个模式(Pattern)的一类字符串 grep 模式包含信息 grep 搜索例子 email 正则表达式 1[a-zA-Z0-9_.-]+@[a-zA-Z0-9_.-]+\.[a-zA-Z0-9_.-]+ IP地址的正则表达式 1[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125; 搜索文本 textfile 中的IP 1$ egrep '[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;' testfile egrep 相当于grep -E,表示采用Extended正则表达式语法。 注意正则表达式参数用单引号括起来了 原封不动地传给grep 命令,而不会被Shell解释掉。 搜索结果 因为grep 找的是包含某一模式的行，这一行包含一个符合模式的字符串234.234.04.567。 grep 找的是包含某一模式的行,而不是完全匹配某一模式的行 grep 是一种查找过滤工具,正则表达式在grep 中用来查找符合模式的字符串。 其实正则表达式还有一个重要的应用是验证用户输入是否合法, email 地址验证 基本语法 以上介绍的是grep正则表达式的Extended规范； 如果用grep 而不是egrep ,并且不加-E参数,则应该遵照Basic规范来写正则表达式。 Basic规范也有这些语法； 只是字符?+{}|()应解释为普通字符 要表示上述特殊含义则需要加\ 转义。 概念 C的变量有各种类型，而Shell脚本变量都是字符串。 各种工具和编程语言所使用的正则表达式规范的语法并不相同,表达能力也各不相同。 egrep 正则表达式 man 7 regex 字符类 通过字符来限定表示的方式 数量限定符 字符表示：出现的次数 再次注意grep 找的是包含某一模式的行,而不是完全匹配某一模式的行 位置限定符 字符表示：匹配字符的位置 精确查找 1$ egrep '^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$' textfile 特殊字符​ Sed 流编辑器(Stream Editor) sed 意为流编辑器(Stream Editor),在Shell脚本和Makefile中作为过滤器使用非常普遍 把前一个程序的输出引入sed的输入，经过一系列编辑命令转换为另一种格式输出 sed命令行的基本格式 12sed option 'script' file1 file2 ... sed option -f scriptfile file1 file2 ... 命令行参数可以一次传入多个文件,sed 会依次处理 option : “-n”,这种用法相当于grep 命令，查找出相同的并打印 ‘script’：sed命令 scriptfile ：将sed命令写成脚本文件，然后用-f参数指定 常用的sed命令 使用p 命令需要注意,sed是把待处理文件的内容连同处理结果一起输出到标准输出的 sed 命令 不会修改原文件：删除命令只表示某些行不打印输出，而不是从原文件中删去。 修改原文件：查找替换命令时,可以把匹配pattern1 的字符串复制到pattern2中 awk sed 以行为单位处理文件,awk 比sed强的地方在于不仅能以行为单位还能以列为单位处理文件。 awk缺省的行分隔符是换行,缺省的列分隔符是连续的空格和Tab]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[system_process]]></title>
    <url>%2F2019%2F04%2F22%2Fsystem-process%2F</url>
    <content type="text"><![CDATA[System Process process：分为子进程和父进程； exec：子进程执行代码时，调用的函数 父进程和子进程的通信：pipe 模式 Process 每个进程：在内核中都有一个进程控制块(PCB Process control block)来维护进程相关的信息 Linux内核的进程控制块是task_struct结构体 结构体包含的信息 fork and exec fork 和exec 是本章要介绍的两个重要的系统调用。 fork : 根据一个现有的进程复制出一个新进程 父进程：parent process 子进程：child process exec : 在Shell下输入命令（终端）可以运行一个程序 Shell进程在读取用户输入的命令之后会调用fork 复制出一个新的Shell进程 然后新的Shell进程调用exec 执行新的程序。 父进程和子进程 子进程的PCB是根据父进程复制而来的,所以其中的umask 掩码也和父进程一样。 父进程在创建子进程时会复制一份环境变量给子进程,但此后二者的环境变量互不影响。 环境变量 exec 系统调用 exec 系统调用执行新程序时会把命令行参数和环境变量表传递给main 函数 和命令行参数argv类似,环境变量表也是一组字符串 全局变量 environ libc 中定义的全局变量environ指向环境变量表, environ 没有包含在任何头文件中,所以在使用时要用extern声明。 12345extern char **environ;int i;for(i=0; environ[i]!=NULL; i++) printf("%s\n", environ[i]); // 打印出环境变量return 0; 环境变量 ,环境变量字符串都是name=value 这样的形式, name 由大写字母加下划线组成，叫做环境变量 value：,value 的部分则是环境变量的值。 环境变量值含义 PATH 1$ echo $PATH // 查看环境变量的值: $xxx SHELL : 它的值通常是/bin/bash 。 gentenv 函数 查找某一个环境变量的值它对应的value ； sentenv 函数 修改环境变量可以用以下函数 进程控制fork 函数 pid = fork() 调用的返回结果 调用过程 父进程和子进程的PCB信息相同,用户态代码和数据也相同； 现在有两个一模一样的进程看起来都调用了fork 进入内核等待从内核返回，返回的先后顺序取决于内核的调度算法 fork函数 fork 函数的特点概括起来就是“调用一次,返回两次”,在父进程中调用一次,在父进程和子进程中各返回一次。 子进程中fork 的返回值是0,而父进程中fork 的返回值则是子进程的id gdb调试 gdb只能跟踪一个进程(默认是跟踪父进程)，而不能同时跟踪多个进程， 但可以设置gdb 在fork 之后跟踪父进程还是子进程 1$ (gdb) set follow-fork-mode child // gdb 跟踪子进程 exec 函数 子进程如何执行程序 用fork 创建子进程后执行的是和父进程相同的程序，子进程往往要调用一种exec 函数以执行另一个程序。 调用exec 并不创建新进程，以调用exec 前后该进程的id并未改变。 exec 函数族 如果调用出错则返回-1，所以exec 函数只有出错的返回值而没有成功的返回值。 不带字母p(表示path)的exec函数第一个参数必须是程序的相对路径或绝对路径 1/bin/ls or ./a.out 不能是 ls or a.out 于带字母p的函数: 如果参数中包含 / ，则将其视为路径名。 否则视为不带路径的程序名，在PATH环境变量的目录列表中搜索这个程序。 带有字母l(表示list)的exec函数 要求将新程序的每个命令行参数都当作一个参数传给它 命令行参数的个数是可变的 对于带有字母v(表示vector)的函数 则应该先构造一个指向各参数的指针数组,然后将该数组的首地址当作参数传给它,数组中的最后一个指针也应该是NULL 就像main 函数的argv参数或者环境变量表一样。 对于以e(表示environment)结尾的exec 函数 可以把一份新的环境变量表传给它,其他exec 函数仍使用当前的环境变量表执行新程序。 事实上,只有execve是真正的系统调用,其它五个函数最终都调用execve man 2 execve upper 函数 转换小写为大些 函数实现 123while((ch = getchar()) != EOF) &#123; putchar(toupper(ch)); &#125; she’ll的重定向功能 简单的标准输入输出重定向(&lt;和&gt;) 1234$ cat file.txtthis is the file, file.txt, it is all lower case.$ ./upper &lt; file.txtTHIS IS THE FILE, FILE.TXT, IT IS ALL LOWER CASE. wait and waitpid 函数 彻底清除进程 一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存； 内核在其中保存了一些关于进程是否正确退出 Shell是它的父进程,当它终止时Shell调用wait 或waitpid 得到它的退出状态同时彻底清除掉这个进程。 僵尸(Zombie)进程 如果一个进程已经终止,但是它的父进程尚未调用wait 或waitpid对它进行清理 自动调用函数，除非自己写函数进行查看。 12$ ps u // 查看进程状态STAT 为z时 -- 僵尸进程的状态 清除僵尸进程 调用函数 进程间通信IPC InterProcess Communication 进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到。 进程之间要交换数据必须通过内核，进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走。 Pipe 管道 函数 12#include &lt;unistd.h&gt;int pipe(int filedes[2]); 数组filedes[0] 指向管道的读端，filedes[1] 指向管道的写端(很好记,就像0是标准输入1是标准输出一样)。 管道单向通信 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。 父进程关闭管道读端,子进程关闭管道写端。 数据从写端流入从读端流出,这样就实现了进程间通信 管道通信的特殊情况 进程间通信必须通过内核提供的通道，两个进程通过一个管道只能实现单向通信 管道的读写端通过打开的文件描述符来传递； 通过fork 传递文件描述符使两个进程都能访问同一管道,它们才能通信。 其他 IPC 机制]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell_script]]></title>
    <url>%2F2019%2F04%2F22%2Fshell-script%2F</url>
    <content type="text"><![CDATA[Shell Script shell script 编写语法和执行 环境变量：变量值=文件所在的目录; Shell History Shell 用户的命令，用户输入一条命令，Shell就解释执行一条，不需要编译 Batch 批处理的方式，便是she’ll script Unix She’ll 本章只介绍bash 和sh的用法和相关语法,不介绍其它Shell。 切换其他的she’ll Shell 如何执行命令执行 用户在命令行输入命令后，一般情况下Shell会 并 该命令，但是Shell的内建命令例外。 内建命令 – 不创建新的进程 执行内建命令相当于调用Shell进程中的一个函数,并不创建新的进程。 凡是用which 命令查不到程序文件所在位置的命令都是内建命令 1$ man bash-builtins //查询内建命令 执行脚本 注释 用# 表示注释,相当于C语言的//注释 当#！作为开头，表示该脚本使用后面指定的解释器/bin/sh解释执行。 12$ chmod +x script.sh$ ./script.sh Shell会fork 一个子进程并调用exec 执行./script.sh这个程序 exec 系统调用应该把子进程的代码段替换成./script.sh程序的代码段，并从它的_start开始执行。 shript.sh 文本文件 文本文件根本没有代码段和_start函数,怎么办呢? 其实exec 还有另外一种机制： 如果要执行的是一个文本文件，并且第一行用Shebang指定了解释器 则用解释器程序的代码段替换当前进程,并且从解释器的_start开始执行,而这个文本文件被当作命令行参数传给解释器。 12345script.sh #! /bin/sh cd .. ls$ /bin/sh ./script.sh // exec 的另外一种机制： 执行脚本方法 – 创建了一个子进程 123$ ./script.sh ---&gt; $ (cd ..; ls -l)$ sh ./script.sh //cd ..命令改变的是子Shell的PWD ,而不会影响到交互式Shell(也就是不会影响到当前进程) 执行脚本方法 —- 直接在交互式Shell下逐行执行脚本中的命令 但是去掉（），这种方式也不会创建子Shell，而是直接在交互式Shell下逐行执行脚本中的命令。 123$ cd ..; ls -l --&gt; $ source ./script.sh--&gt; $ . ./script.sh 判断是否创建新的进程 建新的进程但执行结束后也会有一个状态码,也可以用特殊变量$?读出。 echo $? 通常也用0表示成功非零表示失败 Shell 语法变量 环境变量 环境变量可以从父进程传给子进程，进程调用 fork() 本地变量 只存在于当前Shell进程 12$ printenv // 显示当前Shell进程的环境变量。$ set //可以显示当前Shell进程中定义的所有变量(包括本地变量和环境变量)和函数。 环境变量是任何进程都有的概念,而本地变量是Shell特有的概念。 Shell 中变量的定义 环境变量、本地变量 ：变量的定义，等号两边都不能有空格 1234$ VARNAME=value // 变量的定义 $ export VARNAME // 用export命令可以把本地变量导出为环境变量 $ export VARNAME=value$ unset VARNAME // 可以删除已定义的环境变量或本地变量。 Shell 中变量的赋值 Shell变量的值都是字符串 12$ echo $SHELL // 查看变量$SHELL 的值$ echo $SHELL abc // 给$SHELL 变量赋值字符串 abc Shell变量不需要先定义后使用,如果对一个没有定义的变量取值,则值为空字符串。 文件名替换 这些用于匹配的字符称为通配符(Wildcard) Globbing所匹配的文件名是由Shell展开的,也就是说在参数还没传给程序之前已经展开 1$ ls /dev/ttyS* //匹配/dev/ttyS的所有文件 命令代换 由反引号括起来的也是一条命令 Shell先执行该命令, 然后将输出结果立刻代换到当前命令行中。 12$ DATE='date'$ echo $DATE --&gt; $DATE=$(date) 算数代换 $(()) $(()) 中的Shell变量取值将转换成整数 $(()) 中只能用+-*/和()运算符,并且只能做整数运算。 12$ VAR=45 // 变量的赋值$ echo $(($VRA +3)) 转义字符 \ \ 在Shell中被用作转义字符,用于去除紧跟其后的单个字符的特殊意义(回车除外) 在 \ 后面的字符取字面值 12$ echo $SHELL --&gt; /bin/bash$ echo \$SHELL --&gt; $SHELL 建立包含特殊字符的文件名 1$ touch \$\ \$\ // 创建一个文件名为“$ $”的文件 单引号 ‘ ‘ 和C语言不一样,Shell脚本中的单引号和双引号一样都是字符串的界定符,而不是字符的界定符 单引号用于保持引号内所有字符的字面值，即使引号内的\和回车也不例外, 1234$ echo '$SHELL' --&gt; $SHELL$ echo 'ABC\(回车) // 单引号需要配对，如果没有配对就输入回车&gt; DE'(再按一次回车结束命令) --&gt; ABC\ DE 双引号 “” 双引号用于保持引号内所有字符的字面值(回车也不例外) 有几种例外的情况，用到的时候在说 Bash 脚本 启动脚本是bash 启动时自动执行的脚本。 用户可以把一些环境变量的设置和alias 、umask 设置放在启动脚本中,这样每次启动Shell时这些设置都自动生效。 bash 在执行启动脚本时是以fork 子Shell方式执行的还是以source方式执行的? 交互登录Shell启动 交互Shell：是指用户在提示符下输命令的Shell而非执行脚本的Shell, 登录Shell：是在输入用户名和密码登录后得到的Shell 1/etc/profile // 用户设置都在这个脚本 Shell 脚本语法条件测试 命令test 或[ 可以测试一个条件是否成立 测试结果为真，Exit Status返回 0, 测试结果为假，Exit Status返回 1 1234$ VAR=2$ test $VAR -gt 1 --&gt; $ [ $VAR -gt 3 ] // 命令和参数要用空格隔开$ echo $? --&gt; $ echo $?0 --&gt; 1 测试命令 基本命令 与或非 作为一种好的Shell编程习惯，应该总是把变量取值放在双引号之中(展开为[ -d Desktop -a “” = ‘abc’ ]): 123456$ unset VAR$ [ -d Desktop -a $VAR = 'abc' ] bash: [: too many arguments$ [ -d Desktop -a "$VAR" = 'abc' ]$ echo $? 1 分支控制 在Shell中用if 、then 、elif 、else 、fi这几条命令实现分支控制 规则 如果两条命令写在同一行则需要用;号隔开，一行只写一条则不需要 要注意命令和各参数之间必须用空格隔开 [ a b ] Exit Status为0(表示真) Shell脚本没有{}括号,所以用fi 表示if 语句块的结束。 “ : “号 1234567#! /bin/shif [ -f /bin/bash ] // 一条命令占一行then echo "/bin/bash is a file"else echo "/bin/bash is NOT a file"fiif :; then echo "always true"; fi // 有分号隔开 :是一个特殊的命令,称为空命令,该命令不做任何事，但Exit Status总是真。 read 的read 命令的作用是等待用户输入一行字符串,将该字符串存到一个Shell变量中。 1read YES_OR_NO Shell还提供了&amp;&amp;和||语法 &amp;&amp;相当于“if…then…”,而 || 相当于“if not…then…” 而上面讲的-a和-o仅用于在测试表达式中的两个条件、 12test "$VAR" -gt 1 -a "$VAR" -lt 3 // -gt 大于； -lt 小于； -a 测试test "$VAR" -gt 1 &amp;&amp; test "$VAR" -lt 3 case/esac case 命令可类比C语言的switch/case 语句,esac 表示case 语句块的结束。 Shell脚本的case 可以匹配字符串和Wildcard 末尾必须以;;结束 执行时找到第一个匹配的分支并执行相应的命令,然后直接跳到esac 之后,不需要像C语言一样用break 跳出。 $1 是一个特殊变量, 123456case $1 in start) echo "" ;; stop) echo "" ;;esac $1 是一个特殊变量,在执行脚本时自动取值为第一个命令行参数,也就是start 命令行参数指定为stop 、reload或restart 可以进入其它分支执行停止服务、重新加载配置文件或重新启动服务的相关命令。 1$ sudo /etc/init.d/apache2 start // 传入start进行执行 for / do / done Shell脚本的for 循环结构和C语言很不一样,它类似于某些编程语言的foreach循环。 1$ for FILENAME in chap?; do mv $FILENAME $FILENAME~; done // 将文件chap 替换成chap~ while/do/done while 的用法和C语言类似。比如一个验证密码的脚本: 1234567#! /bin/shecho "Enter password:" # ""保留字面值read TRY # 读用户输入while [ "$TRY" != "secret" ]; do echo "Sorry, try again" read TRYdone 位置参数和特殊变量 Shell自动赋值的特殊变量 位置参数可以用shift 命令左移 比如shift 3 表示原来的$4 现在变成$1, 原来的$1、$2、$3 丢弃,$0不移动。(不够移动) 不带参数的shift 命令相当于shift 1 函数 规则 Shell中也有函数的概念,但是函数定义中没有返回值也没有参数列表。 函数体的左花括号：{ 和后面的命令之间必须有空格或换行 最后一条命令和右花括号 } 写在同一行，命令末尾必须有“ ; “号 1foo()&#123; echo "Function foo is called";&#125; # 不在同一行就不需要加 函数先定义，后使用； 函数调用，foo 后面不加（） Shell脚本中的函数必须先定义后调用,一般把函数定义都写在脚本的前面,把函数调用和其它命令写在脚本的最后 类似C语言中的main 函数,这才是整个脚本实际开始执行命令的地方 Shell函数没有参数列表并不表示不能传参数, 在函数内同样是用$0 、$1、$2 等变量来提取参数 函数中的位置参数相当于函数的局部变量,改变这些变量并不会影响函数外面的$0、$1 、$2等变量。 如果return后面跟一个数字则表示函数的Exit Status。 Shell 调试方法 调试脚本的选项 1$ sh -x ./script.sh 在脚本开头提供参数 1#! /bin/sh -x 在脚本中用set命令启用或禁用参数 set -x和set +x 分别表示启用和禁用 “-x参数” 这样可以只对脚本中的某一段进行跟踪调试。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Language_test]]></title>
    <url>%2F2019%2F04%2F19%2FLanguage-test%2F</url>
    <content type="text"><![CDATA[语文考试描写方法描写方法 描写方法：是用生动形象的语言把人物或景物具体描绘出来的一种手法。 按内容来分：描写有人物描写和景物描写两种。 人物描写的方法主要有六种，即概括描写、肖像描写、语言描写、行动描写 、心理描写、细节描写； 景物描写则包括静态与动态、客观与主观、反衬与对比三种。 按特征分类有： 白描，所谓“白描”是指抓住事物的主要特征，并以简洁的语言勾画出事物形象的一种写法，鲁迅 先生非常善于使用白描手法，如《藤野先生》中关于藤野先生的一段介绍：“其时进来的是一个黑瘦的先生，八字须，戴着眼镜，挟着一叠大大小小的书。一将书放在讲台上，便用了 缓慢而很有顿挫的声调，向学生介绍自己道：‘我就是叫作藤野严九郎的……。’”语言 简洁，印象深刻。 细描，细描是指对事物的一笔一画的精雕细刻，相对于白描，细描也可以称为工笔，如阿累的《一 面》写鲁迅就比鲁迅写藤野又细一些：“他的面孔黄黑带白，瘦得教人担心，好象大病新愈 的人，但是精神很好，没有一点颓唐的样子。头发约莫一寸长，显然好久没剪了，却一根一 根精神抖擞地直竖着。胡须很打眼，好象浓墨写的隶体‘一字’。”? 表达方式 表达方式：分为叙述、描写、说明、抒情、议论的表达方式的分类解释； 一篇文章可以以一种表达方式为主，兼用其它表达方式； 现在流行的话题作文的要求里也有相关表述——可任选一种表达方式为主并综合运用其它各种表达方式。 综合起来，“表达方式”应当为在用语言、艺术、音乐、行动把思想感情表示出来时所采取的方法和形式。 表现手法 托物言志 写景抒情 叙事抒情 直抒胸臆 顺叙 倒叙 插叙 对比 衬托 卒章显志 象征 衬托 想象 联想 照应 寓情于景 托物言志 反衬 烘托 托物起兴 美景衬哀情 渲染 虚实结合 侧面描写 正面描写 直接抒情 间接抒情等，数量不限 写作手法：写作手法属于艺术表现手法（即：艺术手法和表现手法，也含表达手法（技巧））， 常见的有：夸张，对比，比喻，拟人，悬念，照应，联想，想象，抑扬结合、点面结合、动静结合、叙议结合、情景交融、衬托对比、伏笔照应、托物言志、白描细描、铺垫悬念、正面侧面比喻象征、借古讽今、卒章显志、承上启下、开门见山，烘托、渲染、动静相衬、虚实相生，实写与虚写，托物寓意、咏物抒情等。 表达方式就是常见的叙述、描写、抒情、议论和说明。（其实也属于艺术表现手法）。 修辞手法 常见的修辞方法，高考规定为8种：比喻、比拟、借代、夸张、对偶、排比、设问、反问。 比喻：比喻的结构一般由本体、喻体和比喻词构成。比喻的本体和喻体必须是不同的事物，但相互之间有相似点。运用比喻可以化平淡为生动，化深奥为浅显，化抽象为具体。 比拟：包括拟人和拟物两类。拟人是把物当人来描写，赋予物以人的情感、意志、动作等；拟物是把人当物来描写，或把此物当彼物来描写。运用比拟，可使人或物色彩鲜明，描写生动，蕴含丰富。 借代：用借体代本体。它不直接说出所要表述的人或物，而用上其相关的事物来代替，可用部分代整体，以特征代本体，以专名代泛称等，如《药》中以“花白胡子”代人物，便是以特征代本体。比喻要求本体与喻体有相似点，借代要求借体与本体有相同处。借代可使表达具体形象。 夸张：包括对事物作合情合理的夸大或缩小。鲁迅《药》中写道：“……眼光正像两把刀，刺得老栓缩小了一半。”后一句使用了“缩小”的夸张。夸张要合情合理，其作用是烘托气氛，增强联想，给人启示，增强表达效果。 对偶：俗称“对对子”，诗歌中叫“对仗”。对偶有宽对、严对之别。一般来说，上下两句应字数相等、词性相对、结构相同、意义相关；可以是短语，也可以是句子。有正对、反对、流水对等类型。用对偶，句子整齐，表意凝练，抒情酣畅。 排比：由三个或三个以上结构相同或相似、内容相关、语气一致的短语或句子构成。其作用在加强语气、强调内容、加重感情。 设问：无疑而问，在自问自答中引人注意，启人思考。 反问：也是无疑而问，但答案就在问句中，即用肯定的形式表示否定的意思，用否定的形式表示肯定的意思。有强化语气、强化情感的作用。 修此语句的欣赏 大学 中庸 读后感中庸 中庸的高明之处在于有过之而无不及，是至高的道德境界。以“诚”为贵，诚者自诚也，而道自道也，诚者物之终始，不诚无物，故君子诚之为贵，至诚不息，不息则久。 真诚是多么可贵的品质，只有内心真诚了才能通情达理，懂得通情达理才能明辨是非，学会了明辨是非才能通过现象看本质区别，从而达到中和之效。 诚，天地之道，其为物不贰，则其生物不测，皆承载着万事万物。 和而不流，中立而不倚，要达到中庸之道的精微境界，圣人亦所不能焉，更别说此等普通人了，虽力所不能及也，但臻于至善。 人一能之己百之，人十能之己千之。果真此道矣，虽愚必明，虽柔必强。 别人看一遍的书，我估计要看十遍才看懂，好吧，相信勤能补拙，但愿天道酬勤。 好学近乎知，力行近乎仁，知耻近乎勇。知斯三者，则知所以修身。 大学 《大学》以修身为其核心。为什么说心的力量如此之大，因为心的执念会指引你往“仁”的方向前进，一个人内心的善念大于恶，为人处事待人接物的首要反应都是与善念息息相关，言其行，修身其修心，则其正。君子有诸己，而后求诸人；无诸己，而后非诸人。且慎独矣，务本，本立而道生。 海纳百川，有容乃大； 壁立千仞，无欲则刚。 苟日新，日日新，又日新 重复着的简单，简单重复了不简单，温故而知新，抱着新颖的态度去对待日复一日的的事情，追求更新的境界，便会获得不同的感悟，如果能够做到一天新，就应该保持每天新，新了还要更新，不求最新，只求更新一层，新新如也，故无所不用其极。早起，读书，每每坚持如此～与生活合二为一，成为不可或缺的一部分。 修身，齐家，治国的推己及人的絜矩之道 心正而后身修，身修而后家齐；家齐而后国治；国治而后天下平，层层递进，环环相扣。这正与社会主义核心价值观的本质具有一致性。 富强、民主、文明、和谐； 自由、平等、公正、法治； 爱国、敬业、诚信、友善； 看书是为了能更好地融入于生活，知识最终还是要潜移默化地应用到社会生活中。 史记 在中国这个物华天宝，人杰地灵的泱泱文明古国里，中华文化，源远流长，博大精深，先贤们留给我们浩如烟海的精神财富——古文典籍。其中，满天星辰中，《史记》是最为璀璨，最熠熠生辉的一颗。细细品读完《史记》，可以是人感到3000年前，群雄蜂起，英雄拼搏，帝王称霸的峥嵘岁月。 《史记》为西汉史学家、文学家司马迁所著。记载了上自中国上古传说中的黄帝时代，下至汉武帝元狩元年，共3000多年的历史，全书包括十二本纪、三十世家、七十列传、十表、八书，共一百三十篇，五十二万余字，司马迁以其“究天人之际，通古今之变，成一家之言”的史识，完成了中国第一部，也是最为著名的纪传体通史。 《史记》思想深邃、气势开阔、笔力雄放，对后世史学和文学的发展都产生了深远影响，其首创的纪传体通史方法为历代“正史”开创先河。其丰富的艺术价值被古代的小说、戏剧、传记、文学、散文所传承并不断发展。从鲁迅“史学之绝唱，无韵之离骚”的高度评价中就可看出它对后世的影响。读《史记》，使我认识了四面楚歌中，乌江自刎的项羽；生灵涂炭中，起兵反秦的陈胜吴广；紧急危难中，智勇双全的蔺相如；流亡在外，却终登皇位的重耳……历史风云，世间百态，一次次震撼着我的心灵，其中勾践卧薪尝胆的故事最为引人深思。 公元前494年，吴国进攻越国，越国军队几乎全军覆没，无奈勾践只得屈辱求和，按照吴王的要求。勾践得在吴国服苦役。三年里，他忍辱负重，一心复国。回国后，他又艰苦奋斗，励精图治，与百姓同甘共苦，最终，“苦心人，天不负，三千越甲吞掉吴！” 勾践卧薪尝胆，雪耻灭吴的佳话至今为人们代代相传，它也为我们这些“少年不识愁滋味”的后人多了许思考：生活在当今的竞争大潮中，应居安思危，励精图治，居存思亡，艰苦奋斗；如果不具有忧患意识，不把目光放长远，畏惧困难而贪图安逸，得过且过，那么，他就会被这个社会淘汰，结果只会像吴王一样死路一条！ 困难与挑战虽往往给人以挫折，却能催人奋进，给人以力量，而安逸与保守虽可以暂时保身，但却可以使人堕落而遭淘汰，所以，遇到挫折，就做一只同暴风雨抗击的海燕吧！只有这样，才能见到雨后的晴天！ 作为炎黄子孙的我们是荣幸的，这是一个有着优秀传统的神秘国度，这是一个物华天宝的泱泱大国，这是一个人杰地灵的文明古国。先贤给我们留下了浩如烟海的古文典籍，作为后世子孙的我们在茫茫书海中寻觅古贤人的踪迹，感慨曾经的惊心动魄，思量曾经的纷纷扰扰，而作为华夏儿女的我在品读《史记》之后，也真切地感受到3500多年历史中充塞的豪迈、悲壮与辛酸。不过在“少年不识愁滋味”的同时更体会到了中华文化的博大精深。 阅读《史记》，不是仅仅为了某种知识性的获得，不是为了记住几个烦琐的历史事件和历史人物，而是从中欣赏体验，汲取一种精神养料。当孩子们今后面对困境时，能从忍辱负重的司马迁处获得一种力量，这才是我们教育的最终目的。让学生从小结识这样一些精神大师，并与之交流，掌握一种做人、做学问、看世界的方法，这才是受益终身的东西。按照这一思路，五体中书、表可暂且搁置一旁，其他112篇人物传记，则可以任意选出一篇慢慢品味，或挑自己感兴趣的历史人物事迹来一睹为快，总之，不拘一格，因人而异。 史家之绝唱，无韵之离骚。《史记》会一直流传下去，给更多人以感慨与教育。 儒学 论语《论语》的真谛，就是告诉大家，怎么样才能过上我们心灵所需要的那种快乐的生活。 《论语》终极传递的是一种态度，是一种朴素的、温暖的生活态度。孔夫子正是以此来影响他的弟子。这种变化最终达到了一个境界，叫做“神于天，圣于地”。 这六个字其实是中国人的人格理想：既有一片理想主义的天空，可以自由翱翔，而不妥协于现实世界上很多的规则与障碍；又有脚踏实地的能力，能够在这个大地上去进行他行为的拓展。 孔夫子的这个形象身上，凝聚着他内心传导出来的一种饱和的力量。这种力量就是后来孟子所说的“浩然之气”。 只有当天地之气凝聚在一个人心中的时候，它才能够如此的强大。《论语》的思想精髓就在于把天之大，地之厚的精华融入人的内心，使天、地、人成为一个完美的整体，人的力量因而无比强大。人对自然万物，有一种敬畏，有一种顺应，有一种默契。 这是一种力量，我们如果学会了提取锻造这种力量，我们就能够获得孔夫子那样的心胸。我们看到，孔夫子的态度非常平和，而他的内心却十分庄严。因为其中有一种强大的力量，那是信念的力量。孔夫子是一个特别讲究信念的人。其实，一个人的视力本有两种功能：一个是向外去，无限宽广地拓展世界；另一个是向内来，无限深刻地去发现内心。 我们的眼睛，总是看外界太多，看心灵太少。《论语》的精华之一，就是告诉我们，如何用平和的心态来对待生活中的缺憾与苦难。人首先要能够正确面对人生的遗憾，要在最短的时间内接受下来。不要纠缠在里面，一遍一遍地问天问地，这样只能加重你的苦痛。 第二个态度是，要尽可能地用自己所可以做的事情去弥补这个遗憾。 承认现实生活中的不足之处，并通过自己的努力去弥补这种不足，这就是《论语》告诉我们对待生活缺憾的态度。当一个不幸降临了，最好的办法就是让它尽快过去，这样你才会腾出更多的时间去做更有价值的事情，你才会活得更有效率，更有好心情。而一个人的自信心来自哪里？它来自内心的淡定与坦然。要做到内心强大，一个前提是要看轻身外之物的得与失。 假如一个人真能做到一日“三省吾身”（《论语?学而》），真能“见贤思齐焉，见不贤而内自省也”（《论语?里仁》），就做到了约制。而能够反省到自己的错误并且勇于改正，这就是儒者所倡导的真正的勇敢。 君子因为有心态的平和、安定和勇敢，他的安详舒泰是由内而外的自然流露；小人表现出来的则是故作姿态，骄矜傲人，因为他内心多的是一股躁气，气度上便少了一份安闲。你要想做一个别人愿意和你交流，也可以和你交流的人，最关键的是你要有一个敞亮的心怀。这就是《论语》中所提倡的“坦荡荡”的心境。 君子的力量始自于人格与内心。他的内心完满、富足，先修缮了自我修养，而后表现出来一种从容不迫的风度。一个人反省自己的行为，而能够不后悔、不愧疚，这个标准说低也低，我们每个人都可以做到；说高就是个至高无上的标准，大家想想，要使自己做过的每件事都禁得住推敲，实在又是极不容易的事。所以孔子才把它作为君子的人格标准。 一个人有了一种仁义的大胸怀，他的内心无比仁厚、宽和，所以可以忽略很多细节不计较，可以不纠缠于小的得失。只有这样的人，才能真正做到内心安静、坦然。 我们无法左右外在的世界，只有让内心的选择能力更强大。当我们很明白如何取舍，那么那些烦恼也就没有了，这就是孔夫子所说的“知者不惑”。 那么在今天这个社会，怎样成为一个君子？我想不妨从倡导“恒心”开始。 我们现在这个社会有了多元选择，我们在兴奋、激情的驱使下，在众多选择中摇来摆去，难以决定。这是缺乏“恒心”的表现。君子还有第三个标准，就是“矜而不争，群而不党”（《论语?卫灵公》）。 就是说：君子是合群的，虽然他内心里庄重、庄严不可侵犯，但他在一大群人里头却从来不争。同时，他也决不拉帮结派，谋取私利。君子则胸怀坦荡，因为他坦然无私，所以能够平和，能够以善意跟所有人走到一起。 孔子说：“君子耻其言而过其行。”（《论语?宪问》）这在今天成为一个成语，叫“言过其行”。一个人说的多于他做的，是君子之耻。 无论你的理想是大是小，实现所有理想的基础，在于找到内心的真正感受。一个人内心的感受永远比他外在的业绩更加重要。在今天看来，一个人的发展，最重要的往往不在于终极的理想有多么高远，而在于眼前拥有一个什么样的起点。我们往往不缺乏宏图伟志，而缺少通向那个志愿的一步一步积累起来的切实的道路。 理想和行动的关系，就如同引线和风筝的关系。这个风筝能飞多远，关键在于你手中的线。而这条线，就是你的内心愿望。你的内心越淡定，越从容，你就越会舍弃那些激烈的，宏阔的，张扬的，外在的形式，而尊重安静的，内心的声音。这会使你走到社会角色中的时候，能够不失去自我，能够有担当，能够做到最好。孔子强调一个人的内心修养，决不是放弃对社会的责任，而是为了更好地为社会服务。 “君子居之，何陋之有？”这句话可以从两个角度来理解。第一个角度，是君子有天下使命，不管这个地方是奢华的还是简陋的，对他来讲只是一个外在环境而已；第二个角度，就是君子的内心有一种恒定的能量，他可以使得周边熠熠生辉，繁华似锦，他自己生命里面的气场可以去改变一个简陋的地方。内在的心灵标准衡定你的生命是否开始有了一种清明的内省，并且从容不迫，开始对你做的事情有了一种自信和坚定。 孔子说：“不怨天，不尤人，下学而上达。知我者其天乎？”（《论语?宪问》）皇侃对这段话的解释是：“下学，学人事；上达，达天命。我既学人事，人事有否有泰，故不尤人；上达天命，天命有穷有通，故我不怨天也。”可见，“知天命”关键在于一个“知”字，要能够了解什么是自己的天命。当自己能够客观认识命运中的穷与通，人世间的好与坏，知道这一切都很自然，那么你就能理性把握，平静应对。有一句谚语说得好：两朵云只有在同一高度相遇，才能成雨。 学习《论语》，学习任何经典，所有古圣先贤的经验最终只有一个真谛，就是使我们的生命在这些智慧光芒的照耀下，提升效率，缩短历程，使我们尽早建立一个君子仁爱情怀，能够符合社会道义标准，不论是对自己的心还是对于社会岗位，都有一种无愧的交待。 我想圣贤的意义就在于，他以简约的语言点出人生大道，而后世的子孙或蒙昧地，或自觉地，或痛楚地，或欢欣地，一一去实践，从而形成一个民族的灵魂。 让那种古典的精神力量在现代的规则下圆润地融合成为一种有效的成分，让我们每一个人真正建立起来有效率、有价值的人生，大概这就是《论语》给予我们的终极意义 《论语》是春秋时期孔子的言论辑录，当中蕴涵着丰富的人生哲理。而于丹教授却以她自己方式更通俗地为我们广大群众解读了这本著作，从而使得这本千百年来的著作能够更贴近我们的生活。 于丹教授在她谈《论语》心得时，开篇就讲到：宋代开国宰相赵普曾经标榜说，自己以半部《论语》治天下。可见《论语》在古代社会生活和政治生活中发挥的巨大作用以及古人对《论语》的推崇。于丹教授明确地阐述自己的心得：“《论语》告诉大家的东西，永远是最简单的。《论语》的真谛，就是告诉大家，怎么样才能过上我们心灵所需要的那种快乐的生活”。 于丹教授告诉我们《论语》中对交友有非常明确的标准，谓之，益者三友损者三友。也就是说，好朋友有三种，坏朋友也有三种。这三种好朋友的标准是什么，会给我们的生活事业带来什么样的帮助；而那三种坏朋友又是什么样的，会给我们的人生带来怎样的影响，我们又如何来分辨好朋友和好朋友呢？ 其实人这一生有什么样的朋友直接反映他是一个什么样的为人，好朋友就是一本书，他可以打开整个你的世界，也就是我们经常说的物以类聚人以群分。什么样的人你只要观察他的社交圈子，从这样一个外在环境是可以看到他自己内心价值取向的。那么论语中鼓励交什么样的朋友呢？很简单，孔子说：在这个世界上，益者三友，损者三友；友直、友谅、友多闻，益矣；友偏辟、友善柔、友便妄，损矣。 先说三种好朋友，所谓益者三友就是友直、友谅、友多闻，也就是第一这个朋友为人要正直，要坦荡要刚正不阿，一个人不能有谄媚之色，要有一种朗朗人格，在这个世界上顶天立地，这是一种好朋友。因为他的人格可以反映你的人格，他可以在你怯懦的时候给你勇气，他可以在你犹豫不前的时候给你一种果断，这是一种好朋友。 第二种是友谅，也就是宽容的朋友。其实宽容有的时候是一种美德，他是这个世界上最深沉的美德之一，我们会发现，当我们不小心犯了过错或者对他人造成伤害的时候，有时候过分的苛责还有一种批评，都不如宽容的力量来得恒久。其实有时候最让我们内心受不了的是一个人在忏悔的时候没有得到他人的怨气反而得到淡淡的一种包容，所以有一个好朋友，他会给我们内心增加一种自省的力量；宽容的朋友不会使我们堕落或者更多的放纵自己反而会让我们从他人的内心包容上找到自己的弊病，找到自己的缺失。所以有一个宽容的好朋友，他是一种做人的情怀，他是一种悲悯，他是在这个世界上对于一花一叶、一草一木关怀中所折射出来的光芒，这是第二种好朋友。 第三种叫做友多闻，在先秦那个时代，不像我们有电脑，有这么发达的资讯，有铺天盖地的媒体，那个时候人要想广视听怎么办呢，最简单的一个办法，交个好朋友,让你朋友所读的书，那些间接经验转化成你自己的直接经验系统。当你在这个社会上感到犹豫彷徨有所踌躇的时候，到朋友那里以他的广见博识为你做一个参考，来帮助自己做出选择。所以结交一个多闻的朋友就像翻开一本辞典一样，我们总能从他人的经验里面得到自己的一个借鉴系统，这就是孔夫子所说的三种好朋友，叫友直、友谅、友多闻。 《论语》中的益者三友就是正直的朋友，宽容的朋友，广见博识的朋友，这就是孔老夫子所称道的三种好朋友；那孔老夫子所说的三种坏朋友又是些什么样的人呢？ 什么是友偏辟，就是性情暴躁的朋友。那当然，每一个人的生活不一样遇到的情况也不一样，很有可能遇到一件事，你还迷茫的时候你的朋友先怒了，先告诉你这件事情不能这么做。 第二种叫做友善柔。这个正好反着，这个不是脾气特别暴躁的朋友，是脾气特别优柔寡断的朋友。我们发现，过分优柔寡断其实他在浪费你的生命能源，也可能你要去辞职了，你说有一个机会我要下海或者我要跳槽，你去问朋友，朋友说想想吧，你现在的地方也不错呀，你要是万一走了你什么什么就丢掉了。 至于的三种，所谓友便妄，是最坏的一种朋友。大家都知道佞臣之说，佞，就是那种心怀鬼胎的，有心计的，要以一种不择手段的方法去谋取个人利益的这种小人。他们是真正的小人，是那种心理阴暗的人，但是这种人往往会打扮出来一副善良的面孔。由于他内心有所企图所以他对人的热情比那些没有企图的人可能要高好几十倍，所以你一不小心要是被这种人利用的话，那么你的一生你就给自己套上了枷锁。如果你不付出惨痛的代价，这个朋友是不会放过你的。这其实在考验我们自己的眼光和知人论事的能力。 损者三友，益者三友，它告诉你，在这一辈子里面所做的所有事情，内心是应该以朋友作为一个坐标的，这种标准有可能是防微杜渐的，不见得这个朋友作出多么伤大雅的事情来，哪怕就是一个苗头，他可能就觉得说这个人做我的朋友以后可能是我的危险。 宋代开国宰相赵普曾经标榜说，自己以半部《论语》治天下。可见《论语》在古代社会生活和政治生活中发挥的巨大作用以及古人对《论语》的推崇。 那么，对于我们现代社会，现代人的生活，《论语》还有什么现实意义吗？ 《论语》的真谛，就是告诉大家，怎么样才能过上我们心灵所需要的那种快乐的生活。就是教给我们如何在现代生活中获取心灵快乐，适应日常秩序，找到个人坐标。 《论语》是两千五百多年前，孔子教学和生活中的点点滴滴，被学生片片断断记录下来的语录。这些以课堂笔记为主的记录由他的学生汇集编纂，后来就成了《论语》。 《论语》终极传递的是一种朴素的、温暖的生活态度。大家知道，孔子弟子三千，其中有七十二贤人。孔夫子正是以这种朴素的、温和的生活态度来影响他的弟子，他的弟子都是一粒种子，把那种生活的态度、生活的智慧广为传播。 作文生命 路 中美贸易1.中美贸易战是美国主动挑起、强加于中国的 美国总统特朗普3月22日签署总统备忘录，将对中国进口的商品大规模征收关税，并限制中国企业对美投资并购。这次中美争端，不是中国挑起的，不是中国愿意的，是美国特朗普政府不惜破坏国际规则，强行加到中国身上的。 美国单方面、主动挑起中美贸易战，有人认为是服务于选举需要，有人认为是遏制中国的谋略，动机众说纷纭。但有一点是清楚的：中国无处可退。幻想着绥靖就能换来“和平”，只能是自欺欺人。在利益面前，商人的欲壑永远是无法填满的。 2.中方做好了充分的准备，奉陪到底决非一句空话 从外交部、大使馆，再到商务部的反应和应对，不难看出中方对此贸易战已经做足了功课。从外交到经济，甚至到政治到军事，无论美方采取怎样的举措，中方都准备了相应的预案。 我们对美方打贸易战将奉陪到底决非一句空话，而是有大量实实在在能力的支持。23日，中国商务部公布反制清单，拟对自美进口部分产品加征关税，涉及美对华约30亿美元出口。中国正在研究第二批、第三批清单，比如飞机、芯片领域。 3.挑起贸易战背后是美国对于中国崛起的恐惧 美国之所以费尽心思地针对中国，其目的很明确，就是要限制和打压这个正在崛起的国家——这符合美国作为守成大国的心理，也是其在战争选项之外，必然会选取的手段。 中国通过非战争的方式与守成国家进行磨合，是国际秩序进行调整的一个相对理性的方式，也是一个后发国家必然要经历的过程。我们需要做好这个心理准备。 4.美国拉拢盟友联合向中国施压是一厢情愿 为拉拢盟友一起施压中国，特朗普在当地时间22日批准修正条款，宣布在5月1日前，暂停对澳大利亚、加拿大、欧盟和韩国的进口钢铁产品和铝产品征收高关税。 然而，德国《世界报》等媒体已警告，欧盟如果此次在贸易上向美国“示弱”，特朗普很可能在今后变本加厉，拿欧盟“单独开刀”，到时候欧盟各国只能“吃不了，兜着走”。 可以说，世界多数国家对美国的战略信任度很低，与中国又大都有良好的贸易关系，为了本国利益的最大化，它们决不会给美国当棋子、当枪使，主动关上与中国做生意的大门。换句话说，美国已无领导世界共同遏制中国的号召力，它也欠缺与中国打一场大规模贸易战的统筹力和操控力。 5.美国发起贸易战不仅仅针对中国，是对国际贸易规则的公然践踏 早在3月8号下午，特朗普其实就已经签署了一项法令，除了墨西哥和加拿大被暂时豁免外，对来自所有国家的钢铁和铝制品都征收进口关税。 美国本次主动扣动针对全球的关税计划扳机，可以说是对国际贸易规则的一次公然践踏，是主动损害其自身形象和信誉的自残之举，短期内或许于商业经济有利，但从长远来看，则是美利坚帝国继续陨落的标志。总想着仗着美军的强势，把世界财富往美国聚拢，这种模式注定难以持久。 6.美国贸易战害人终害己，必将付出巨大代价 不少美国媒体分析称，对华贸易战将会导致美国消费者的生活成本增高。日常开销花费比例更大的低收入家庭将受到更大影响。美国大企业也将因贸易战受损巨大。中国后续的反击政策将给这些跨国公司造成沉重打击。 分析人士普遍认为，中国实施反制措施之后，美国的制造业产值和就业、进出口贸易都会随着贸易战激化而进一步受损。有澳大利亚学者模拟发现，如果所有国家都展开报复，美国GDP将下降5.2个百分点，损失高达9332亿美元；如果中国不再资助美国的预算赤字，美国的经济地震将更剧烈。特朗普以为“贸易战是好事”，结果只会适得其反。 7.打贸易战，已让美国站到全世界的对立面 若特朗普政府执意开打贸易战，国际社会都将为这场“战争”进行买单。华盛顿智库布鲁金斯学会的研究显示，如果美国挑起全球小型贸易战，即关税增加10%，则大多数经济体国内生产总值将减少1%至4.5%；如果全球爆发严重贸易战，即关税增加40%，则全球经济将重现“大萧条”。 在美国决定对进口钢铝产品征收高关税后，欧盟、日本等均批评这一行径，并考虑采取反制行动，就连“暂免”征税的墨西哥和加拿大也表示会“居安思危”，做“两手准备”。 8.团结一心，胜利终将属于中国 针对美方发起的“贸易战”，中方会根据美方的动作，有针对性地进行反击，并且最终都会严格地按照国际法的相关规定进行操作，对美方的行为，也将积极地推动国际法律诉讼，用法律来维护中国的国家利益。这将是中方理性反击的底线所在。 当然，若美方疯狂到了超越理性，选择毁灭性的行为，那中国一定会有自己的应对，也必然能够应对。大规模的贸易战会同时伤及中美经济，但也会逼迫中国经济朝着更有利于释放本国潜力的方向转型。中国没有理由在美国的挑衅面前惧战。]]></content>
      <categories>
        <category>lanuage test</category>
      </categories>
      <tags>
        <tag>hust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file_system]]></title>
    <url>%2F2019%2F04%2F18%2Ffile-system%2F</url>
    <content type="text"><![CDATA[file_system 文件系统：目录管理结构 + 数据存储；便于访问和读写 ext2 文件系统磁盘分区划分 磁盘分区 格式化工具：mkfs 对每个分区进行格式化 目的：格式化为某种文件系统，才能存储文件 格式化过程：在磁盘写一些管理存储布局的信息。 文件系统 文件系统中存储的最小单位是块(Block)； Block size 12$ mke2fs -b 1024 / 2048 / 4096 //指定块的大小// 32位的每一页大小是4kb ext2文件系统 总体布局 Boot block : size : 1 kb 启动块是由PC标准规定的,用来存储磁盘分区信息和启动信息,任何文件系统都不能使用启动块。 ext2 文件系统：整个分区划成若干个同样大小的块组(Block Group) super block ： 功能：描述整个分区的文件系统信息,例如块大小、文件系统版本号、上次mount 的时间 损坏：损坏就会丢失整个分区的数据，所以超级块在每个块组的开头都有一份拷贝。 Grope Descriptor Table 功能：由很多块组描述符组成, 块组描述符：存储一个块组的描述信息，一旦块组描述符意外损坏就会丢失整个块组的数据 Block Bitmap size : one block 功能：块位图就是用来描述整个块组中哪些块已用哪些块空闲的,它本身占一个块, 1 表示占用； 0 表示空闲 12$ df // 用df命令统计整个磁盘的已用空间,直接查看block bitmap$ du //用du 命令查看一个较大目录的已用空间就非常慢,要搜遍整个目录的所有文件。 inode bitmap size : one block 功能：中每个bit表示一个inode是否空闲可用。 inode table 功能：存储文件的描述信息 1$ ls -l // 文件信息都保存在iNode中 构成：每个文件都有一个inode； 个块组中的所有inode组成了inode表。 size：一个块组有多少个8KB就分配多少个inode。 也可以近似认为数据块有多少个8KB就分配多少个inode, data block 目录：该目录下的所有文件名和目录名存储在数据块中 注意文件名保存在它所在目录的数据块中 :目录也是一种文件,是一种特殊类型的文件。 设备文件：FIFO和socket等特殊文件没有数据块,设备文件的主设备号和次设备号保存在inode中。 查看指令 home 目录下 1$ ls -l // 为什么各目录的大小都是4096的整数倍 zero 字符设备文件 1$ ls -l /dev // xconsole 文件的类型是p(表示pipe) 是一个FIFO文件,是一块内核缓冲区的标识, 不在磁盘上保存数据,因此没有数据块,文件大小是0。 zero 文件的类型是c，表示字符型设备文件 它代表内核中的一个设备驱动程序,也没有数据块,原本应该写文件大小的地方写了1, 5 这两个数字,表示主设备号和次设备号 访问该文件时,内核根据设备号找到相应的驱动程序 ln 符号链接 123$ touch hello // touch 文件权限 666$ ln -s ./hello halo // 符号链接halo 指向hello；halo文件保存./hello路进名$ ls -l ln 硬链接 12$ ln ./hello hello2$ ls -l hello2和hello 除了文件名不一样之外,别的属性都一模一样 硬链接数：ls -l 第二栏的数字 表示一个文件在文件系统中有几个名字 hello 和hello2是同一个文件在文件系统中的两个名字 硬链接数也保存在inode中 12345$ mkdir a // creat a file$ mkdir a/b // 在目录a 创建 b file$ ls -ld a // 硬链接数 是3$ ls -la a$ ls -la a/b 目录的硬链接 目录的硬链接只能通过 a/b 这种方式创建 用ln命令可以创建目录的符号链接,但不能创建目录的硬链接。 文件系统的实例格式化分区 创建一个1MB文件，并清零 1$ dd if=/dev/zero of=fs count=256 bs=4k dd 命令可以把一个文件的一部分拷贝成另一个文件。 到/dev/zero 是一个特殊的设备文件,它没有磁盘数据块,对它进行读操作传给设备号为1, 5的驱动程序. if和of 参数表示输入文件和输出文件,count 和bs 参数表示拷贝多少次,每次拷多少字节。 格式化并清零 123$ mke2fs fs // 格式化文件$ dumpe2fs fs // 查看这个分区的超级块和块组描述符表中的信息$ od -tx1 -Ax fs // 二进制文件的查看 mount 挂载 123$ sudo mount -o loop fs /mnt$ cd /mnt/$ ls -la 会出现三个目录 “.”表示当前目录, “..”表示上一级目录, lost+found 目录由e2fsck工具使用,如果在检查磁盘时发现错误,就把有错误的块挂在这个目录下 sudo unmount /mnt ：取消挂载 debugfs 工具 123$ debugfs fs // 它提供一个命令行界面,可以对文件系统做各种操作$ debugfs: help //$ debugfs: quit 例如查看信息、恢复数据、修正文件系统中的错误。 数据块寻址 数据块 通过inode中的索引项Blocks[0-14] 索引项一共有15个,从Blocks[0] 到Blocks[14] ,每个索引项占4字节。 索引项Blocks[12] 所指向的块并非数据块,而是称为间接寻址块(Indirect Block) 访问文件中的任意数据 只需要两次读盘操作,一次读inode(也就是读索引项)一次读数据块。 而访问大文件中的数据 则需要最多五次读盘操作:inode、一级间接寻址块、二级间接寻址块、三级间接寻址块、数据块 文件和目标操作的系统文件系统函数 stat stat(2)函数读取文件的inode 然后把inode中的各种文件属性填入一个struct stat 结构体传出给调用者。 access 函数 access(2) 函数检查执行当前进程的用户是否有权限访问某个文件 access函数取出文件inode中的st_mode 字段,比较一下访问权限，0/-1 chmod(2) 和fchmod(2) 函数 改变文件的访问权限,也就是修改inode中的st_mode字段 utime(2) 函数 改变文件的访问时间和修改时间, link(2)函数 创建硬链接,其原理是在目录的数据块中添加一条新记录,其中的inode号字段和原文件相同。 symlink(2) 函数创建一个符号链接,这需要创建一个新的inode,其中st_mode字段的文件类型是符号链接 unlink(2) 函数删除一个链接。 rename(2) 函数 改变文件名,需要修改目录数据块中的文件名记录, VFS (Virtual Filesystem)目录树 不同的磁盘分区、光盘或其它存储设备都有不同的文件系统格式,然而这些文件系统都可以mount 到某个目录下。 用ls命令看起来是一样的,读写操作用起来也都是一样的 VFS Linux 内核在各种不同的文件系统格式之上做了一个抽象层； 使得文件、目录、读写访问等概念成为抽象层的概念 因此各种文件系统看起来用起来都一样,这个抽象层称为虚拟文件系统 内核数据结构 每个进程的process control block 保存着一份文件描述符 已打开的文件在内核中用file 结构体表示,文件描述符表中的指针指向 file struct file struct 维护File Status Flag(file 结构体的成员f_flags) 和当前读写位置(file 结构体的成员f_pos ) f_count：表示引用计数(Reference Count) 例如有fd1和fd2 都引用同一个file 结构体，要close（d1）,close(d2)； 才会释放file struct file_operation 每个file 结构体都指向一个file_operations 结构体,,这个结构体的成员都是函数指针 指向实现各种文件操作的内核函数。 dentry 每个file 结构体都有一个指向dentry结构体的指针,“dentry”是directory entry(目录项)的缩写 为了减少读盘次数,内核缓存了目录的树状结构,称为dentry cache inode 每个dentry结构体都有一个指针指向inode 结构体。 inode 结构体保存着从磁盘inode读上来的信息。 super_block inode 结构体有一个指向super_block结构体的指针 super_block结构体保存着从磁盘分区的超级块读上来的信息, dup and dup2 函数 dup 和dup2 都可用来复制一个现存的文件描述符,使两个文件描述符指向同一个file 结构体。 dup2 12int dup(int oldfd);int dup2(int oldfd, int newfd);]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>file_system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file_and_IO]]></title>
    <url>%2F2019%2F04%2F13%2Ffile-and-IO%2F</url>
    <content type="text"><![CDATA[FIle and IO 本书中库函数和系统函数的区别和联系 库函数：对应的是C的标准库，针对符号的处理和I/O操作 函数操作的区域是：buffer 系统函数：内核提供给应用程序的接口 sys/xxx 函数操作的区域是：内核 本书中讲解的计算机的体系结构：好好学习x86平台 只讲Linux平台的特性，只讲Linux内核的工作原理， 涉及体系结构时只讲x86平台 汇编程序的Hello world 注意在C语言中字符串的末尾隐含有一个’\0’ ，而汇编指示.ascii定义的字符串末尾没有隐含的’\0’ 。 在汇编程序中用”. xxx”可以取出当前地址计数器的值,是一个常量。 C标准I/O库函数与Unbuffered I/O函数 对于C标准I/O库来说，打开的文件由FILE *指针标识； 而对于内核来说，打开的文件由文件描述符标识，文件描述符从open 系统调用获得； Unbuffered I/O 函数 Unbuffered I/O函数是UNIX标准的一部分 在所有支持C的平台上应该都可以用C标准库函数(除了有些平台的C编译器没有完全符合C标准之外) 而只有在UNIX平台上才能使用Unbuffered I/O函数 1#include &lt;unistd.h&gt; Man Page中的 COMFORMING TO部分可以看出来一个函数接口属于哪个平台。 我们知道UNIX的传统是Everything is a file，Unbuffered I/O的函数属于无缓存的函数,也就是直接写到设备。 关系 文件描述符 Linux Kernel 中 task_struct ：维护进程信息，Process Descriptor file_srtuct ：文件描述符表 每个表包含已打开的文件指针 用户程序不能直接访问内核中的文件描述符表,而只能使用文件描述符表的索引(即0、1、2、3这些数字),这些索引就称为文件描述符(File Descriptor) Open and CloseOpen 函数flags参数 open的flags参数 O_CREAT: 若此文件不存在则创建它。使用此选项时需要提供第三个参数mode ,表示该文件的访问权限。 O_TRUNC: 如果文件已存在,并且以只写或可读可写方式打开,则将其长度截断(Truncate)为0字节。 open and fopen 区别 创建新的文件，和文件追加内容那块有区别； open函数 mode参数 文件的权限 文件的权限由open 的mode参数和当前进程的umask 掩码共同决定。 几个权限值 Shell进程的umask 12$ umask // 权限值是 0022 //umask 掩码：就是取umask的反码 touch file 12$ touch file // 用touch 命令创建一个文件时,创建权限是0666$ ls -l file // 看到文件是 -rw; 而touch 进程继承了Shell进程的umask 掩码,所以最终的文件权限是0666 &amp; ~022=0644。 gcc 12$ gcc main.c // 用gcc 编译生成一个可执行文件时,创建权限是0777,$ ls -l a.out // 文件的权限 -rwxr 同样道理,用gcc 编译生成一个可执行文件时,创建权限是0777,而最终的文件权限是0777&amp;~022=0755。 close 由open 返回的文件描述符一定是该进程尚未使用的最小描述符。 可以利用这一点在标准输入、标准输出或标准错误输出上打开一个新文件,实现重定向的功能。 read and writeread and fgetc 读数据的过程 read : 读上来的数据保存在缓冲区buf 中，同时文件的当前读写位置向后移； 没有取完的数据继续保存在buf中 读写位置：记录在内核中的。 fgetc: getc 有可能从内核中预读1024个字节到I/O缓冲区中,再返回第一个字节, 这时该文件在内核中记录的读写位置是1024 而在FILE 结构体中记录的读写位置是1。 是ssize_t,表示有符号的size_t read and write 中的count 面对读写常规文件时：read / write 的返回值通常等于请求写的字节数count 面对的是终端设备Terminal：通常以行为单位,读到换行符就返回，不一定是count。 面对网络读写时：有不同的传输协议，不一定是count 阻塞 Block 现象 阻塞状态：针对终端设备和网络读取 Sleeping：当进程调用一个阻塞的系统函数时，该进程被置于睡眠(Sleep)状态，这时内核调度其它进程运行，直到该进程等待的事件发生。 Running： 正在都被调度执行： 就绪状态 已经准备好，处于排队中，随时准备被调用 按照优先级进行调用 Unblocking 如果在open 一个设备时指定了O_NONBLOCK 标志,read / write 就不会阻塞。 轮询（Poll）方式 表示本来应该阻塞在这里(would block,虚拟语气),事实上并没有阻塞而是直接返回错误,调用者应该试着再读一次(again)。 调用者只是查询一下，而不是阻塞在这里死等，这样可以同时监视多个设备: 通过 goto 无条件跳转函数，实现非阻塞读终端 lseek 移动当前的读写位置 lseek 和 标准I/O库的fseek 函数类似,可以移动当前读写位置(或者叫偏移量)。 参数offset和whence的含义和fseek 函数完全相同。只不过第一个参数换成了文件描述符。 fseek 成功时返回0失败时返回-1,要返回当前偏移量需调用ftell 而lseek 成功时返回当前偏移量失败时返回-1。 Fcntl 对已经打开的文件，重新设定其属性，新设置读、写、追加、非阻塞等标志 （file status flag） 优点：不用重新打开文件 像标准输入 stdin stdout stderr；这些标准输出文件，在开始运行的时候便已经打开； 或者其他已经打开的文件，需要重新设定其属性 Shell 的重定向功能 利用Shell的重定向功能在该描述符上打开文件 open打开的文件，返回的文件描述符一定是该进程尚未使用的最小描述符； 以利用这一点在标准输入、标准输出或标准错误输出上打开一个新文件,实现重定向的功能。 shell重定向语法 如果在&lt;、&gt;、&gt;&gt;、&lt;&gt;前面添一个数字，该数字就表示在哪个文件描述符上打开文件, file_and_io/fcntl/cmd_flag.c 123$ ./cmd.flag 0 &lt; /dev/tty //时将它的标准输入重定向到/dev/tty ,并且是只读的。// argv[0] 是"./a.out",argv[1] 是"0"//重定向由Shell解释,在启动程序时已经生效,程序在运行时并不知道标准输入被重定向了。 123$ ./a.out 1 &gt; temp.foo // 标准输出，重定向到文件temp.foo$ ./a.out 2 2&gt;&gt;temp.foo //,注意2和&gt;&gt;之间不能有空格,否则2就被解释成命令行参数了。$ ./a.out 5 5&lt;&gt;temp.foo /dev/null 设备文件 /dev/null 设备文件只有一个作用,往它里面写任何数据都被直接丢弃。 因此保证了该命令执行时屏幕上没有任何输出，既不打印正常信息也不打印错误信息，让命令安静地执行。 这种写法在Shell脚本中很常见。 1$ command &gt; /dev/null 2&gt;&amp;1 //文件描述符数字写在重定向符号右边需要加&amp;号,否则就被解释成文件名，二期不能有空格 ioctl ioctl 用于向设备发控制和配置命令,有些命令也需要读写一些数据,但这些数据是不能用read /write 读写的,称为Out-of-band数据。 read/ write 读写的数据是in-band数据,是I/O操作的主体。 而ioctl 命令传送的是控制信息,其中的数据是辅助的数据。 mmap 映射函数Introduction mmap 可以把磁盘文件的一部分直接映射到内存,这样文件中的位置直接就有对应的内存地址； 对文件的读写可以直接用指针来做而不需要read /write 函数。 strace command 1$ strace ./a.out]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linux system complie</category>
      </categories>
      <tags>
        <tag>file and IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三极管和场效应管的工作原理]]></title>
    <url>%2F2019%2F04%2F08%2FAudionNPN%2F</url>
    <content type="text"><![CDATA[三极管的详解 Reference 电荷的判断 正电荷是不会移动的，只有负电荷（电子）才能移动； 负电荷的移动，形成了电势差； 电势差的产生，形成了电流，电流是正电荷。 特性 核心是“PN”结； 电流的流向是PN时，才是正向偏执 发射区：发射的是电子 溶度高的话，利于渗透 集电结面积大：集电区与发射区为同一性质的掺杂半导体，但集电区的掺杂浓度要低，面积要大，便于收集电子。 发射区高掺杂：为了便于发射结发射电子，发射区半导体掺浓度高于基区的掺杂浓度，且发射结的面积较小; 三极管不是两个PN结的间单拼凑，两个二极管是组成不了一个三极管的！ 电流控制原理 电流里面的是正离子，电子往相反方向流。 外加电压使发射结正向偏置，集电结反向偏置。 集/基/射电流关系： IE = IB + IC IC = β * IB 如果 IB = 0, 那么 IE = IC = 0 电压控制原理 集-射极电压UCE为某特定值时，基极电流IB与基-射电压UBE的关系曲线。 UBE&lt;UBER时，三极管高绝缘，UBE&gt;UBER时，三极管才会启动； UCE增大，特性曲线右移，但当UCE&gt;1.0V后，特性曲线几乎不再移动。 输出特性 基极电流IB一定时，集极IC与集-射电压UCE之间的关系曲线，是一组曲线。 当IB=0时, IC→0 ,称为三极管处于截止状态，相当于开关断开; 当IB&gt;0时, IB轻微的变化,会在上以几十甚至百多倍放大表现出来; 当IB很大时，IC变得很大，不能继续随IB的增大而增大，三极管失去放大功能，表现为开关导通。 三极管核心功能 放大功能：小电流微量变化，在大电流上放大表现出来。 开关功能：以小电流控制大电流的通断。 NPN and PNP区别 NPN 是用 B→E 的电流（IB）控制 C→E 的电流（IC），E极电位最低，且正常放大时通常C极电位最高，即 VC &gt; VB &gt; VE PNP 是用 E→B 的电流（IB）控制 E→C 的电流（IC），E极电位最高，且正常放大时通常C极电位最低，即 VC &lt; VB &lt; VE 电路接法 NPN的接法 PNP的接法 元器件的代表 PNP : s8550 NPN: s8050 场效应管 Reference Reference2 场效应管的划分 场效应管(FET)是场效应晶体管(field-effect transistor)的简称，即：在一定结构的半导体器件上，加上二氧化硅和金属，形成栅极。 所有的FET都有栅极g(gate)、漏极d(drain)、源极s(source)三个极 分别对应双极性晶体管的基极b(base)、集电极c(collector)和发射极e(emitter)。 P区与N区交界面形成耗尽层，而漏极d与源极s间的非耗尽层区域称为导电沟道。 MOS管工作原理–MOS管的特性MOS管的输入、输出特性 对于共源极接法的电路，源极和衬底之间被二氧化硅绝缘层隔离，所以栅极电流为0。 MOS管的导通特性 MOS管作为开关元件，同样是工作在截止或导通两种状态。由于MOS管是电压控制元件，所以主要由栅源电压uGS决定其工作状态。 NMOS的特性 Vgs大于一定的值就会导通，适合用于源极接地时的情况(低端驱动)，只要栅极电压达到4V或10V就可以了。 PMOS的特性， Vgs小于一定的值就会导通，适合用于源极接VCC时的情况(高端驱动)。 但是，虽然PMOS可以很方便地用作高端驱动，但由于导通电阻大，价格贵，替换种类少等原因，在高端驱动中，通常还是使用NMOS。 场效应管的工作原理 结型场效应管(JFET)因有两个PN结而得名 绝缘栅型场效应管(JGFET)则因栅极与其它电极完全绝缘而得名 为绝缘栅型场效应管的栅极为金属铝，故又称为MOS管。 分成耗尽型与增强型 耗尽型：当栅压为零时有较大漏极电流的称为 增强型：当栅压为零，漏极电流也为零，必须再加一定的栅压之后才有漏极电流的称为。 无论是结型场效应管还是绝缘栅型场效应管，无论是耗尽型场效应管或是增强型场效应管，都可分为N沟道和P沟道，其结构分别如下图所示 如何进行区分 结型场效应管–结型 N沟道结型场效应管—-结型 为保证能正常工作，应在其栅-源之间加负向电压(即uGS&lt;0),以保证耗尽层承受反向电压; 在漏-源之间加正向电压uDS，以形成漏极电流。 栅-源之间负向电压越大，PN结交界面所形成的耗尽区就越厚，导电沟道越窄，沟道电阻变大，漏极电流iD越小; 若栅-源之间负向电压越小，则耗尽区就越薄，导电沟道越宽，沟道电阻变小，漏极电流iD越大。 因此实现了场效应管的栅-源间负向电压对沟道电流的控制。 P沟道结型场效应管： 其栅-源之间加正向电压(即uGS&gt;0)才能保证其能能正常工作。 结型场效应管– 绝缘栅型 N沟道耗尽型MOS管为例+]]></content>
      <categories>
        <category>三极管</category>
        <category>场效应管</category>
      </categories>
      <tags>
        <tag>NPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Man Page]]></title>
    <url>%2F2019%2F04%2F02%2FManpage%2F</url>
    <content type="text"><![CDATA[LinuxC ManPage Man Page 是linux自带的文档 manual 手册 Command 列出某一个章节 12man passwd //这就是第一页man 5 passwd //指定第五页 列出可查询的章节 1234567man -aw printf //查询文档在第几章节result： /usr/share/man/man1/printf.1.gz // 在第一章和第三章 /usr/share/man/man3/printf.3.gzselect man 1 printf man 3 printf 一次性查阅所有章节 1man -a printf // 显示所有章节 看完第一章后，按下q退出，会让你选择继续查看还是退出 按下Enter便能继续阅读下一章节 在manual中搜索关键字 1man -k printf // 显示printf所在的章节 根据得到的结果，查询对应的章节 搜索函数名中含有其他关键字 1man -k "^s.*printf" //搜索含有s的printf 通过浏览器查看 12man -Hfirefox printf // 浏览器打开sudo apt-get install groff // Cannot open firefox 优化界面 给字体分配颜色：这个得加 1234567891011vi ~/.bashrc // 打开文件add code # Less Colors for Man Pages export LESS_TERMCAP_mb=$'\E[01;31m' # begin blinking export LESS_TERMCAP_md=$'\E[01;38;5;74m' # begin bold export LESS_TERMCAP_me=$'\E[0m' # end mode export LESS_TERMCAP_se=$'\E[0m' # end standout-mode export LESS_TERMCAP_so=$'\E[38;5;246m' # begin standout-mode - info box export LESS_TERMCAP_ue=$'\E[0m' # end underline export LESS_TERMCAP_us=$'\E[04;38;5;146m' # begin underline source ~/.bashrc]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Man Page</category>
      </categories>
      <tags>
        <tag>Man Page</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Standard Lib]]></title>
    <url>%2F2019%2F04%2F02%2FCStandardLib%2F</url>
    <content type="text"><![CDATA[C Standard Lib C标准主要由两部分组成，一部分描述C的语法，一部分描述C标准库。 平台支持C语言 实现C编译器 实现C标准库 函数文件的命名，以.c 为准 在 ’.c‘ file：void * 类型的数，做右值的时候会自动进行转换； 在 ’ .cpp ‘file：不会自动的转换 POSIX 是Unix系统的标准，不属于C标准库 String Funcation 程序按功能划分可分为数值运算、符号处理和I/O操作三类, 符号操作：由各种基本的字符串操作组成。 字符串的初始化、取长度、拷贝、连接、比较、搜索等基本操作。 字符串的操作中：’ \0 ‘ 的操作要注意。操作可能是including，excluding size_t size_t 是一种类型，表示的是操作系统的位数，32位和64位 memset 初始化字符串 12void *memset(void *s, int c, size_t n);// 将指针s指向的存储空间的 n 位数，用 c 代替；memset(buf, 0, 10); //将buf的前10位用0初始化 strlen 1size_t strlen(const char* s); 计算字符串长度 注意数组的越界 拷贝字符串 SCLib/memcpy strcpy and strncpy 拷贝以 ‘ \0 ‘结尾的字符串； 属于字符类型 以str开头的函数处理以’\0’ 结尾的字符串; 12char *strcpy(char *dest, const char *src);char *strncpy(char *dest, const char *src, size_t n); strn 不需要以 ‘\0’结尾，当source的前n个字节没有NULL（’\0’），那么dest不需要以NULL结尾 当source的字节数，少于n个字节，那么dest将填充足够的NULL（’\0’）直至满足n个字节 memcpy and memmove mem*：针对的是memory，存储单元 根据src指向的内存地址，拷贝n个字节（而不一定是字符串） 而以mem开头的函数则不关心’\0’ 字符,或者说这些函数并不把参数当字符串看待,因此参数的指针类型是void 而非char 12void *memcpy(void *dest, const void *src, size_t n);void *memmove(void *dest, const void *src, size_t n); memcpy的两个参数src 和dest 所指的内存区间如果重叠，则无法正常拷贝。 可以借助一个临时的缓存区，进行拷贝 在32位的x86平台上,每次拷贝1个字节需要一条指令,每次拷贝4个字节也只需要一条指令,memcpy函数的实现尽可能4个字节4个字节地拷贝,因而得到上述结果。 连接字符串 strcat and strncat 以str开头的函数处理以’\0’ 结尾的字符串; strncat strncat总是保证dest 缓冲区以’\0’ 结尾，这一点又和strncpy不同，strncpy并不保证dest缓冲区以’\0’结尾 dest至少含有的字节数：strlen(dest)+n+1个 比较字符串 memcmp memcmp - compare memory areas mem*：针对的是memory，存储单元 12int memcmp(const void *s1, const void *s2, size_t n);return 负值，0， 正值 memcmp从前到后逐个比较缓冲区s1和s2的前n个字节(不管里面有没有’\0’ ) strcmp and strncmp strcmp把s1和s2 当字符串比较,在其中一个字符串中遇到’\0’ 时结束; strncmp 遇到’\0’ 或者 比较完了n个字节，就结束。 搜索字符串 笔试估计会考，还有相应的算法。【算法导论】 strchr and strrchr 123locate character in stringchar *strchr(const char *s, int c); // 从前到后，找到第一次出现的C就返回char *strrchr(const char *s, int c);// 从后到前， 如果没有找到就返回 NULL 疑问：为什么character 是int型的而不是char类型？ strstr 12char *strstr(const char *haystack, const char *needle);返回值:如果找到子串,返回值指向子串的开头,如果找不到就返回NULL 堆haystack中找一根针needle ，按中文的说法叫大海捞针，显然haystack 是长字符串，needle 是要找的子串。 分割字符串 分隔符：符号是‘ ：’； 在编写Makefile 文件的时候； clean : 文件的编写，就需要加分隔符 分割符 很多文件格式或协议格式中会规定一些分隔符或者叫界定符(Delimiter),例如/etc/passwd文件中保存着系统的帐号信息。 strtok C标准库提供的strtok函数可以很方便地完成分割字符串的操作。 tok是Token的缩写,分割出来的每一段字符串称为一个Token 123#include &lt;string.h&gt;char *strtok(char *str, const char *delim);char *strtok_r(char *str, const char *delim, char **saveptr); 每次都是改写的str 第一次调用时把字符串传给strtok,以后每次调用时第一个参数只要传NULL 就可以了,strtok函数自己会记住上次处理到字符串的什么位置(显然这是通过strtok 函数中的一个静态指针变量记住的)。 标准I/O库函数文件的基本概念 用C标准库对文件进行读写操作,对文件的读写也属于I/O操作的一种 十六进制数，十六进制的ASCII值 12十六进制数 十六进制的ASCII值 5 32 ASCII 码值 0 - 127 : 128位的ASCII码值 有33位不能显示出来，只能显示95个 文本文件（Text file） Text file –&gt; Source file 文本文件是用来保存字符的 文件中的字节都是字符的某种编码(例如ASCII或UTF-8) 编写和查看 vi : 进行编辑 cat : 查看里面的内容 查看text file的长度 1$ ls -l textfile /* 查看文本的长度，vi会自动在文件末尾加一个换行符 */ od Command -tx1：将文件中的字节以十六进制码的形式列出来 -tc : 将文件中的ASCII码以字符形式列出来。 -Ax : 要求以十六进制显示文件中的地址。（类似于hexdump） 1234$ od -tx1 -tc -Ax textfile 000000 35 36 37 38 0a // 十六进制的ASCII码值 5 6 7 8 \n // 十六进制数000005 // 地址 123hexdump textfile 0000000 3635 3837 000a 0000005 二进制文件 Binary file Binary file 目标文件，库文件和可执行文件 有些字节表示各Section和Segment在文件中的位置,有些字节表示各Segment的加载地址。 查看 hexdump command :进行查看 fopen / fclose fopen : 就是在操作系统中分配一些资源用于保存该文件的状态信息，并得到该文件的标识。 fclose: man fopen 1FILE *fopen(const char *path, const char *mode); 指针类型：FILE * 返回值做判断：在代码中对返回值进行判断 12345if ( (fp = fopen("/tmp/file1", "r")) == NULL) /*绝对路径*/&#123; printf("error open file /tmp/file1!\n"); exit(1);&#125; mode “a” : 只能在文件末尾追加数据,如果文件不存在则创建 “a+”: 允许读和追加数据,如果文件不存在则创建 “w”: 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节再重新写,也就是替换掉原来的文件内容 “r”: 只读,文件必须已存在 路径的介绍 Shell 提示符显示当前目录 12~$ //当前工作目录是主目录/etc$ //当前工作目录是 /etc 绝对路径：不同进程下的工作目录 1fp = fopen("/tmp/file1", "w") 相对路径： 相对路径是相对于当前工作目录(Current Working Directory)的路径 每个进程都有自己的当前工作目录 Shell进程的当前工作目录可以用pwd 命令查看 123fp = fopen("file.a", "r"); //在当前工作目录下打开文件fp = fopen("../a.out", "r"); //只读打开当前工作目录下上一层目录下的文件fp = fopen("Desktop/file3", "w"); //当前工作目录下的子目录Desktop stdin/stdout/stderr 终端操作：人机交互的设备，此时的I/O是对设备的操作。 设备和文件占时不做区分 I/O设备的操作，printf 和scanf 不用打开就可以操作设备 c程序启动是会自动把终端设备打开三次, 分别赋给三个FILE *指针stdin 、stdout和stderr ， 这三个文件指针是libc 中定义的全局变量, 函数的操作 printf：向stdout中写； scanf：从stdin中读 stderr：打印标准错误，所以fopen的标准错误代码 12345if ( (fp = fopen("/tmp/file1", "r")) == NULL) /*绝对路径*/&#123; printf("error open file /tmp/file1!\n"); exit(1);&#125; errno / perror errno 很多系统函数在错误返回时将错误原因记录在libc 定义的全局变量errno 中 每个错误原因对因一个错误码。 所有错误码都是正整数。 perror 对错误码errno的整数进行解读：解释成字符串再打印 可以添加附加信息：方便定位错误 123456789int main(void)&#123; FILE *fp = fopen("abcde", "r"); if (fp == NULL) &#123; perror("Open file abcde"); // 添加的额外信息Open file abcde： exit(1); &#125; return 0;&#125; strerror strerror 函数可以根据错误号返回错误原因字符串。 以后学线程库时我们会看到,有些函数的错误码并不保存在errno 中,而是通过返回值返回。就不能调用perror打印错误原因了，这时strerror就需要使用strerror 1fputs(strerror(n), stderr); 以字节为单位的I/O函数 CSlib/fgetc.c fgetc(stdin) 从指定的文件中读一个字节 fgetc 读到文件末尾时返回EOF ，只是用这个返回值表示已读到文件末尾,并不是说每个文件末尾都有一个字节是EOF (根据上面的分析,EOF并不是一个字节)。 getchar 从标准输入读一个字节 调用getchar() 相当于调用fgetc(stdin) 1234#include &lt;stdio.h&gt;int fgetc(FILE *stream);int getchar(void);返回值:成功返回读到的字节,出错或者读到文件末尾时返回EOF fputs 向指定的文件写一个字节 每调用一次fputc ,读写位置向后移动一个字节,因此可以连续多次调用fputc 函数依次写入多个字节 putchar(c) 向标准输出写入一个字节 调用putchar，相当于调用fputc( c, stdout ) 从终端输入时有两种方法表示文件结束 直接输入 ctrl + D 利用Shell 的Heredoc语法 &lt;&lt;END 表示从下一行开始是标准输入,直到某一行开头出现END时结束。 &lt;&lt; 后面的结束符可以任意指定,不一定得是END ,只要和输入的内容能区分开就行。 123456$ ./a.out &lt;&lt;END&gt; hello&gt; hey&gt; ENDhellohey 操作读写位置的函数 三个函数 1234#include &lt;stdio.h&gt;int fseek(FILE *stream, long offset, int whence); //返回值:成功返回0,出错返回-1并设置errnolong ftell(FILE *stream); //返回值:成功返回当前读写位置,出错返回-1并设置errnovoid rewind(FILE *stream); //把读写位置移到文件开头 fseek(FILE *stream, long offset, int whence) offset ：可正可负 负值表示向前(向文件开头的方向)移动,正值表示向后(向文件末尾的方向)移动, 如果向前移动的字节数超过了文件开头则出错返回 如果向后移动的字节数超过了文件末尾,再次写入时将增大文件尺寸,,从原来的文件末尾到fseek 移动之后的读写位置之间的字节都是0. whence ：何时 SEEK_SET：从文件开头移动offset个字节 SEEK_CUR（current）从当前位置移动offset个字节 SEEK_END 从文件末尾移动offset个字节 以字符串位单位的I/O函数 fgets : 从指定的文件中读一行字符到调用者提供的缓冲区中供的缓冲区中。 1char *fgets(char *s, int size, FILE *stream); // s--指向buffer;size--读取长度；stream--原始文件 该函数从stream 所指的文件中读取以’\n’结尾的一行(包括’\n’ 在内)存到缓冲区s中 如果文件中的一行太长,fgets 从文件中读了size-1个字符还没有读到’\n’ 则将size-1个字符和‘\0’添加到buffer，剩下的下一次调用 并且在该行末尾添加一个’\0’ ，组成完整的字符串。 fgets 对于 ‘\n’ 和 ‘\0’ 对于fgets 来说,’\n’是一个特别的字符,而’\0’ 并无任何特别之处 如果读到’\0’ 就当作普通字符读入。 fgets 只适合读文本文件而不适合读二进制文件, fputs : 向指定的文件写入一个字符串,puts向标准输出写入一个字符串。 12int fputs(const char *s, FILE *stream);int puts(const char *s); 缓冲区s中保存的是以’\0’ 结尾的字符串，fputs 将该字符串写入文件stream，但并不写入结尾的’\0’； fputs 并不关心的字符串中的’\n’ 字符,字符串中可以有’\n’也可没有’\n’ puts将字符串s写到标准输出(不包括结尾的’\0’ ),然后自动写一个’\n’ 到标准输出。 以记录为单位的I/O文件 /CSlib/fread_and_fwrite/ fread / fwrite 用于读写记录，这里的记录是指一串固定长度的字节,比如一个int、一个结构体或者一个定长数组。 12345size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE*stream);返回值:读或写的记录数,成功时返回的记录数等于nmemb,出错或读到文件末尾时返回的记录数小于nmemb,也可能返回0 该程序生成的recfile 文件是二进制文件而非文本文件,因为其中不仅保存着字符型数据,还保存着整型数据24和28((在od命令的输出中以八进制显示为030和034) 注意,直接在文件中读写结构体的程序是不可移植的 结果输出不一定相同 因为不同平台的大小端可能不同(因而对整型数据的存储方式不同) ,结构体的填充方式也可能不同(因而同一个结构体所占的字节数可能不同） 格式化的I/O函数 格式化的I/O函数：以特定的格式进行输入和输出 printf and scanf /IO/print/print.c printf 格式化打印到标准输出 关于printf的函数：很多种分类 printf 转换说明的可选项 “%#x ” ：指定输出类型是0x 十六进制 “ %#X ” : 输出大写字符 “-%10d-”： 长度为10，格式化后的内容居左,右边可以留空格。 “ % . d ”：打印输出的%6.4—长度位6，精度位4 “ %hhd ” ：对于整型参数可以指定字长,hh、h 、l 、ll 分别表示char 、short 、long、long long 的字长 “ %p ” : 打印main函数的首地址 “%f ”: double型参数格式化，精度=小数点后6位 “ %e/E ” : 取double型参数格式化为，转化为指数模式 “ %g/G “ : 精度指有效数字，默认是6位有效数字，多余的就抹去 “%%” ： 格式化输出一个 % printf并不知道实际参数的类型，只能按转换说明指出的参数类型从栈帧上取参数， 所以如果实际参数和转换说明的类型不符,结果可能会有些意外。 scanf scanf 从标准输入读字符,按格式化字符串format中的转换说明解释这些字符 转换后赋给后面的参数,后面的参数都是传出参数,因此必须传地址而不能传值。 scanf 用输入的字符去匹配，格式化字符串中的字符和转换说明 如果成功匹配一个转换说明,就给一个参数赋值 或者如果遇到和格式化字符串不匹配的地方就停止。 scanf的转换字符还得注意一点 对于整型参数可以指定字长,有hh 、h、l、ll(也可以写成一个L),含义和printf相同。 但l和L还有一层含义,当转换字符是e、f、g时, 表示赋值参数的类型是float 而非double 这一点跟printf不同,这时前面加上l或L表示double 或long double 型。 scanf 字符转换 scanf(%d, &amp;i); // 传的是地址，不能传值 “%d”：匹配十进制整数(开头可以有负号),赋值参数的类型是int * 。 “% i ”: 匹配整数(开头可以有负号),赋值参数的类型是int * 以0x或0X开头，则匹配十六进制整数 以0开头则匹配八进制整数 “%o , %u, %x”: 匹配无符号八进制、十进制、十六进制整数，赋值参数类型是usigned int * “ %c “ : 匹配一串字符,字符的个数由宽度指定,缺省宽度是1,赋值参数的类型char * 末尾不会添加’\0’ 。 如果输入字符的开头有空白字符,这些空白字符并不被忽略,而是保存到参数中, 要想跳过开头的空白字符,可以在格式化字符串中用一个空格去匹配。 “%s”: 匹配一串非空白字符 从输入字符中的第一个非空白字符开始匹配到下一个空白字符之前,或者匹配到指定的宽度,赋值参数的类型是char *, 莫为自动添加‘\0’ “%e, %f, %g” : 匹配浮点数(开头可以有负号),赋值参数的类型是float * 可以指定double 或long double 的字长。 C标准库的I/O缓存 用户程序调用C标准I/O库函数读写文件或设备， 库函数要通过系统调用把读写请求传给内核 由内核驱动磁盘或设备完成I/O操作 内核写回设备的操作是Flush操作； 库函数是fflush fclose函数在关闭文件之前也会做Flush操作。 分配一个I/O缓冲区以加速读写操作 缓冲区分为三类 printf 标准的输出，分配的是行缓冲； 每次遇到 \n ；换行符，便进行flush操作； 写回内核，输入到设备 数值字符串转换函数 将一串字符中能识别成某种进制的数，转换为int or double 1234#include &lt;stdlib.h&gt;int atoi(const char *nptr); // 把一个字符串开头可以识别成十进制整数的部分转换成int 型,double atof(const char *nptr); // atof 把一个字符串开头可以识别成浮点数的部分转换成double型返回值:转换结果 开头没有可识别的进制数，则返回0 strtol and strtod 能控制识别的进制数（8,10,16） 能区分返回值error and 0 123long int strtol(const char *nptr, char **endptr, int base);double strtod(const char *nptr, char **endptr);返回值:转换结果,出错时设置errno 分配内存函数 在堆空间分配内存的函数 calloc 分配nmemb 个元素的内存空间,每个元素占size 字节 calloc负责把这块内存空间用字节0填充,而malloc 并不负责把分配的内存空间清零。 realloc 候用malloc 或calloc分配的内存空间使用了一段时间之后需要改变它的大小 把原内存空间的指针ptr传给realloc,通过参数size 指定新的大小(字节数) realloc返回新内存空间的首地址,并释放原内存空间。 综合练习日志文件中添加记录 获取当前的系统时间需要调用time(2)函数,返回的结果是一个time_t 类型； 其实就是一个大整数，其值表示从UTC(Coordinated Universal Time)时间1970年1月1日00:00:00(称为UNIX系统的Epoch时间)到当前时刻的秒数。 然后调用localtime(3)将time_t所表示的UTC时间转换为本地时间(我们是+8区,比UTC多8个小时)并转成struct tm 类型 该类型的各数据成员分别表示年月日时分秒 调用sleep(3) 函数可以指定程序睡眠多少秒。 INI and XML files INI文件：是Initialization File的缩写，即初始化文件，系统配置文件所采用的存储格式 文件扩展名：配置文件 . ini 格式：由节，键，值组成 节： [ section ] 键 = 值 ：name = value 注释：注解使用分号表示（;）。在分号后面的文字，直到该行结尾都全部为注解。 12345example： ; exp ini file [port] portname=COM4 port=4 XML文件：同样是一个配置文件的格式 两者区别 xml,对于描述复杂的数据结构非常的方便，缺点相对ini使用麻烦一点。 而且因为它有比较严格的格式审查机制，容错性也不是特别好,在手写时容易出现错误。 抛开配置的功能，作为存储传输数据的手段，xml还有个缺点就是它的处理和存储的效率非常低下，解析速度慢，占用更多的存储空间。 INI ：通常用于对软件的参数进行配置和记录。 优点是使用方便，嵌入程序也容易，几个接口就够了，很容易掌握。 配置文件更小巧，手工配置也更容易。 缺点是它的结构只有2层，对于复杂类型数据描绘就显得比较无力了。 另外ini文件有64kb的大小限制。 转换ini 为xml]]></content>
      <categories>
        <category>LinuxC</category>
        <category>standard lib</category>
      </categories>
      <tags>
        <tag>standard lib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP32 Feature]]></title>
    <url>%2F2019%2F03%2F30%2FESP32Feature%2F</url>
    <content type="text"><![CDATA[Esp32 Feature基本特性 蓝牙和WiFi的特性 分双核和单核DE模组 淘宝上买的板子估计是自己生产的，不是乐鑫的(以后买板子，先查查正品`是哪些，在进行购买) ESP32-WROOM-32 模组 ESP32-WROOM-32D语音编码、音频流和 MP3 解码 ESP32 硬件特性 其他绘制也可参考 SCH_PCB的审查规则查看 电源和地SCH Check 睡眠电流小于 5 μA，适用于电池供电的可穿戴电子设备。 外部供电电源电压及供电电流是否满足需求（500mA 及以上）。 芯片设计唯一接地的管脚在芯片下方，绘制原理图注意是否有添加并连接至地。 PCB Check 电源输入接口的 ESD 管是否有靠近端口放置。 电源走线进入芯片之前是否有添加 10uF 去耦电容。情况允许，可搭配 0.1uF 电容一起使用。 芯片底部的 Ground PAD 是否有至少通过 9 个地孔(CC2540的就需要)连接到地平面。 射频SCH 是否有预留 π 型匹配网络（推荐优先采用 CLC 结构）用于外部天线的阻抗匹配。 RF 测试点添加的位置是否合适（建议添加在第一个 π 匹配电路之后） PCB RF 走线线宽是否有突变。是否存在分支走线。是否有采用 135°走线或圆弧走线。RF 走线两侧是否有密集地孔进行屏蔽。RF 走线需尽量短。 芯片到天线的 RF 走线是否有过孔，天线需与芯片在同一层。 RF 走线附近不能有高频信号线。RF 上的天线必须远离所有传输高频信号的器件，比如晶振，DDR，一些高频时钟（SDIO_CLK 等）。USB 端口、USB 转串口信号的芯片、UART 信号线（包括走线、过孔、测试点、插针引脚等）都必须尽可能地远离天线。且 UART 信号线做包地处理，周围加地孔屏蔽。 复位 复位功能 睡眠和唤醒​ 通过控制某几个GPIO口的引脚进行控制状态 检测一种状态：BT模式下进行 BT模式下进行​ 为了通过Wi-Fi或BT源唤醒芯片，芯片将在Active、Modem-sleep和Light-sleep之间进行切换，CPU、Wi-Fi、Bluetooth和射频模块均将在预设间隔中唤醒，保证Wi-Fi/蓝牙的正常连接。 Light_sleep Light_sleep 但是esp_sleep.h 的头文件中唤醒模式没有BT DatasheetPin Mode EN : Module-enable signal. Active high. Software can read the values of these five bits from register ”GPIO_STRAPPING”. MTDI – &gt; gpio12 MTDO –&gt; gpio15 GPIO0 首先长按Boot键，同时按 reset键，系统将会进入下载模式，然后 make flash 长按boot键，就是将其拉低。 Download 通过CP2102 USB to TTL ESP32 通过串口进行下载]]></content>
      <categories>
        <category>Esp32</category>
        <category>Feature</category>
      </categories>
      <tags>
        <tag>esp32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Funcation Interface]]></title>
    <url>%2F2019%2F03%2F25%2FFuncationInterface%2F</url>
    <content type="text"><![CDATA[Funcation Interface 我们讲过void *类型 和任何指针类型之间可以相互隐式转换。 函数接口的定义 函数的调用者和函数的实现者之间订立了一个契约 调用函数之前：调用者要为实现者提供某些条件 函数返回时：实现者要对调用者尽到某些义务。 首先靠函数接口来描述 即函数名,参数,返回值,只要函数和参数的名字起得合理 参数和返回值的类型定得准确 函数接口并不能表达函数的全部语义 这时文档就起了重要的补充作用，怎么写Man Page Online man page command line –&gt; man strcpy strcpy and strncpy man page 命令行输入：man strncpy dest: Destination（目的） src: Source(源) n : 看下面的文档 注意dest的空间一定要足够大 否则：发生越界 像buf 这种由调用者分配并传给函数读或写的一段内存通常称为缓冲区(Buffer) 缓冲区写越界的错误称为缓冲区溢出(Buffer Overflow) Bug : 数组的长度必须固定，所以strncp容易造成越界； char buf[n+1] = {} ; // 虽然保证buf 是以 ‘\n’结尾，但是仍然不够灵活 动态内存分配 malloc and free C的标准函数，都是可以直接用的，对吧。（在C中定义好了） malloc malloc 12void *malloc(size_t size); /* void *类型 和任何指针类型之间可以相互隐式转换。 */ 对每次的调用malloc，进行判断函数调用是成功，还是失败。 1234if (p == NULL) &#123; printf("out of memory\n"); /* 对每次的调用malloc，判断函数成功/失败的返回值 */ exit(1); &#125; free 每一次调用malloc，都需要free，对指针内存和地址进行释放 内存泄漏（Memory leak）:分配完了又不释放,就会慢慢耗尽系统内存 内存泄漏的Bug很难找到,因为它不会像访问越界一样导致程序运行错误 特殊情况 free : 只要不是释放野指针就没问题 12malloc(0); return 非NULL的指针free(NULL); 合法的 free 产生错误 123malloc(p);free(p);free(p); //第二次释放的时候，找不到指针，到这里会报错 正确的free过程 123free(p-&gt;msg);free(p);p = NULL; 传入参数和传出参数 parameter code 传入参数：把指针所指向的数据传给函数使用； 传出参数：由函数填充指针所指的内存空间，传回给调用者使用 如果传入参数是NULL表示取缺省值,也可能表示不做特别处理。 如果传出参数是NULL 表示调用者不需要传出值,例如time(2) 的参数。 函数123void func(const unit_t *p) //传入参数void func(unit_t *p) //传出参数void func(unit_t *p); //Value-result参数示例: 两层指针 TwoPointer 两层指针的内存分配 两层指针和单层指针 两层指针只能作为传出参数，两种情况 传出的指针指向静态内存,或者指向已分配的动态内存； 在函数中动态分配内存，然后传出的指针指向这块内存空间,这种情况下调用者应该在使用内存之后调用释放内存的函数。 12void alloc_unit(unit_t **pp); //分配内存void free_unit(unit_t *p); //释放内存 参数分配内存则需要两层指针 返回值是指针的情况返回指向已分配内存的指针示例 FuncationInterface / ReturnPointer unit_t *func(void) 动态分配内存并返回指针 FuncationInterface / ReturnPointer / Return 12unit *alloc_unit(void);void free_unit(unit *p); 通过返回值分配内存就只需要一层返回指针； 参数分配内存则需要两层指针 回调函数 利用函数指针的方法进行调用]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Funcation Interface</category>
      </categories>
      <tags>
        <tag>Funcation Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里AI安全讲座]]></title>
    <url>%2F2019%2F03%2F22%2FWork%2F</url>
    <content type="text"><![CDATA[阿里AI安全讲座 工作和学习的建议 主讲人：张荣 个人的工作经历 第一阶段的工作：快速成长 跳出生活的舒适区，刚毕业对生活的节奏很新鲜，工资翻倍，小生活滋润 需要有鞭策，寻找新视野，更上工作的步伐，为后续的转行做准备 第二阶段的工作：拒绝吃老本行 跳出工作的舒适区，适应工作环境和工作节奏之后的状态 学习新的知识，寻找新的方向和平台 第三阶段的工作：止跌回升 找到大平台，资源； 为自己的方向而打拼 用计算机的思维去思考问题 第四阶段的工作：行业内寻找新方向 在行业中寻找新的方向 选择 行业～进入快速发展的行业 企业～进入前途远大的企业 业务～进入成长性的业务 老板～跟上有雄心壮志的老板 行业 科技发展的2个主线：能量和信息 5G : 基础设施，超高速传输，广覆盖 IoT：万物互联 感知 – 认知 企业 巨头：资源过剩，平台大，优秀的人多，不容易脱颖而出 二线：发展的机会欠缺，不利于成长 超新星：国家和政府扶持，目前最需要的 初创：不关注个人成长，只是让你完成任务 企业面试看中什么？ 校招和社招不同 校招～为未来投资，面向未来，技能总会过时 阿里校招的需求 基础品质 完整的项目经历，项目落地的经历 基础知识 技术文档：英语写作能力，口头交流能力 编程基础 学生到职场人 做决定和承担的能力 有自己的想法和idea 自我驱动和发展 公司需要的能力 从公司的规模来看： 完成 – 完善 – 对外推广 从公司的结构 网状：上下连接，生产实现，推销 Leader：不应该是团队的技术核心，应该是一个连接者，组建一个由长板构成的团队 面试和笔试 基础必须好： 数据结构题目的刷人，时间复杂度，空间复杂度是多少 编程问题：基础能力必须牢固 想面试阿里：用一个钉钉客户端，里面有阿里邮箱 AI 安全技术相关]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pointer]]></title>
    <url>%2F2019%2F03%2F22%2FPointer%2F</url>
    <content type="text"><![CDATA[Pointer (指针)指针的基本操作理解指针 堆栈和队列 堆栈有栈顶指针，队列有头指针和尾指针 这种指针本质：是一个整数，是数组的索引 指针概念 把一个变量所在的内存单元的地址 保存在另外一个内存单元 此内存单元 称为指针 12345int i;int *pi = &amp;i; /*全局变量的赋值：右边必须是常量表达式*/ /* 定义一个指向int型的指针变量pi,并用i的地址来初始化pi */char c;char *pc = &amp;c; /*32位的虚拟机，他们的内存单元都是4 byte*/ 指针变量 pi 和pc 指向不同类型的指针变量，但内存单元都占4 byte； 32 bit 的平台：占4byte； 64 bit 的平台：占8byte； 根据指针知找到变量 指针的关系 &amp;运算符的操作数必须是左值,因为只有左值（变量）才表示一个内存单元,才会有地址, 表达式E可以做左值（变量），*&amp;E = E E是指针类型，&amp;*E = E 123int *p; /*定义指针类型p*/p = &amp;i; /*此时p保存的是i的地址*/int j = *p; /*此时 *p = *&amp;i; 也就是i的值*/ 指针间的赋值 12int *ptri;ptri = pi; /*是把变量pi所保存的地址值赋给变量ptri*/ 保证ptri 和 pi是同一种类型，否则需要强制转化 指针很容易指向错误的地址，访问这样的地址可能导致段错误 空指针和野指针 定义局部类型的指针变量，却没有赋值 – 野指针(Unbound Pointer)（局部变量定义却不赋值） 避免野指针，定义指针变量因该赋值，货值初始化NULL 123int *p = NULL;#define NULL ((void *)0) /*将地址0转换为指针类型*//*任何对地址0的访问都会立刻产生段错误*/ void * 类型 void *指针与其它类型的指针之间可以隐式转换,而不必用类型转换运算符。 只能定义void *指针，而不能定义void 型的变量。 因为void *指针和别的指针一样都占4个字节，void型的变量就不清楚了 void *指针不能直接Dereference,而必须先转换成别的类型的指针再做Dereference。 指针类型的参数和返回值12345int *swap(int *px, int *py) /*指针类型的形参*/&#123; ... return px; /*如果需要指针类型的返回值，需要定义指针类型的函数*/&#125; 指针和数组 关系 地址之间的关系： int 型元素占4个字节，pa++使pa指向的地址加4，不是加1 指针与变量之间的关系 指针保存变量的地址 指针和数组的关系 右值：在赋值符号“ = ”，右边的常量表达式，相当于要存储的值 数组名做右值使用时,自动转换成指向数组首元素的指针。 字符串字面值还有一点和数组名类似,做右值使用时自动转换成指向首元素的指针。 12a[2] 能取到数组的第三个元素，相当于 *（a+2）*(pa+2) --&gt; pa[2]; //做右值的时候自动转化为指针 指针指向数组 a[0] 的首地址 123int a[10];int *pa = &amp;a[0]; /*后缀运算符优先级高于单目运算符*/pa++; 由于数组a做右值使用时和 &amp;a[0]是一样的 表达式pa[-1] 是合法的,它和a[0] 表示同一个元素。 12int *pa = &amp;a[0]; 等价于 ：int *pa = a; 指针的比较运算 只有指向同一数组的指针，作比较才有意义 指针的比较比的是地址 指针的相减运算 相减：表示两个指针间，相差的元素个数 12pa - a = ?pa - 1 = a; pa - a = 1 函数的参数是数组时，等价于参数是指针的形式 12void func(int a[10])等价于 ： void func(int *a) 指针与const限定符 const : 将不允许修改的内存单元保护起来； 看 const 离哪个比较近，则保护的便是它 指向const int 型的指针 代码方式 12const int *a;or int const *a; /* 将 const 后面的(*a)看成一个整体，这个整体不允许修改的 */ 代表含义 a 是一个指向const int 型的指针； a 指向的内存单元是不能修改的。（a 代表地址的内存单元） （*a）++ 不允许 （值）；a++允许（地址） 只能读指针a 指向的元素 指向int 型的 const 指针 代码方式： 1int * const a; 代表含义 *a是可以改写的,内容的值可以修改 a不允许改写，地址不能修改 指向const int 型的 const 指针 代码方式： 12const int * const a;or int const * const a; 代表含义 因此*a 和a都不允许改写。 结论 指向非const 变量的指针或者非const 变量的地址可以传给指向const 变量的指针,编译器可以做隐式类型转换,例如: 12char c = 'a';const char *pc = &amp;c; // c 的值是不会改变的 const 使用 字符串字面值通常分配在.rodata段 .rodata：不允许改写，但编译器不会报错，在运行时会出现段错误。 指针与结构体 定义结构体类型 typedef：相当于一个命名，将struct unit 命名为了unit 好处：在定义struct unit 类型的变量时：可以只写unit 123456struct unit&#123; --&gt; typedef struct&#123; char c; --&gt; char c; int num; --&gt; int num;&#125;; --&gt; &#125;unit;struct unit u; --&gt; unit u;struct unit *p = &amp;u; --&gt; unit *p = &amp;u 指针访问结构体元素 12way1 ： (*p).c ，(*p).num;way2 : p-&gt;c , p-&gt;num 指向指针的指针与指针数组指向指针变量的指针 指针可以指向基本类型，也可以指向复合类型，因此也可以指向另外的指针变量 代码类型 12345char c;char *pc = &amp;c;int i;int *pi = &amp;i; // pi 保存的是 i 的地址int **ppi = &amp;pi; // *ppi = &amp;pi: ppi保存pi的地址; *ppi保存的是i的地址 如何进行参数的传递呢？ 1234void insert(int **ppi, int value); /* 形式参数 */int *pi = null;insert(&amp;pi, 5); /* 指向指针的指针，使用和指向int 型的指针类似，换的只不过是类型而已 */ 指针数组 指针数组的定义 12int a[10]; --&gt; int *a[10];int *pa = &amp;a; --&gt; int **pa = &amp;a[0]; //指向指针数组的首元素 &amp;a[0] 表示数组a的首元素的首地址；而&amp;a 表示数组a 的首地址； 显然这两个地址的数值相同，但这两个表达式的类型是两种不同的指针类型,前者的类型是int ,而后者的类型是int ( )[10] 则pa[0] 和a[0]取的是同一个元素; 唯一比原来复杂的地方在于这个元素是一个int * 指针，不是基本类型 main的标准原型 [main code] main的原型 1int main(int argc, char *argv[]); argc : 命令行参数的个数 而argv 是一个指向指针的指针,为什么不是指针数组呢? 函数原型中的[ ]表示指针而不表示数组，等价于char **argv 那为什么要写成char *argv[]而不写成char **argv 呢？ argv 不是指向单个指针,而是指向一个指针数组的首元素。 数组中每个元素都是char *指针,指向一个命令行参数字符串。 main 原型的代码结构 指向数组的指针与多维数组指向数组的指针 代码定义： 12345int *a[10] --&gt; int (*a)[10]; /*********************Equivalent to:**********************/typedef int *t; --&gt; typedef int t[10];t a[10]; --&gt; t *a;// a是一个数组，元素的类型是int *型 可以认为 后缀运算符 [ ]，优先级高于 单目运算符 * int a[10]：a和[]先结合，a[10]表示数组指针，指向 int 类型， 数组元素是10个 int *型 的数 int (a)[10]：a和 先结合，a表示指针，指向含有10 个int 型的数组 指针数组使用 指针数组 和 指向数组的指针 123指针数组： --&gt; 指向数组的指针int *a[10] --&gt; int a[10]; int (*pa)[10] = &amp;a; *pa：表示pa指向的数组a； 12a[0] --&gt; (*pa)[0]; (*pa) --&gt; pa[0]; 数组做右值的时候，自动转化为首元素指针所以引入二维数组： (*pa)[0] == pa[0][0] 多维数组 通过指向数组的指针，表示二维数组； 实现数组的自增和赋值作用 多维数组的引用 123int a[5][10]; --&gt; int a[10];int (*pa)[10] = &amp;a[0] --&gt; int (*pa)[10] = &amp;a;//则pa[0] 和a[0]取的是同一个元素 多维数组的优势 pa 比a用起来更灵活，数组名不支持赋值、自增等运算； 而指针可以支持，pa++ 使 pa 跳过二维数组的一行(40个字节)，指向a[1] 的首地址。 函数类型和函数指针类型定义 指针变量：内存单元存放一个地址值； 函数指针：存放的就是函数的入口地址(位于.text 段) 123void func(const char *p)&#123; --&gt; void (*func)(const char *p)&#123; ...函数 --&gt; ... 函数指针&#125; --&gt; &#125; 而函数类型和数组类型类似,做右值使用时，自动转换成函数指针类型，所以可以直接赋值 12345678void say_hello(const char *str)&#123; printf("hello %s\n", str)&#125;int main(void)&#123; void (*func)(const char *) = say_hello; --&gt; void (*func)(const char *) = &amp;say_hello; f("Guys"); --&gt; (*f)("Guys") or say_hello("Guys") return 0;&#125; 函数调用运算符() 要求操作数是函数指针,所以f(“Guys”) 是最直接的写法; 而say_hello(“Guys”)或(*f)(“Guys”)则是把函数类型自动转换成函数指针然后做函数调用。 高级指针 指向指针的指针： 间接访问：传递的都是变量的地址； 每一层间接访问，就对应一层地址传递 高级声明 优先级的高低 1最低优先级：* &lt; () or [] 函数 type f ( ) : 这个()是函数的调用操作符;type 是返回值的类型 123int *f(); // 首先结合 f()-函数；再结合 * -- 函数返回值是指向int型的指针int (*f)(); // 首先结合 (*f)-聚合为一个指针；再结合()--(*f)()是一个函数指针；函数返回整形值int *(*f)(); // (*f)()指针函数； [(*f)()]组合 * 后称为一个指针，指向int型 数组 type g[ ] 123int f[]; // 数组int *f[]; // 首先结合 f[] 成为数组，元素类型是指向 int 型的指针；int (*f[])(); // f[]是一个数组；数组元素类型是函数指针；返回值是整形值 函数指针 — 回调函数的实际应用 函数指针的初始化 1int (*pf)(int value) = &amp;f; // 函数指针的定义和初始化，f也是函数； 做左值的时候：等价的 &amp;f –&gt; f 回调函数的应用 功能函数能执行不同类型的工作，或者执行只能右函数调用者定义的工作； 许多窗口系统，使用回调函数连接多个动作；]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Pointer</category>
      </categories>
      <tags>
        <tag>pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile]]></title>
    <url>%2F2019%2F03%2F21%2FMakefiles%2F</url>
    <content type="text"><![CDATA[Makefile 基础 Link code – Makefiles 注释是 “#” Makefile 基本规则Makefile 例子 12345678main: main.o stack.o maze.o gcc main.o stack.o maze.o -o mainmain.o: main.c main.h stack.h maze.h gcc -c main.cstack.o: stack.c stack.h main.h gcc -c stack.cmaze.o: maze.c maze.h main.h gcc -c maze.c Makefile 由一组规则 rule组成 1234target ... : prerequisites ... command1 command2 ... 目标和条件之间的关系是：欲更新目标，必须首先更新它的所有条件; 所有条件中只要有一个条件被更新了，目标也必须随之被更新。 所谓“更新”就是执行一遍规则中的命令列表；命令列表中的每条命令必须以一个Tab开头；（注意不能是空格） 对于Makefile中的每个以Tab开头的命令,make 会创建一个Shell进程去执行它。 make 编译 make 会自动选择那些受影响的源文件重新编译，不受影响的源文件则不重新编译。 make clean123456clean: @echo "cleanning project" -rm main *.o @echo "clean completed".PHONY: clean /* 声明clean为一个伪目标 */ clean 目标不依赖于任何条件,并且执行它的命令列表不会生成 clean文件 rm and mkdir 命令前面加 “ - ” 即使这条命令出错，也会继续执行后面的命令 因为rm 要删除的文件可能不存在,mkdir 要创建的目录可能已存在 在命令前加 @ 加了命令在前面，不显示命令本身 而只显示它的结果; .PHONY: clean 声明clean为一个伪目标 为了将clean 当做特殊的名字使用 类似于clean的目标名字​ Makefile 隐含规则和模式规则​ 变量 符号 作用 “ := ” y := $(x) bar make 遇到变量定义的时候：立即展开 nullstring :=space := $(nullstring) # end of the line 为了定义变量的值为空格；注释前面是有空格 “ ?= ” foo ?= $(bar) 相当于 “ = ”，定义foo的值为$(bar) “ += ” 保持了“ := ”的特性 特殊变量 可以减少书写错误 特殊变量：替代makefile中的规则，简写 特殊变量的使用 “ $? “的使用 用于生成静态、共享库 123libsome.a: foo.o bar.o lose.o win.o ar r libsome.a $? ranlib libsome.a 变量的缺省值 自动处理头文件的依赖关系 省去了手动敲命令 命令12$ gcc -M main.c /* 找出所有的依赖头文件 */$ gcc -MM main.c /* 排除系统头文件 */ Make命令选项想通过命令行传参数或者缺省参数设置 前提条件： 需要通过隐式规则编写Makefile 将gcc编译省去 在Makefile 文件理添加缺省命令 123456789101112all: main # 按照惯例,用all 做缺省目标。main: main.o gcc $^ -o $@main.o: main.cCFLAGS = -gclean: @echo "cleanning project" -rm main *.o @echo "cleanning compile".PHONY:clean 通过命令行传递缺省参数 1make CFLAGS=-g /*在编译中增加调试选项*/ Makefile 文件 从主目录到子目录中都存在 总的Makefile ： make -C 执行每个子目录下的Makefile 1234$ make -n /*只打印要执行的命令，而不是直接执行；检查makefile是否正确*/$ make -C testmake /* 切换到目录testmake下，编译 */$ make -C /*执行每个子目录下的Makefile*/$ make CFLAGS=-g /*在编译中增加调试选项*/ GNU make GNU Make 编写Makefile文件进行大项目的管理； 概念Why Use 明确搜索位置 减少项目的编译时间 只针对改动的项目进行编译 从很多目标文件生成一个程序包 (Library)比从一个单一的大目标文件生成要好的多 使用 gcc/ld (一个 GNU C 编译／连接器) 把一个程序包连接到一个程序时； 在连接的过程中，它将不去连接没有使用到的部分。 程序是很模块化的，文件之间的共享部分被减到最少 When Use 如果你需要开发一个相当大的项目，在开始前，应该考虑一下你将如何实现它，并且生成几个文件（用适当的名字）来放你的代码。 当然，在你的项目开发的过程中，你可以建立新的文件，但如果你这么做的话，说明你可能改变了当初的想法，你应该想想是否需要对整体结构也进行相应的调整。 How Use 不要用一个 header 文件指向多个源码文件; 如果可以的话，完全可以用超过一个的 header 文件来指向同一个源码文件。 不要在多个 header 文件中重复定义信息。 关键字“static”：要防止一个符号在它被定义的源文件以外被看到 header 不要在 header 档里定义变量，只能用作声明变量和函数。 你只需要在 header 档里声明，然后在适当的Ｃ源码文件（只在 #include header）里定义一次。 声明和定义 声明：告诉编译器其所声明的符号应该存在，并且要有所指定的类型。但是，它并不会使编译器分配贮存空间。 定义：要求编译器分配贮存空间。 防止出现重复声明 1234#ifndef FILENAME_H#define FILENAME_H...#endif GUN Make Tools GNU Make 的主要工作是读进一个文本文件–makefile 。 搜索其中的Target and dependencies； 检查磁盘上的文件和目标文件的时间戳； 进而进行目标文件的更新。 Makefile 变量 如何编写，引用Makefile变量 和变量的赋值规则相似 变量：用大写的字母 引用：通过 “$( CC )” “$(CFLAGS)” 123OBJS = main.o #变量 = 变量的值CC = gccCFLAGS = -Wall -O -g #-Wall 打印所有的警告信息； -O 编译器的优化； -g gdb调试的编译 三个特殊的变量 “$@” ：扩展成当前规则的目的文件名 “$&lt;” : 扩展成依靠列表中的第一个依靠文件 “$^” : 扩展成整个依靠的列表（除掉了里面所有重复的文件名） Makefile 文件编写 1234567891011121314151617# 编译条件OBJS = main.o CC = gccCFLAGS = -Wall -O -g# 目标文件all: main # 按照惯例,用all 做缺省目标。# 编译条件main : $(OBJS) $(CC) $^ -o $@main.o : main.c main.h $(CC) $(CFLAGS) -c $&lt; -o $@ # 类似于 gcc -c main.c# cleanclean: @echo "cleanning project" -rm main *.o @echo "cleanning compile".PHONY:clean 隐含规则 Rule 变量CC 做为编译器 传递变量 CFLAGS 给 C 编译器（C++ 编译器用 CXXFLAGS ） CPPFLAGS （ C 预处理器旗标） TARGET_ARCH （现在不用考虑这个） 加入旗标 ‘-c’ ，后面跟变量 $&lt; （第一个依靠名），然后是旗标 ‘-o’ 跟变量 $@ （目的文件名） 1$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c $&lt; -o $@ 假想可执行文件 为了通过一个Makefile生成多个可执行文件 12在Makefile开始时输入 all: main mymain Makefile 的一种编写方式, 但是没有成功, 保留原格式 123456789101112131415161718192021222324# specify all source files hereSRCS = double_list.c # specify target here (name of executable)TARG = double_list # specify compiler, compile flags, and needed libsCC = gccCFLAGS = -g -WallLIBS = -lm # this translates .c file in src list to .o'sOBJS = $(SRCS: .c=.o)# all is not really needed , but is used to generate the targetall: $(TARG)# this generates the target executable$(TARG): $(OBJS) $(CC) $(OBJS) -o $(TARG) # this is a generic rule for .o files%.o: %.c $(CC) $(CFLAGS) -c $&lt; $@ 多目录下的Makefile 文件编写在文件夹下包含一个Makefile 文件目录 子目录下的Makefile 编译该子目录下的文件，并保存到一个函数库中，再将该库文件复制到上一级主目录当中。 12345678910111213141516171819202122# 编译条件CC = gccINCLUDE = -I. # 子目录下的Makefile文件编译CFLAGS = -g -Wall# 要使用Tab键: 将文件定义为lib.a库array_malloc_queue = array_malloc_queue.a$(array_malloc_queue): $(array_malloc_queue)(array_malloc_queue.o) (cp $(array_malloc_queue) ../) (cp $(linkQueueInterface) ../array_queue_interface/) # 复制到不同目录################# .o 文件编译################array_malloc_queue.o: array_malloc_queue.c array_queue_interface.h $(CC) $(CFLAGS) -c $(INCLUDE) $&lt; -o $@clean: @echo "cleaning project" -rm $(array_malloc_queue) -rm *.o @echo "cleaning complie".PHONY: clean 调用函数的目录 Makefile 123456789101112131415161718192021222324252627#Objsall: array_queue############编译条件################CC = gccCFLAGS = -g -WallINCLUDE = -I. -Iarray # 不同目录下文件array_malloc_queue = array_malloc_queue.a # 子目录下最后生成的文件名################# OBjs目标文件的编译################array_queue: main.o $(array_malloc_queue) $(CC) $^ -o $@################# 目标.o 文件的编译################$(array_malloc_queue): # 子目录下Make编译文件 (cd array;$(MAKE))# 不用加array_queue_interface.h文件，我们在生成目标文件时进行链接main.o: main.c $(CC) $(CFLAGS) -c $(INCLUDE) $&lt; -o $@#cleanclean: @echo "cleaning project" -rm array_queue $(array_malloc_queue) -rm *.o @echo "cleaning complie".PHONY: clean 执行编译过程 1$ make // 在调用函数的目录下执行 123$ make clean // 在主目录下执行，不能clean子目录的；$ cd array // 进入子目录；$ make clean // 子目录下的clean 问题： 每次子节点目录下文件的改变，需要进入目录去修改； 并且重新生成]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Preprocessing]]></title>
    <url>%2F2019%2F03%2F21%2FPretreatment%2F</url>
    <content type="text"><![CDATA[Preprocessing预处理步骤 经过以下步骤之后，把空白字符丢掉，把Token交给C编译器做语法解析 Token：通过分隔符将字符串，分成一个个的子块 换行符 Windows平台的文本文件用 \r \n 做行分隔符，而Linux平台用 \n 做行分隔符； C编译器要能处理差别 把用 “ \ ” 字符续行的多行代码连成一行 把注释都替换为一个空格 Token 然后预处理器把逻辑代码行划分成Token和空白字符, 这时的Token称为预处理Token：包括标识符、整数常量、浮点数常量、字符常量、字符串、运算符和其它符号 include and define 在Token过程中，遇到 #include 预处理指示：则把相应的源文件包含进来 宏定义：。如果遇到宏定义则做宏展开。 宏定义 较大的项目都会用大量的宏定义来组织代码，宏定义很常用。 看起来宏展开就是做个替换（展开替换）而已,其实里面有比较复杂的规则, 函数式宏定义 变量式宏定义（Object-like Macro） 12#define N 20#define STR "hello, world" 函数式宏定义 12#define MAX(a, b) ((a)&gt;(b)?(a):(b)) // 不加括号，展开后会报优先级错误k = MAX(i&amp;0x0f, j&amp;0x0f) 函数式宏定义不建议使用 内联函数 关键词：inline 用于定义内联函数 inline funcation inline关键字告诉编译器,这个函数的调用要尽可能快,可以当普通的函数调用实现,也可以用宏展开的办法实现。 “# and ## 运算符”和可变参数 # 运算符用于创建字符串，运算符后面应该跟一个形参（中间可能有Tab） 1#define STR #s //#的用法 ## 运算符将两个字符连接在一起 宏展开时前后两个#号被这个运算符连接在一起。 而根据定义## 运算符用于连接前后两个预处理Token,不能出现在宏定义的开头或末尾,所以会报错。 条件预处理提示Header Guard1234#ifndef HEADER_FILENAME //如果没有定义HEADER_FILENAME，则执行后面的语句#define HEADER_FILENAME/* body of header */#endif #ifdef 或 #if 可以嵌套使用,但预处理指示通常都顶头写不缩进,为了区分嵌套的层次 预处理过程 先处理defined运算符 12#if defined x 相当于 #ifdef x#if !defined x 相当于 #ifndef x 展开所有的宏定义 把没有定义的宏换成 0 把得到的表达式 ，像C表达式一样求值 其他预处理特性 _ FILE _ ：展开为当前源文件的文件名,是一个字符串, _ LINE _ ：展开为当前代码行的行号,是一个整数。 _ func _ : 特殊的标识符，打印所在函数的名字 assert.h 实现 #undef assert 确保前面对assert的定义 然后分另种情况：]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Preprocessing</category>
      </categories>
      <tags>
        <tag>Pretreatment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Link lib]]></title>
    <url>%2F2019%2F03%2F19%2FLinklib%2F</url>
    <content type="text"><![CDATA[Link lib Code link – Link 多目标文件链接 编译查看命令 12$ gcc main.c -o main //编译可执行文件$ readelf -a main //查看符号表 global and local 目的： 能查看到跟函数的段定义 Data Segment 后面的一些Segment，主要是调试信息 为什么要声明函数 为什么编译器在处理函数，调用代码时需要知道函数原型? 因为必须知道参数的类型和个数以及返回值的类型，才知道生成什么样的指令。 定义和声明 凡是被多次声明的变量或函数： 必须有且只有一个声明是定义 如果有多个定义，或者一个定义都没有,链接器就无法完成链接。 变量和函数的声明不同 函数的声明：extern，可有可无 变量的声明：extern，必须要有 extern int top extern 和 static 直接包含 .c 文件 — 直接包含// #include “stack.cpp” ，错误的想法 12345#include &lt;stdio.h&gt;extern void push(char);extern char pop(void);extern int is_empty(void); extern : 表示关键字具有 External Linkage 链接之后是同一个GLOBAL符号,代表同一个地址。 static ： 表示一个Internal Linkage的属性 有些模块不希望被外界访问到，声明为内部的 头文件 .h 将变量和函数的声明放在一个 .h 的文件中 在每次调用函数的时候，只需要包含 . h 的头文件； 不需要在函数中对每一个函数进行声明 预处理关键词 1234#ifndef STACK_H /* 预处理的关键词 */ if not define STACK_H, so define STACK_H; if have define STACK_H, it is NULL.#define STACK_H...#endif #include &lt;&gt; and #inlclude “” &lt;&gt; ：gcc编译的时候首先查找 -I 选项指定的目录，然后查找系统的头文件目录(/usr/include) “ ”：gcc首先查找包含头文件的.c 文件所在的目录，然后查找 - I 选项指定的目录，然后查找系统的头文件目录。 1gcc -c main.c -Istack //用-I选项告诉gcc 头文件要到子目录stack里找;stack是一个子目录 直接包含 .c 文件 – – 错误的 为什么不在 main.c 中直接包含 stack.c 文件？？ 假如又有一个foo.c 也要使用stack.c这个模块。如果在foo.c 里面也包含头文件#include “stack.c” 就相当于push 、pop 、is_empty 这三个函数在main.c和foo.c 中都有定义，那么main.c和foo.c 就不能链接在一起了。 如果采用包含头文件的办法,那么这三个函数只在stack.c中定义了一次,最后可以把main.c、stack.c、foo.c 链接在一起。 头文件中的函数和变量声明一定不能是定义 如果头文件中出现变量或函数定义，这个头文件又被多个.c 文件包含,那么这些.c 文件就不能链接在一起了。 定义声明的详细规则 有相应的作用域和作用范围 三个关键字 Storage Class 静态库 将一组代码编译成一个库 链接器只会取出静态库中：有用的那部分代码。 代码结构 代码目录的区别：编译的时候需要指定目录 便以为目标文件 12$ gcc -c stack/stack.c stack/push.c stack/pop.c stack/is_empty.c// 生成 .o 文件 打包成静态库 库文件命名：libxxx; 静态库 ： .a为后缀 12$ ar rs libstack.a stack.o push.o pop.o is_empty.oar: creating libstack.a 链接主函数 main.c 和 libstack.a -L 选项告诉编译器去哪里找需要的库文件：-L . 表示在当前目录找 -lstack ：告诉编译器链接 libstack库 -Istack：告诉编译器寻找头文件 1$ gcc main.c -L. -lstack -Istack -o main 查看编译器会查询的目录 1$ gcc -print-search-dirs 共享库编译，链接，运行 编译 12$ gcc -c -fPIC stack/stack.c stack/push.c stack/pop.cstack/is_empty.c // -f 编译选项；PIC 是其中一种 生成共享库 使用了PIC：共享库的各段加载地址没有定死，可以加载到任意位置 12$ gcc -shared -o libstack.so stack.o push.o pop.o is_empty.o$ objdump -dS libstack.so //反汇编查看共享库 链接库 1$ gcc main.c -g -L. -lstack -Istack -o main 运行出错 12$ ./main // 运行的时候：找不到动态链接库 libstack.so??$ ldd main //ldd查看main函数依赖哪些共享库 添加动态库的路径 pwd : 得到 .so 的绝对路径 vi etc/ld.so.conf ：每个路径一行，添加 sudo ldconfig -v 共享库的命名 按照共享库的命名惯例,每个共享库有三个文件名:real name、soname和linker name。 指定库的名字 1$ gcc -shared -Wl,-soname,libstack.so.1 -o libstack.so.1.0 stack.o push.o pop.o is_empty.o 虚拟内存管理查看命令12345$ ps //查看当前终端下的进程// bash 进程的 id 是 3279$ cat /proc/3279/maps //查看它的虚拟空间地址// proc 是内核虚拟出来的文件系统// 当前系统中运行的每个进程在/proc 下都有一个子目录,目录名就是进程的id 进程地址空间 进程空间是独立的：每个进程都有各自的VA 和 PA 系统中可分配的内存总量 = 物理内存的大小 + 交换设备的大小]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Linklib</category>
      </categories>
      <tags>
        <tag>Linklib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Assembly And C]]></title>
    <url>%2F2019%2F03%2F18%2FComplationAndC%2F</url>
    <content type="text"><![CDATA[Assembly And C汇编代码生成C和汇编穿插显示12gcc -g main.c -o main -Wall // 生成可执行文件.outobjdump -dS main // 把C代码和汇编代码穿插起来显示 只生成汇编1gcc -S main.c //只生成汇编代码main.s,而不生成二进制的目标文件。 汇编调试12345(gdb) disassemble //可以反汇编当前函数或者指定的函数(gdb) si //step 命令可以一行代码一行代码地单步调试,而这里用到的si命令可以一条指令一条指令地单步调试。(gdb) info registers //可以显示所有寄存器的当前值。(gdb) p $esp //打印esp寄存器的值,// 在上例中esp 寄存器的值是0xbff1c3f4,所以x/20 $esp 命令查看内存中从0xbff1c3f4地址开始的20个32位数。 数据的存储 在执行程序时,操作系统为进程分配一块栈空间来存储函数栈帧 esp 寄存器总是指向栈顶，ebp指向栈底 esp 随着压栈和出栈操作随时变化，ebp保持不变 有高地址想低地址增长 函数的参数和局部变量都是通过ebp 的值加上一个偏移量来访问的 程序入口 -o ：作用 –&gt; 只是为了取名字，而不是其他的作用 编译的作用：翻译高级语言为可执行的二进制语言。 汇编程序入口函数：_start；C程序的入口是：main() 汇编函数编译 12$ as hello.s -o hello.o //翻译为汇编代码$ ld hello.o -o hello //ld进行链接库 C程序的编译 123$ gcc -S main.c -o main.s //生成汇编代码$ gcc -c main.s -o main.o //生成目标文件 $ gcc main.o -o main //生成可执行文件 汇编代码： 可以直接命名为 xxx.s ；进行编写 通过as进行编译，ld进行链接。 可以通过 xxx.c 生成 通过 gcc -S 生成 .s汇编代码 C程序链接库的过程 链接和显示 12$ gcc -v main.c -o main //了解详细的编译过程$ objdump -d main //通过反汇编查看各目标文件所定义的符号 C链接的过程 变量的存储布局 查看命令 12$ gcc -g main.c -o main // gdb 调试文件生成$ readelf -a main //查看符号表 global and local 关键字修饰变量 通过一些关键字修饰变量：const 、static、register const 修饰的变量 全局的变量 GLOBAL 变量只读，不可修改 const 变量在定义时必须初始化。因为只有初始化时才有机会给它一个值。 一旦定义之后就不能再改写了,也就是不能再赋值了。 static 修饰的变量 static 修饰的变量，LOCAL LOCAL 的符号只能在某一个目标文件中定义和使用,而不能定义在一个目标文件中却在另一个目标文件中使用。 标识符的作用域（Scope） 关键字：时用来修饰标识符和变量的。 用来定义他们的作用范围 标识符：作用域适合于所有的标识符，而不仅仅是变量。 命名空间 （Name Space）的重名标识符 对于重名标识符，内层作用域的标识符将覆盖外层作用域的标识符。 标识符的链接属性 Linkage 外部链接（External Linkage） 标识符在任意程序文件中即使声明多次也都代表同一个变量或函数,则这个标识符具有External Linkage。 具有External Linkage的标识符编译后在符号表中是GLOBAL的符号。 内部链接（Internal Linkage） 如果一个标识符在某个程序文件中即使声明多次也都代表同一个变量或函数,则这个标识符具有Internal Linkage。 具有Internal Linkage的标识符编译后在符号表中是LOCAL的符号 无链接(No Linkage)。 除以上情况之外的标识符都属于No Linkage的 例如函数的局部变量，以及不表示变量和函数的其它标识符。 存储类型修饰符–关键字（Storage Class Specifier） typedef ，static，extern 修饰一个变量的声明 结构体和联合体存储 栈：是从高地址向低地址增长的； 结构体成员：从低地址向高地址排列，这一点和数组类似。但有一点和数组不同，结构体的各成员并不是一个紧挨一个排列的，中间有空隙，称为填充。 C和内联汇编 内联汇编：为了提高Ｃ的执行效率。因为Ｃ的代码是由编译器进行翻译的。 内联方式 内联格式 1_asm_(assembler code) C中的内联汇编，需要和Ｃ的变量建立关联 12345__asm__(assembler template : output operands /* optional */ : input operands /* optional */ : list of clobbered registers /* optional */); Volatile 限定符 编译器优化对寄存器代码产生的影响 在为调试而编译时不要指定优化选项,否则可能无法一步步跟踪源代码的执行过程。 编译器优化 指令形式 12gcc main.c -g -O -o main // -o 对生成的文件进行命名； // -O 制定优化选项 -O 优化寄存器代码，造成了错误 设备寄存器中的数据不需要改写就可以自己发生变化,每次读上来的值都可能不一样 连续多次向设备寄存器中写数据并不是在做无用功,而是有特殊意义的。 如何防止编译器优化造成的影响 加上限定符volatile 123/* artificial device registers */volatile unsigned char recv; // 仿照寄存器设备volatile unsigned char send; Volatile 有了volatile 限定符,是可以防止编译器优化对设备寄存器的访问。 当一个全局变量被同一进程中的多个控制流程访问时也要用volatile限定,比如信号处理函数和多线程。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Complation</category>
      </categories>
      <tags>
        <tag>complation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CC2540]]></title>
    <url>%2F2019%2F03%2F17%2FCC2540%2F</url>
    <content type="text"><![CDATA[CC2540核心板电路图阿莫电子 正常工作：CC2540工常工作的晶振是32M,休眠晶振是32.768K。 IT 官网 RESET 引脚：接了一个电阻 复位键：加了一个下拉电阻。（通过一个电阻减小电流对reset pin 造成的影响） CC2540 连接不上仿真器外部晶振不工作 原来CC2540为了降低功耗：设置了几种不同的工作模式，在没有程序运行的情况下，默认是关闭外部的晶振的，所以在新片子刚焊上时，晶振当然也就不起振了。 两端的匹配电容大小要合适，不然导致无法起振； 选择的电容的值越大单片机的耗电能力也就越强，而且易造成不起振的情况。减小晶振的电容值 PCB 焊接错误 参考蓝牙 底部是需要进行焊接的：之前焊接的时候都是有意避开底部，不上焊锡。 电压检查 Bias 引脚 错误原因排除 32 M 晶振的是适配电容用12 pF; PCB板子的底部应该是打孔 3*3 cc2540内部集成了上电的复位电路，我们没有，应该加上电复位Reset TI 建议在RESET 上连接RC 滤波电路，这样增加系统的可靠性，其实也可以直连RESET。 CC-debugger 板子的2脚反馈电压不正常，板子的供电不正常。– 排除 开发手册 参考教程]]></content>
      <categories>
        <category>cc2540</category>
        <category>Electronic</category>
      </categories>
      <tags>
        <tag>cc2540</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crystal Oscillator]]></title>
    <url>%2F2019%2F03%2F17%2FCrystalOscillator%2F</url>
    <content type="text"><![CDATA[Oscillator and Crystal有源晶振 oscillator（振荡器） 有源晶振是右石英晶体组成的。 石英晶片：可以当为振荡器使用，是基于它的压电效应：在晶片的两个极上加一电场，会使晶体产生机械变形； 四脚晶振 有源的四脚晶振：有个点标记的为1脚，按逆时针（管脚向下）分别为2、3、4 有源晶振通常的用法：一脚悬空，二脚接地，三脚接输出，四脚接电压。 配置电路 有源晶振不需要DSP的内部振荡器，信号质量好，比较稳定，而且连接方式相对简单。 电源滤波：通常使用一个电容和电感构成的PI型滤波网络， 三脚输出端：用一个小阻值的电阻过滤信号。 无源晶振 Crystal 仅由阻容元件组成 起振需求 无源晶振是有2个引脚的无极性元件，需要借助于时钟电路才能产生振荡信号，自身无法振荡起来。 两端的匹配电容大小要合适，不然导致无法起振。 晶振是否起振测量示波器测量 通电的情况下，测量双脚： 脚1和脚3是通电的，电流从脚1流入、脚3流出。 正接脚1，负接3； 以探头最好打到衰减档进行测试，探头测试晶振管脚有固定正确频率的正弦波信号输出即可。 通电的情况下，测量单脚： 用示波器连接任意一个引脚与地线， 观测到震荡波形且频率与晶振频率相符（频率不对的话是干扰信号）就说明已经起振。 原因分析焊接 晶振的温度范围 -50 – 85。 焊接时烙铁的温度200 度左右。 PCB 工艺问题 电容值不匹配，电容值大小和晶振起振相反。 降低电容值，看是否起振 选择的电容的值越大单片机的耗电能力也就越强。而且易造成不起振的情况。 晶振两脚之间有走线 晶振电路的走线过长]]></content>
      <categories>
        <category>Oscillator</category>
        <category>Electronic</category>
      </categories>
      <tags>
        <tag>Oscillator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[post]]></title>
    <url>%2F2019%2F03%2F17%2Fpost%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[x86Programe]]></title>
    <url>%2F2019%2F03%2F14%2Fx86Programe%2F</url>
    <content type="text"><![CDATA[x86 Programe 确实没怎么看懂 X86的寄存器 x86的通用寄存器有eax 、ebx 、ecx、edx 、edi 、esi 前面加 %eax 汇编语句的编译执行 文件命名：.s 代码解读 .globl name : 需用连接器 ld 知道的名字 edi / ebx / eax ELF 文件 ELF Header 目标文件布局]]></content>
      <categories>
        <category>LinuxC</category>
        <category>x86 Programe</category>
      </categories>
      <tags>
        <tag>LinuxC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CBIB Item]]></title>
    <url>%2F2019%2F03%2F14%2FAutoCADxbox%2F</url>
    <content type="text"><![CDATA[CBIB ItemAutoCAD Xbox autocad 制作盒子给kinect KinectXobx xbox.pdf 尺寸图 类别尺寸 mm 长 宽 高 平板尺寸图 303 188 11 Xbox 284 39 62 Xbox 云台 82 20 73 类别尺寸 长 宽 高 俯视图外层 305 200 俯视图内部虚线 Kinect [2019.4.8] 语音上的修改 在Qt上弹出一个设置：语音播放测量结果，是否可以进行选择 语音播放后界面的测量时间太长。 加一个Qt 设置的界面 可选择是否显示文字；（防止语音出问题） 可选择是否通过语音播放； 测量值，身高的差别太大了，能不能在测出的结果下截取一定的值 三轴传感器实现音乐的播放实现目的 实现简单的音乐简谱：从最简单低音，中音，高音 ，实现 do re mi fa so la xi 七个音符 ； 对音乐的简谱有一个了解; 电脑的beep，可以实现； 通过读取三轴传感器的数据，控制电脑播放某一个音节； 电脑读取：USB三轴传感器的数据； 数据进而控制简谱的播放：对应的关系。 先检测晃动的轻重：能够控制低音，中音，高音； 检测晃动的频率：能控制播放的节拍 电脑能够记录弹奏者 用户自己输入一遍音符 ：只保证正确，不需要匹配速率； 当播放用户的文件时 加速度传感器：控制用户播放音符的节奏 通过检测晃动的频率 用户输入音符：记录用户输入的轻重节奏 当播放用户的文件时 加速度传感器：控制音符的低音，中音，高音； 最后能够实现 制作一个指挥棒； 指挥棒能完成一首音乐演奏的指挥任务 平台搭建 先使用USB的三轴传感器，进行功能的实现； 后期ESP32 的蓝牙 + 三轴传感器；实现远程的控制 血压检测仪–飞机上使用开发型的资料 Code交接 代码的基本注释 代码的整体流程图 硬件文档 硬件整体的设计，制作，生产文档 硬件输入以及输出 硬件的基本接口 硬件的PCB和原理图 二次开发资料 开发的资料和网站 调试文档 经常遇到的Bug，尽量提供解决方案 生产型的资料 程序下载文档 程序的烧写 读取ESP32的MAC地址，生成二维码 产品组装文档 传感器+主控+供电模块：如何连接 遇到过的问题有哪些？ 呼吸暂停检测硬件模块搭建供电模块 锂电池供电，1500mah； mirco_usb 进行充电； 报警模式 蜂鸣器模块报警 震动模块报警 远程APP传送指令 传感器检测形式 传感器形式 模拟式传感器 – 透射式检测 数字式传感器 – 反射式 检测位置 手指检测（占时不考虑） 手腕检测 整体封装 电路盒 + 护腕带 臂带]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>cbib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Architecture]]></title>
    <url>%2F2019%2F03%2F14%2FComputerArchitecture%2F</url>
    <content type="text"><![CDATA[Computer Architecture Von Neumann 体系结构主要由CPU(processor) + Memory ( data + fetch ) 数据的存储，访问和管理 操作系统 程序运行的过程: 执行指令 内存中fetch（取址）– decode（解码） – excuse（执行）具体的操作 冯诺依曼计算机模型 操作系统作用： 程序运行需要内存调度, 设备交互; OS 作用: 确保系统易于使用且高效运行； OS 如何实现程序的高效运行： 虚拟化: 将物理资源(CPU, 内存, 磁盘)转换为更通用, 更强大的虚拟形式; 标准库API: 用户与OS交互的接口, 告诉操作系统执行哪些功能; 资源管理器: OS充当的角色, 合理高效的分配资源 虚拟化CPU: 决定执行哪个程序； 虚拟化内存：数据结构的保存； 虚拟化 虚拟化CPU 硬件资源 + OS : 虚拟化实现多个CPU, 可移执行多个进程; 多进程的调度: OS有一定的机制 + 策略 虚拟化内存 程序的执行过程: 指令 和 数据都是保存在内存中的; OS将内存映射的足够: 程序执行的整个过程; 并发 在同一个内存空间中：运行的多个函数； 每次都有多个线程处于活动状态； 持久性 通过文件系统，对数据进行持久的保存 操作系统设计的目标 建立抽象：方便系统的调用； 高效性能：减少开销 提供保护：在应用程序之间，以及OS和应用程序之间提供保护 使用的方法：隔离 内存和地址 地址 CPU通过address找到存储单元，每个存储单元只能存一个byte，将数据放入存储单元中。 内存 内存的大小：却绝育CPU的地址空间； 32位：0x0000 0000 - 0xffff ffff 找存储位置，进行读 / 写操作。 CPU CPU总是周而复始地做同一件事 : 从内存取指令,然后解释执行它,然后再取下一条指令,再解释执行 CPU 包含功能单元 Register ： 是CPU内部的高速存储器，像内存一样可以存取数据，速度更快。 程序计数器 保存CPU取指令的地址，CPU读到地址后，按照地址去内存中取指令； 取完本次指令后，指向内存中的下一条指令 是CPU的特殊寄存器 指令解码器 算数逻辑单元 ALU 地址和数据总线 32位处理器有32条地址线和32条数据线 可以表示一个32位的数 设备 CPU除了访问内存外，还要访问很多Device 总线 总线：正因为地址线和数据线上可以挂多个设备和内存芯片所以才叫“总线”,但不同的设备和内存应该占不同的地址范围。 加载：操作系统在执行程序时，从硬盘拷贝到内存，这样CPU才可以取指令执行。 进程：程序加载到内存后，成为操作系统调度执行的一个任务。 中断：为了提供设备发送主动请求。 中断处理的步骤：先判断哪个设备引发的中断，然后调用该设备驱动程序提供中断处理函数。 Linux内核源代码：绝大部分是设备驱动程序。 设备驱动程序：是操作系统内核里的一组函数,主要是通过对设备寄存器的读写实现对设备的初始化、读、写等操作，有些设备还要提供一个中断处理函数供ISR调用。 CPU访问的类别 Memory Device 访问方式 按地址进行读写 按地址进行读写 访问操作 a按地址找到存储单元，进行读写 给设备发一个命令，数据不一定保存 集成在处理器的芯片访问方式 内存映射I/O，端口I/O 数据 只保存数据 产生新的数据 请求 被动等待读和写 主动发送请求 Memory Management Unit虚拟内存管理 VIrtual Memory Management 操作系统需要用VMM ：需要MMU的支持。 物理地址：处理器没有MMU，CPU执行单元发送的内存地址将直接传到芯片引脚，被内存芯片（物理内存）接受。 虚拟地址：CPU发送的内存地址被MMU捕获，从CPU到MMU的地址。 物理地址和虚拟地址 32位的CPU：指CPU的寄存器是32位，数据总线是32位，虚拟地址空间是32位。 物理地址的范围：取决于处理器芯片上的芯片引脚有多少条地址线， 虚拟地址映射带物理地址：MMU进行管理分配，具体细节就不聊了。 MMU 内存保护机制 MMU除了做地址转换（虚拟–物理）之外，还提供内存保护机制。 内存保护机制：操作系统设置的访问权限。 操作系统将虚拟地址空间划分为：用户空间和内核空间。 中断：从用户空间切换到内核空间，处理异常。（用户空间的切换，必须有中断发起） Memory Hierachy 计算机的存储器分为若干等级，按照离CPU的远近依次是： 寄存器，Cache，内存中的数据都是掉电易丢失； 寄存器访问：由程序指令直接控制之外；其他的存储器都不是由指令直接控制的。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Operate System</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu for ESP32 select development environment]]></title>
    <url>%2F2019%2F03%2F12%2FEsp32%2F</url>
    <content type="text"><![CDATA[ESP32开发环境的选择ESP-IDF for ESP32 通过gcc交叉编译进行开发 Esp32，开发类似于ESP8266，乐鑫官方提供相应的开发教程。 ESP32的SDK的编程指南，ESP-IDF编程指南 开发环境搭建 在Ubuntu下搭建ESP32开发环境 编译依赖工具 ESP32 的编译开发主要依赖两大核心工具，一个是乐鑫官方提供的ESP32交叉编译工具链，另外一个是python2.7。 配置工程，开始编译 有一个Bug，每次都要重新指定，ESPIDF的实际路径 1export IDF_PATH=/home/quronghui/HustFiles/Esp32/sources/esp-idf Arduino IDE for ESP32 arduino-esp32 主要是在Arduino IDE 中加载 Esp32 的core; PlatformIO for ESP32环境搭建 VS Code 中加载组件platform。 在platform 中加载ESP32的库。 基于ESP-IDF开发 使用ESP-IDF进行开发 例子的参考 espressif/esp-idf 基于Arduino 开发 开发平台选择arduino，这样就可以直接开发了 开发平台比较 在Ubuntu下进行开发 类别 ESP-IDF for ESP32 Arduino IDE for ESP32 PlatformIO for ESP32 环境搭建 有明确的文档 github有说明 直接加载平台就行 编译 编写makefile，指定IDF_PATH 平台操作 平台操作 下载 命令行 平台操作 平台操作 开发难度 目前来说有点难（make指令） 加载库 加载库 开发界面 vs code 不友好 vs code 选择 platformio]]></content>
      <categories>
        <category>Esp32</category>
        <category>Ubuntu Vs Code</category>
      </categories>
      <tags>
        <tag>Esp32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu for Arduino]]></title>
    <url>%2F2019%2F03%2F12%2FArduinoInUbuntu%2F</url>
    <content type="text"><![CDATA[Ubuntu for Arduino 将嵌入式设备的开发从Windows，迁移到了Linux下 Ubuntu + Vs Code + PlatfromIO Port Permission denied 问题：下载程序到arduino时，端口权限报错。 12Auto-detected: /dev/ttyACM0*** [upload] could not open port /dev/ttyACM0: [Errno 13] Permission denied: '/dev/ttyACM0' 重启后权限消失 12给端口权限sudo chmod 666 /dev/ttyACM0 永久权限 12sudo gedit /etc/udev/rules.d/70-ttyacm.rules // 添加权限文件KERNEL=="ttyACM[0-9]*",MODE="0666" // 添加权限文件 串口显示问题 问题：串口一直不能输出 解决：代码错误 1Serial.print("hello\n"); // 不是 printf("")]]></content>
      <categories>
        <category>Arduino</category>
        <category>PlatformIO</category>
      </categories>
      <tags>
        <tag>arduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Operator]]></title>
    <url>%2F2019%2F03%2F12%2FLinuxCoperator%2F</url>
    <content type="text"><![CDATA[LinuxC Operator 主要是介绍位运算符，通过位运算对整数进行操作。 位运算按位与、或、异或、取反 要进行数据类型的转换：Data Type 123unsigned char c = 0xfc;unsigned int i = ~c;result : ffffff03 先进行类型的提升，在进行转换。 移位运算 移位运算符(Bitwise Shift)包括 左移 &lt;&lt; 和 右移 &gt;&gt; 无符号的移位 左移将一个整数的各二进制位全部左移若干位 有符号的移位 不建议使用，减少出错 正数的高位移入0 移位运算中：不同进制数 和 不同的类型之间的区别 不同的进制数：同一个数用不同的方式进行表示 不同的类型：存储一个数所能提供的空间（位） 同一个数在不同的类型转换中，会发生溢出现象 掩码 对一个整数的某些位进行操作 1define ： mask = 0x0000ff00; //(定义一个32的存储类型int)对一个数的8-15位进行操作 其他运算符复合赋值运算符 在赋值的同时做一次运算 对于有 Side Effect 的表达式，影响是不同的。 Sizeof and typedef sizeof 是一个特殊的运算符：sizeof 表达式和 sizeof(类型名) sizeof(表达式)： （表达式）不进行求值计算，将（表达式）类型所占的字节数，作为整个sizeof(表达式)的值 sizeof（表达式）的值 = 是size_t类型的 size_t 类型名 C明确规定：sizeof 的值是无符号整形 1typedef unsigned long size_t; // 为了不同平台，规定size_t的类型 typedef 用于给一个类型取名字 12typedef unsigned long size_t; // size_t是一个类型，代表unsigned long的类型unsigned long size_t; // size_t是一个变量，变量的类型是unsigned long 123typedef char array_t[10];array_t a;// 定义了一个 char类型的 a[10] Side Effect and Sequence Point 造成的后果：结果出现Undefined Side effect : 针对函数调用过程中，先后顺序不确定，造成结果的Undefined. Sequence Point：调用一个函数时,在所有准备工作做完之后、函数调用开始之前。 1foo( f(), g()); //调用函数f(),g()的Side Effect发生的顺序不一定；等所有的Side Effect调用完了，才调用foo() short-circuit : 简写 &amp;&amp; || 的逻辑表达式 12a &amp;&amp; b // &amp;&amp;：a为真才调用b，写成if(a) b; a || b // ||: a为假才调用b, 写成 if(!a) b; Sequence Point 哪些地方是一个Sequence Point（序列点） 一个完整的操作前后都可以称之为Sequence Point； 完整的声明；完整表达式的末尾； “ ； ” 像printf 、scanf 这种带转换说明的输入/输出库函数,在处理完每一个转换说明相关的输/输出操作时是一个Sequence Point。 定义规则 在两个Sequence Point之间,同一个变量的值只允许被改变一次。 如果在两个Sequence Point之间既要读一个变量的值又要改它的值,只有在读写顺序确定的情况下才可以这么写。 错误示例 12int a=0;a = (++a)+(++a)+(++a)+(++a); //对变量a有5次Side Effect 1a[i++] = i; // 变量i的读写顺序不能确定 运算符总结 运算符的规则：也就是优先级 Bug 查错的规则：优先级的先后顺序 算数 &gt; 移位 &gt; 关系 &gt; 相等性 &gt; 按位操作 &gt; 逻辑操作 &gt; 条件运算符 &gt; 赋值 &gt; 逗号 左值和右值 左值的判断 在等号左边的表达式，并且能表示一个可以存储结果值的地点，通过左值表达式可以访问 12a = b + 25; //a就是一个左值，能保存表达式 b+25的值b+25 = a; // (b+25) 不能成为左值，虽然（b+25）表示一个值，但是不知道存储在某个角落 右值的判断]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>LinuxC Operator</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataType]]></title>
    <url>%2F2019%2F03%2F12%2FDataType%2F</url>
    <content type="text"><![CDATA[DataType整形 计算机的最小存储单位：Byte(不是bit) 1 Byte = 8 bits char 占一个 Byte 代码的可移植性 编译器规定 有无符号类型 C 规定的Implementation Defined C语言和平台和编译器密不可分的； ASCII 的取值范围是 0-127 这时候char存储一个ASCII，不必写明signed和unsigned 如果char表示8位的整数 为了可移植性就必须写明是signed还是unsigned 2’s Complement : 表示的是补码 Implementation-defined、Unspecified和Undefined implementation Unspecified C标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中； 这样即使用同一个编译器的不同版本来编译也可能得到不同的结果 因为编译器没有在文档中明确写它会怎么处理,那么不同版本的编译器就可以选择不同的处理方式。 Undefined C标准规定 除了char类型需要表明 signed 和 unsigned 其他整形不明确表明signed 和 unsigned，都表示有符号(-127-128)的数 容易造成访问越界的问题 整形数据需要表明有无符号 C规定用八进制和十六进制常量，代替二进制常量。 除了char是C明确规定占一个字节，其他的几个字节都是implementation 浮点型 float 型通常是32位，double型通常是64位。 浮点型的后缀和类型 double : 没有后缀 float : f / F 的后缀 long double : l / L的后缀 类型转换 C语法中最复杂的一部分 Integer Promotion char，short，Bit-field：提升为整形int表示，或者unsigned int 12unsigned char c1 = 255, c2 = 2;int n = c1 + c2; 最后结果是257，而unsigned char 范围是0-255; 是先把c1 和c2提升为int类型，然后相加得到的 Usual Arithmetic Conversion 两边运算的类型不同，低的类型往高的类型转换 赋值类型的转换 右边的类型转换为左边的类型，在进行赋值 编译器的类型转换处理 规则不用用来记的，而是用来排错误 数据转换最大的问题便是：造成越界或者溢出]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Data Type</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Number Of Computer]]></title>
    <url>%2F2019%2F03%2F12%2FNumberOfComputer%2F</url>
    <content type="text"><![CDATA[Number Of Computer进制间的转换 最高位和最低位 十进制转二进制 除二取余 余数倒着写便是 小数转换 十进制转换为二进制 乘二取整，顺序排列。 整数的加减运算 负数的加减运算 减法运算：取被减数的补码（取反加一） 采用补码做加减运算时总是忽略MSB的进位？、 判断溢出的办法是这样的:在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出,否则就说明产生了溢出。 带符号数和不带符号数 用8个bit既表示正数又表示负数,则能够表示的范围是-128~127, 8个bit全部表示正数,则能够表示的范围是0~255,前者称为有符号数(Signed Number), 后者称为无符号数。 浮点数 数的表示：模型的三部分 符号位 指数部分（表示2的多少次方） 尾数部分（只表示小数点后面的数字）–（需要将有效数字全部移到小数点后面） 尾数部分如何表示？ 尾数的规定 尾数必须以 0.1 开头]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Number of computer</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Assert]]></title>
    <url>%2F2019%2F03%2F07%2FLinuxCAssert%2F</url>
    <content type="text"><![CDATA[LinuxC AssertAssert Code Precondition : 代码的前提条件的测试； Maintenance：代码主要功能函数的测试； Postcondition：代码结果是否超过范围的测试 测试函数：简单的代码方式测试，主要是测试条件/结果是否为真 Shut Assert 测试代码只在开发和调试时有用，如果已经发布(Release)的软件还要运行这些测试代码就会严重影响性能了。 所以C语言规定,如果在包含assert.h 之前定义一个NDEBUG宏(表示NoDebug) 就可以禁用assert.h中的assert宏定义，代码中的assert就不起任何作用了: Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 折半查找* 项目1介绍：* (1)折半查找的前提是数组已经排序好；* （2）提供assert代码测试的思想*/#define NDEBUG /* 取消assert代码的相关测试 */#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#define LEN 8int a[LEN] = &#123;1, 3, 3, 3, 9, 5, 6, 7&#125;;int is_sorted()&#123; int i, sorted = 1; for (i = 1; i &lt; LEN; i++) sorted = sorted &amp;&amp; a[i-1] &lt;= a[i]; /* 保证序列是一个排序好的 */ return sorted;&#125;int mustbe(int start, int end, int number)&#123; int i; for (i = 0; i &lt; LEN; i++)&#123; if (i &gt;= start &amp;&amp; i &lt;= end) continue; if (a[i] == number) return 0; &#125; return 1;&#125;int binarysearch(int number)&#123; int mid, start = 0, end = LEN - 1; assert(is_sorted()); /* Precondition 前提条件测试 */ while(start &lt;= end)&#123; assert(mustbe(start, end, number)); /* Maintenance 主要函数测试 */ mid = (start + end) / 2; if(a[mid] &lt; number) start = mid + 1; else if (a[mid] &gt; number) end = mid - 1; else return mid; &#125; assert(mustbe(start, end, number)); /* Postcondition 测试最终的结果*/ return -1; &#125;int main(void)&#123; printf("where the element %d\n", binarysearch(3)); return 0;&#125;]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Assert</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Gdb]]></title>
    <url>%2F2019%2F03%2F04%2FLinuxCGdb%2F</url>
    <content type="text"><![CDATA[LinuxC Gdb Code link – Gdb的相关代码 gdb的命令 含义 gcc -g main.c -o main 编译成可调式文件 list list 显示linenum行周围的源程序list 显示函数名为functionlist // 显示后面10行的内容list - // 显示前面的程序 until （u） 直接运行到循环体结束 print x 按照十六进制格式显示变量； info 查看调试是各寄存器…信息 disassemble 用于反汇编 Gdb调试方式 程序中除了一目了然的Bug之外都需要一定的调试手段来分析到底错在哪 根据程序执行时的出错现象假设错误原因,然后在代码中适当的位置插入printf , 强大的调试工具gdb,可以完全操控程序的运行。 调试思想 分析现象 –&gt; 假设错误原因 –&gt; 产生新的现象去验证假设 单步执行和跟踪函数调用开始调试 gdb -g 编译 123456/** -g选项的作用是在目标文件中加入源代码的信息,比如目标文件中第几条机器指令对应源代码的第几行；* 但并不是把整个源文件嵌入到目标文件中,所以在调试时目标文件时必须保证gdb也能找到源文件。*/$ gcc -g main.cpp -o main -Wall $ gdb main gdb 命令help 12$ (gdb)help // gdb提供一个类似shell下输入help,可以查看命令的类别:$ (gdb)help files // 可以进一步查看某一类别中有哪些命令,例如查看files类别下有哪些命令可以用 列出源码 123$(gdb) list 1 //从第一行开始列出源代码，一次只能10行$(gdb) 回车 // 重复上一条命令$(gdb) l add_range // list命令可以用 l 来表示，列出一个函数的源代码 gdb quit 退出Gdb 调试环境 单步调试 next 主函数的调试 1234$ gdb main$ (gdb) start //开始执行程序$ (gdb) next //控制主函数的语句，一条条的执行（enter--重复上次命令）// 错误不在main()函数，而在功能函数里面 step 功能函数的调试 1234$ (gdb) start //开始执行程序$ (gdb) step //进入函数中执行$ (gdb) bt(backtrace) //查看函数调用的栈针$ (gdb) i locals // 查看功能函数，局部变量的值； main函数传进来的参数； main函数的栈帧编号为1，功能函数add_range 的栈帧编号为0 123456789101112zhi/*查看 main函数当前的局部变量的值*/$ (gdb) f(frame) 1 //选择1号栈帧，然后在查看局部变量$ (gdb) i locals // 查看主函数，局部变量的值；/*在step,跟几步看看*/$ (gdb) step //除了主函数，还有其他功能函数的值$ (gdb) finish //finish 一直运行到当前函数返回为止,得出当前的结果$ (gdb) p result //查看数组result的值，相当于print/*修改变量值，看还有没有其他bug*/$ (gdb) set var sum=0 //修改变量的值$ (gdb) finish print 调试命令{% asset_img GdbCommand.png 调试命令汇总 %} 总结 i locals 查看当前的局部变量，这个是最有用的。 查询功能函数的变量是否初始化。 通过条件语句来设置终端，这个挺好用的。 step 和 next 区别 step 用于调到功能函数； next 在调到功能函数的时候，单步执行 断点字符型和整形 字符型转化为整形： 整形＝字符型 － ‘０’的ASCII值 ASCII码值：’0’＝48; ‘\0’ = 0 断点加单步 单词断点流程 12345678$ gcc -g main.c -o main$ gbd main$ display sum //我们可以用display命令使得每次停下来的时候都显示当前sum值 //每输入一次print sum ; 打印一次当前的sum值，$ break 9 //break命令的参数也可以是函数名,(在第９行设置一个断点)$ continue //连续运行而非单步运行,程序到达断点会自动停下来,这样就可以停在下一次循环的开头。$ next //单步调试，深入内容 多个断点的设置 123456$ break 12 //设置另外一个断点$ i breakpoints //一次调试可以设置多个断点,用info命令可以查看已经设置的断点$ delete breakpoints 1 //删除编号为１的断点$ disable breakpoints 1 //通过禁用，而不用删除$ enable breakpoints 1 //enable 启用断点１ 条件断点 123$ break 9 if sum != 0 //在循环开头设置断点,但是仅当sum不等于0时才中断$ run //然后用命令,重新从程序开头连续执行:$ continue //连续执行到断点的时候停止 调试Bug Bug: 数组的末位含有一个 ‘\0’字符，printf打印的时候遇到’\0’就停止打印。 观察点 调试代码Breakpoint.cpp的代码一；数组越界的问题 代码逻辑 1234$ watch input[5] //设置input[5]为观察点$ info watchpoints //查看当前设置的观察点$ x/7b input //打印数组input才存储器的内容 //打印的是字符对应的十六进制ASCII的值 段错误 文章一直在强调，“scanf”函数是一个十分凶险的函数； 用户输入的值是不确定的； 造成数组的越界；’\0’的越界 造成段错误: Segmentation fault 运行逻辑 12$ run //运行代码，当出现错误的时候会自动停止运行$ bt //查看那个函数调用产生的错误 反汇编C和汇编穿插显示12gcc -g main.c -o main -Wall // 生成可执行文件objdump -dS main // 把C代码和汇编代码穿插起来显示 只生成汇编1gcc -S main.c //只生成汇编代码main.s,而不生成二进制的目标文件。 汇编调试12345(gdb) disassemble //可以反汇编当前函数或者指定的函数(gdb) si //step 命令可以一行代码一行代码地单步调试,而这里用到的si命令可以一条指令一条指令地单步调试。(gdb) info registers //可以显示所有寄存器的当前值。(gdb) p $esp //打印esp寄存器的值,// 在上例中esp 寄存器的值是0xbff1c3f4,所以x/20 $esp 命令查看内存中从0xbff1c3f4地址开始的20个32位数。 valgrind 查找程序中内存泄露和其他隐藏的内存问题; 安装教程 1sudo apt-get install valgrind 使用教程 1234// 编译: gcc -Wall -g valgrind_demo.c -o valgrind_demo// 执行条件 : valgrind --tool=memcheck --leak-check=full ./valgrind_demo// 将错误写进日志: valgrind --tool=memcheck --leak-check=full --log-file=mem_leak.log ./valgrind_demo// 和gdb一起调试: valgrind --tool=memcheck --leak-check=full --log-file=mem_leak.log gdb valgrind_demo 具体代码和调试结果 DDD图形界面调试工具 DDD (Data Display Debugger) DDD、GDB和被调试进程之间的关系：通信都是异步进行 1ddd --debugger arm-linux-gnueabihf-gdb &lt;要调试的程序&gt; Linux 内核调试工具 目标机“插桩”：打上KGDB补丁，主机上的GDB可与目标机的KGDB通过串口或网口通信； 仿真器：仿真器可直接连接目标机的JTAG/BDM； 在目标板上通过printk()，Oops，strace 等软件方法进行“观察”调试 KGDB 典型的嵌入式系统“插桩”工具，依赖于串口与调试主机通信； 串口驱动实现：轮询收发 printk() 将内核信息输出到内核信息缓冲区中； 内核信息缓冲区：是一个环形缓冲区（Ring Buffer); 如果塞入消息过多，则就会把之前的消息冲刷； /proc /proc虚拟文件系统，将内核信息输出给用户； 使用的命令：ps : 显示进程pid; top ：动态显示进行的状态 free ： 用于分析/proc/meminfo 得到的内存信息 Oops 当内核出现类似于用户空间的Segmentation Fault时，Oops会被打印到控制台和写入内核log缓冲区； 1cat /dev/globalmem // 读取设备中节点的段错误信息 strace 用于追踪系统调用命令的工具 总结 学C语言不可能不去了解底层计算机体系结构和操作系统的原理，不了解底层原理连一个scanf函数都没办法用好，更没有办法保证写出正确的程序。]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Gdb</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Coding Style]]></title>
    <url>%2F2019%2F03%2F04%2FLinuxCCodingStyle%2F</url>
    <content type="text"><![CDATA[LinuxC Coding Style Linux kernel Coding Style Thus, programs must be written for people to read, and only incidentally for machines to execute. 缩进和空白 双目运算符的两侧插入一个空格分隔,单目运算符和操作数之间不加空格, 1i = i + 1、++i 、!(i &lt; 1)、-x、&amp;a[1] ... ‘, ‘ 号和 ‘;’ 号之后要加空格, 这是英文的书写习惯 1for (i = 1; i &lt; 10; i++) 、foo(arg1, arg2) ... switch 的语句块 注释 顶头源文件的注释 整个源文件的顶部注释。说明此模块的相关信息,例如文件名、作者和版本历史等,顶头写不缩进。例如内核源代码kernel/sched.c的开头: 相对独立的语句注释 用 / hello / 注释尽量少用 标识符命名 .小写 内核风格规定变量、函数和类型采用全小写 加下划线的方式命名, 1上面举例的函数名radix_tree_insert、类型名struct radix_tree_root 大写 常量(宏定义和枚举常量enum)采用全大写加下划线的方式命名。 1常量名RADIX_TREE_MAP_SHIFT 全局变量和全局函数命名 全局变量和全局函数的命名一定要详细,不惜多用几个单词多写几个下划线 因为它们在整个项目的许多源文件中都会用到,必须让使用者明确这个变量或函数是干什么用的。 函数 执行函数： 执行函数就是执行一个动作,函数名通常应包含动词,例 如get_current、radix_tree_insert。 分割函数 多个.c的文件 功能函数 C语言中的功能函数包含动词 字母加下划线的方式进行。void insertion_sort() Indent Tools Indent Tools 将代码格式化为某种风格 12indent -kr -i8 main.c /* -kr 表示K&amp;R 的风格；-i8 表示TAB键缩进8个空格的长度 */cat main.c]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Array]]></title>
    <url>%2F2019%2F03%2F04%2FLinuxCArray%2F</url>
    <content type="text"><![CDATA[LinuxC ArrayCode link – Array 的相关代码 数组的基本操作 数组的定义和赋值 Bug 数组不可以相互赋值。 12int a[10], b[10];a = b; //这种赋值是错误的 也不能用数组类型作为函数的参数或者返回值，用的是指针传参。 数组应用 随机数的概念: 计算机执行每一条指令的结果都是确定的,没有一条指令产生的是随机数,调用C标准库。 得到的随机数其实是伪随机(Pseudorandom)数,是用数学公式算出来的确定的数,只不过这些数看起来很随机,并且从统计意义上也很接近均匀分布(Uniform Distribution)的随机数。 123$ int x = rand() % upper_bound; // upper_bound 表示生成的随机数的最大上边界// 以后定义随机数的上边界最大值是多少 编译器的工作原理 先是预处理 Preprocess; 然后才是 编译。编译的作用：翻译高级语言为可执行的二进制语言。 1gcc -E main.c 预处理 CPP C preprocessor 像 #include 和 #define 以#号开头的与法院诉称为预处理指示 C 标准库允许我们指定初值 1srand(time(NULL)); //srand 函数指定一个seed,调用当前系统时间距离1970年1月1日00:00:00的秒钟数，然后传给srand. 字符串 字符串可以看作一个数组,它的元素是字符型的。 字符串的打印和数组的打印不同。 字符串的最后一位，必须包含一个 ‘\0’ 这里的’ ‘\0’ 是ASCII码的八进制表示. 12char str[] = "hello,world.\n";printf("string: %s \n", str); Bug printf会从数组str 的开头一直打印到’\0’字符为止(‘\0’本身不打印)。 这其实是一个危险的信号:如果数组str 中没有’\0’,那么printf就会打印出界,后果和前面讲的数组访问越界一样诡异:有时候打印出乱码,有时候看起来没错误,有时候引起程序崩溃。 多维数组 多维数组 类似于结构体的嵌套； 一个数组的元素可以是另外一个数组 多维字符数组 通过下标访问字符串组成的数组可以代替一堆case分支判断,这样就可以把每个case 里重复的代码(printf 调用)提取出来,从而又一次达到了“提取公因式”的效果。 这种方法称为数据驱动的编程(Data-driven Programming): 写代码最重要的是选择正确的数据结构来组织信息,设计控制流程和算法尚在其次,只要数据结构选择得正确,其它代码自然而然就变得容易理解和维护了]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vsiual Studio]]></title>
    <url>%2F2019%2F03%2F01%2FVisiualStudio%2F</url>
    <content type="text"><![CDATA[Visual Studio 2017 for User快捷键的使用多行注释12注释多行：先按 Ctrl - K 组合键，再按 Ctrl - C 组合键取消注释多行：先按 Ctrl - K 组合键，再按 Ctrl - U 组合键]]></content>
      <categories>
        <category>Visiual Studio</category>
      </categories>
      <tags>
        <tag>Vs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QtAndVs]]></title>
    <url>%2F2019%2F03%2F01%2FQtAndVs%2F</url>
    <content type="text"><![CDATA[Qt and Visiual Studio 通过创建Qt GUI 的程序，实现按键的点击和事件的响应。 安装Qt并且关联Vs Vs 创建Qt 工程 创建例程 Qt Gui 文件的类型介绍。 （1）是Qt设计师文件，双击可以打开Qt可视化设计 （2）Qt界面的代码文件，Qt设计师设计的界面以代码的形式存储在这里，比如Button的位置，大小，名字。 （3）Widget类的头文件，定义一些字段和函数声明，包括最重要的slots（槽）函数的声明，以及界面ui句柄，以便通过“ui.***”的方式访问到界面的各个控件，比如访问界面的Label控件里的文字可以这样：ui.label-&gt;text();就是字面意思，很容易理解。 （4）资源文件，相当于AndroidStudio里面的rcs文件夹，里面存放需要用到的.ico图标或者图片。 （5）主函数文件，程序的入口，不必解释，其实一般不会在这个里面修改什么。 （6）Widget类完成的主要文件，在widget.h里面定义之后的字段以及函数声明，以及槽的实现，都是在这里，Qt的逻辑功能设计主要是修改这个文件。 添加事件发现的函数 – 槽函数 发生事件的方式（Click()） 槽函数：接收函数 他们之间的连接 1234567891011Widget::Widget(QWidget *parent) : QWidget(parent)&#123; ui.setupUi(this); connect(ui.checkBox,SIGNAL(clicked()),this,SLOT(on_checkBox_clicked())); connect(ui.checkBox_2, SIGNAL(clicked()), this, SLOT(on_checkBox_2_clicked())); connect(ui.pushButton, SIGNAL(clicked()), this, SLOT(on_pushButton_clicked()));&#125;// ui.checkBox : ui控件// SIGNAL(clicked()) : 发生事件的方式（Click()）// SLOT(on_checkBox_clicked()))：槽函数，响应事件的方式 Qt Gui 窗口大小 Qt Gui窗口大小的设置方式 1this-&gt;setWindowState(Qt::WindowMaximized); Vs and Qt 实现语音功能 Qt to speech 问题 无法打开QtTextToSpeech文件 在VC++ 中添加目录 1C:\Qt\Qt5.12.1\5.12.1\msvc2017_64\include\QtTextToSpeech 出现LNK2019 首先添加Qt的依赖库 和 lib文件目录 然后根据错误定位到QVoice，添加相关的头文件 不允许定义静态数据成员 dllimport 12代码使用：Qt 官方代码Qt使用导出类报错：error C2491: “QTextToSpeech::staticMetaObject”: 不允许 dllimport 静态数据成员 的定义:]]></content>
      <categories>
        <category>Qt Ui</category>
        <category>Visiual Studio</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect Sdk SkeletonStream]]></title>
    <url>%2F2019%2F03%2F01%2FKinectSdkSkeletonStream%2F</url>
    <content type="text"><![CDATA[Kinect Sdk SkeletonStream 网上的知识点 骨骼追踪技术通过处理景深数据来建立人体各个关节的坐标,骨骼追踪能够确定人体的各个部分。 骨骼追踪产生X,Y,Z的三维数据，从而确定这些骨骼点的坐标。 Gain Skeleton Data 骨骼数据来自：SkeletonStream KinectSensor对象有一个名为SkeletonFrameReady事件。 当SkeletonStream中有新的骨骼数据产生时就会触发该事件。 SkeletonStream产生的每一帧数据Frame，都是一个骨骼对象集合。 Kinect SDK在SkeletonStream对象 Kinect能够追踪到的骨骼数量是一个常量。 定义了一个能够追踪到的骨骼个数常量FrameSkeletonArrayLength，使用这个常量可以方便的对数组进行初始化。 SkeletonFrameReady事件的响应方法 每一次事件被激发时，通过调用事件参数的OpenSkeletonFrame方法就能够获取当前的骨骼数据帧。 剩余的代码遍历骨骼数据帧的Skeleton数组frameSkeletons，在UI界面通过关节点将骨骼连接起来，用一条直线代表一根骨骼。 骨骼数据的检测 使用Skeleton对象的 TrackingState 属性来判断，只有骨骼追踪引擎追踪到的骨骼我们才进行绘制。 Kinect能够探测到6个游戏者，但是同时只能够追踪到2个游戏者的骨骼关节位置信息。、、 绘制骨骼直线 CreateFigure方法为每一根骨骼绘制一条直线。 GetJointPoint方法以关节点的三维坐标作为参数，然后调用 KinectSensor 对象的MapSkeletonPointToDepth 方法将骨骼坐标转换到 深度影像坐标上去。 骨骼坐标系和深度坐标及彩色影像坐标系不一样，甚至和UI界面上的坐标系不一样。 三维数据处理 骨骼关节点的三维坐标中我们舍弃了Z值，只用了X,Y值。 可以发现图像的大小是和Z值(深度)成反的。深度值越小，图像越大，即人物离Kinect越近，骨骼数据越大。 Skeleton 对象模型 对象模型有四个最主要的对象，他们是SkeletonStream，SkeletonFrame，Skeleton和Joint。 SkeletonStream对象 Enable SkeletonStream对象，才能产生数据SkeletonFrame。 骨骼数据处理是很耗费计算性能的操作。打开骨骼追踪是可以观察的到CPU的占用率明显增加。当不需要骨骼数据时，关闭骨骼追踪很有必要。 骨骼关节点帧与帧之间的位置差异。 Enable SkeletonStream对象时，调用重载的方法传入一个TransformSmoothParameters参数。 SkeletonStream对象有两个与平滑有关只读属性：IsSmoothingEnabled和SmoothParameters。 SmoothParameters属性用来存储定义平滑参数。 骨骼追踪对象选择 默认情况下，骨骼追踪引擎会对视野内的所有活动的游戏者进行追踪。但只会选择两个可能的游戏者产生骨骼数据。 如果要自己选择追踪对象，需要使用AppChoosesSkeletons属性和ChooseSkeletons方法。 要手动选择追踪者，需要将AppChoosesSkeleton设置为true，并调用ChooseSkeletons方法，传入TrackingIDs已表明需要追踪那个对象。 SkeletonFrame SkeletonStream产生SkeletonFrame对象,使用事件模型从事件参数中调用OpenSkeletonFrame方法来获取SkeletonFrame对象. 调用SkeletonFrame 对象的 CopySkeletonDataTo方法将其保存的数据拷贝到骨骼对象数组. SkeletonFrame对象有一个SkeletonArrayLength的属性，这个属性表示追踪到的骨骼信息的个数。 时间标记字段 SkeletonFrame的FrameNumber和Timestamp字段表示当前记录中的帧序列信息。 FrameNumber和Timestamp这两个字段在分析处理帧序列数据时很重要 FrameNumber 是景深数据帧中的用来产生骨骼数据帧的帧编号。帧编号通常是不连续的，但是之后的帧编号一定比之前的要大。 FrameNumber是一个32位的整型 Timestap字段记录字Kinect传感器初始化以来经过的累计毫秒时间。 imestamp是64位整型 在未来SDK中加入手势引擎之前，我们需要自己编写算法来对帧时间序列进行处理来识别手势，这样就会大量依赖这两个字段。 Frame 描述信息 FloorClipPlane字段是一个有四个元素的元组Tuple&lt;int,int,int,int&gt;，每一个都是Ax+By+Cz+D=0地面平面(floor plane)表达式里面的系数项。 D 通常为负数，是Kinect距离地面高度。 Skeleton Skeleton类定义了一系列字段来描述骨骼信息，包括描述骨骼的位置以及骨骼中关节可能的位置信息。 骨骼数据可以通过调用SkeletonFrame对象的CopySkeletonDataTo方法获得Skeleton数组。 TrackingID 骨骼追踪引擎对于每一个追踪到的游戏者的骨骼信息都有一个唯一编号。 应用程序使用TrackingID来指定需要骨骼追踪引擎追踪那个游戏者。 这个值是整型，他会随着新的追踪到的游戏者的产生添加增长。(不连续的) Kinect追踪到了一个新的游戏者，他会为其分配一个新的唯一编号。 编号值为0表示这个骨骼信息不是游戏者的，他在集合中仅仅是一个占位符。 调用SkeletonStream对象的ChooseSkeleton能以初始化对指定游戏者的追踪。 TrackingState 该字段表示当前的骨骼数据的状态。 Position Position一个SkeletonPoint类型的字段，代表所有骨骼的中间点。 该字段提供了一个最快且最简单的所有视野范围内的游戏者位置的信息，而不管其是否在追踪状态中。 例如，应用程序可能需要追踪距离Kinect最近的且处于追踪状态的游戏者，那么该字段就可以用来过滤掉其他的游戏者。 ClippedEdges ClippedEdges字段用来描述追踪者的身体哪部分位于Kinect的视野范围外，提供了一个追踪这的位置信息。 该字段类型为FrameEdges，他是一个枚举并且有一个FlagsAtrribute自定义属性修饰。 FrameEdges 值 Kinect底座上面有一个小的马达能够调整Kinect的俯仰角度。 俯仰角度可以通过更改KinectSensor对象的ElevationAnagle属性来进行调整。 如果应用程序对于游戏者脚部动作比较关注，那么通过程序调整Kinect的俯仰角能够决绝脚部超出视场下界的情况。 KinectSensor的MaxElevationAngle和MinElevationAngle确定了可以调整角度的上下界。 任何将ElevationAngle设置超出上下界的操作将会掏出ArgumentOutOfRangeExcepthion异常。 微软建议不要过于频繁重复的调整俯仰角以免损坏马达。 Joints 该字段是一个JointsCollection类型，它存储了一些列的Joint结构来描述骨骼中可追踪的关节点(如head,hands,elbow等等) 应用程序使用JointsCollection索引获取特定的关节点，并通过节点的JointType枚举来过滤指定的关节点。 骨骼追踪引擎能够跟踪和获取每个用户的近20个点或者关节点信息。 关节点 都有类型为SkeletonPoint的Position属性， 他通过X,Y,Z三个值来描述关节点的控件位置。 X,Y值是相对于骨骼平面空间的位置，他和深度影像，彩色影像的空间坐标系不一样。 最后每一个Skeleton对象还有一个JointTrackingState属性]]></content>
      <categories>
        <category>Kinect SDK</category>
        <category>Kinect</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BluetoothANT]]></title>
    <url>%2F2019%2F02%2F28%2FBluetoothANT%2F</url>
    <content type="text"><![CDATA[Bluetooth ANT 蓝牙天线的设计使用，需要注意的一些事情。 无线传感技术 蓝牙技术：要求通讯灵敏度，还需要小型化，更需要低功耗，更重要的是要低成本。 硬件天线设计：IPEX接口外接天线和PCB板载天线。 天线 天线是一种用来发射或者接收电磁波的元器件，本质上可以说是一个能量转换器。 发射天线：将发射机的高频电流能量，有效地转换成空间的电磁能量； 接收天线：将空间中的电磁能量，转化为电流能量。 IPEX接口天线​ 信号的方向指向性好，效率高，抗干扰能力强; 能远离主板上的干扰 不用过多的进行调试匹配 PCB板载天线 PCB天线容易受到主板上的干扰，效率相对较低，牺牲性能。 因为近距离数据传输本身就比较稳定，所以蓝牙模块上的天线其实在近处时的效果是差不多的。但是距离远了，外置天线会有明显的优势。 倒F型天线 特点 状或者片状，当使用介电常数较高的绝缘材料时还可以缩小蓝牙天线尺寸 天线一般放置在PCB顶层，铺地一般放在顶层并位于天线附近，但天线周围务必不能放置地，周围应是净空区。 具体尺寸 曲流型天线设计 曲流型天线的长度比较难确定。长度一般比四分之一波长稍长，其长度由其几何拓扑空间及敷地区决定。 天线一般放置在PCB顶层，铺地一般放在顶层并位于天线附近，但天线周围务必不能放置地，周围应是净空区。 具体尺寸 陶瓷天线设计 陶瓷天线是另外一种适合于蓝牙装置使用的小型化天线。 陶瓷本身介电常数较PCB电路板高，所以使用陶瓷天线能有效缩小天线尺寸，在介电损耗方面，陶瓷介质也比PCB电路板的介电损失小，所以非常适合低耗电率的的蓝牙模块中使用。 在 PCB设计时，天线周围要净空就可以了，特别注意不能敷铜。 2.4G棒状天线设计 2.4G棒状蓝牙天线体积大，但传输距离要强于其他天线。在PCB设计时，天线周围也和上述的三种天线设计一样要净空。 蓝牙天线设计 天线的信号（频率大于400MHz以上）容易受到衰减，因此天线与附近的地的距离至少要大于三倍的线宽。 1GHz=1000MHz 1MHz=1000kHz 1kHz=1000Hz 过孔会产生寄生电感，高频信号对此会产生非常大的衰减，所以走射频线的时候尽量不要有过孔。 PCB 布线问题ANT 和 GND 相连 出现一种现象：RF射频线和GND相连报错。 因为这是RF信号，也就是微波。微波就不能当一般的数字，模拟信号来对待了。虽然用万用表量，这个天线与地是短路的。而对微波，其实这整个天线铜皮其实是相当于包括了很多电阻，电容，电感等组成的等效电路。 · ANT 天线没有盖油 如何查看是否盖油 Altium Design – &gt; 只显示 Top Sloder / Bottom Sloder 原因：CC2540 的元件，绘制的时候加了 top sloder 层，导致PCB生成Gerber文件的时候默认为开窗 如何解决： 找到对应天线的元件库，删除top sloder绘制的Track]]></content>
      <categories>
        <category>Bluetooth ANT</category>
      </categories>
      <tags>
        <tag>ANT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows SDK]]></title>
    <url>%2F2019%2F02%2F28%2FWindowsSDK%2F</url>
    <content type="text"><![CDATA[Windows SDK 参考的csdn上相关的知识 了解一些关于SDK开发的一些相关的知识 Windows程序分类 Windows控制台程序 C语言编写第一个“hello world”时，当时的程序就是控制台程序。 他的本质是DOS程序，没有自己的窗口， 你看到的输出Hello world的窗口是程序本身借用了操作系统的DOS窗口 windows窗口程序 123456int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) &#123;...&#125; // APIENTRY wWinMain windos窗口程序的入口 动态链接库dll 12345BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123;...&#125; Visual studio 下的工具 所在目录：C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin 1). 编译器 CL.exe ：将源代码翻译成目标代码。 2). 连接器 LINK.exe : 将目标代码、库连接生成最终文件。 3). 资源编译器RC.exe : 将资源编译，最终通过连接器存入最终文件 Visual studio 下的 lib 库 Kernel32. dll : 提供了线程、进程、内存管理等核心的API user32.dll : 提供了窗口、消息等API gdi32.dll : 提供了绘图的API]]></content>
      <categories>
        <category>Windows SDK</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxC Struct]]></title>
    <url>%2F2019%2F02%2F27%2FStruct%2F</url>
    <content type="text"><![CDATA[Code link – struct 的相关代码 LinuxC Struct 学习一门语言要注意的三点 本节将以结构体为例来讲解数据类型的组合和抽象。 结构体 代码链接 结构体定义 过程抽象：将一组语句通过函数名封装Tag，当做整体调用 结构体 12345结构体：complex_struct不表示变量，而是表示类型,类似于int的符合类型 struct complex_struct &#123; double x, y; /* data */ &#125;z; 结构体的变量使用 12345678910结构体变量的初始化和使用（1）Ways1 double x = 3.0; // 不等同于Tag的z.x； z.x = x; // 变量访问成员，通过z.x z.y = 4.0; (2) Ways:定义的时候直接初始化 struct complex_struct z = &#123; 3.0, 4.0 &#125;; (3)错误的初始化 struct complex_struct z1; z1 = &#123; 3.0, 4.0 &#125;; 结构体当做函数的参数使用 123456789103. 项目描述：将结构体当做函数的参数和返回值来传递（1）结构体当做函数的参数，比如 int main,中的int(2) struct complex_struct 当做函数 add_complex的参数struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2)&#123; z1.x = z1.x + z2.x; z1.y = z1.y + z2.y; return z1; &#125; Data Abstraction (数据抽象) ​ gcc编译时提示对‘sqrt’未定义的引用 1gcc -*.c -lm // 需要链接 libm.so 库 将复数运算的代码分成块的时候，报错 代码还没有解决。DataAbstraction.cpp ​ 解决成功 123456为了避免其他文件引用DataAbstraction.h，造成重复定义的问题： add code: #ifndef _TEST_H_ #define _TEST_H_ &#123; ... &#125; #endif 数据类型的标志 也就是设立 flag （0/1）标志位 Enum 标志位 12345// 枚举类型：枚举类型的成员和变量名在同一个空间，不能定义成同样的名字。enum coordinate_type // 类似于Struct的Tag,enum代表的是枚举类型&#123; // 代表常量Rectangular（直角坐标） == 0 ； Rectangular, Polar // 代表常量Polar(极坐标) == 1&#125;; 还没有实现如何结合struct Tag 一起使用 Enum 可以实现递增赋值的Tag 1enum Month &#123;Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,dec&#125; a,b; 结构体的嵌套 结构体有数据类型定义，结构体本身便是一种数据类型，可以进行嵌套。 1234567struct Segment&#123; struct complex_struct start; struct complex_struct end;&#125;;struct complex_struct&#123; double x,y;&#125;; 访问结构体的成员应该用多个 . 运算符 12s.start.x = 1.0;s.start.y = 2.0;]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect SDK for DepthImageStream]]></title>
    <url>%2F2019%2F02%2F27%2FKinectSDKDepthImageStream%2F</url>
    <content type="text"><![CDATA[Kinect SDK for DepthImageStream 网上的知识点 KinectSensor的最主要功能之一就是能够产生三维数据，它有红外发射器和红外摄像头。 介绍了Kinect红外传感器，景深数据格式，景深图像的获取与展示，景深图像的增强处理 ColorImageStream 数据流的获取 DepthImageStream和ColorImageStream都继承自ImageStream 景深影像数据从DepthImageFrame产生，它由DepthImageStream对象提供 景深帧数据 红外摄像机的视场是金字塔形状的。离摄像机远的物体比近的物体拥有更大的视场横截面积。这意味着影像的高度和宽度，比如640X480和摄像机视场的物理位置并不一一对应。 深度帧数据中，每个像素占16位，这样BytesPerPixel属性，即每一个像素占2个字节。每一个像素的深度值只占用了16个位中的13个位。 ​ 深度值存储在第3至15位中，要获取能够直接使用的深度数据需要向右移位 SDK在DepthImageFrame类中定义了一个常量PlayerIndexBitmaskWidth，它定义了要获取深度数据值需要向右移动的位数。 UI界面显示 在UI界面中Image空间的属性中，宽度和高度是硬编码的。如果不设置值，那么空间会随着父容器（From窗体）的大小进行缩放，如果空间的长宽尺寸和深度数据帧的尺寸不一致，当鼠标点击图片时，代码就会返回错误的数据，在某些情况下甚至会抛出异常。 景深图像处理增强灰度级 增强深度值图像： 按位翻转像素值。 图像的颜色是基于深度值的，他们从0开始。在数字光谱中0表示黑色，65536(16位灰阶)表示白色。 所有的不能确定深度值的数据都设置为了0 增强深度值图像 格式的转换 彩色影像的格式为了Bgr32位，每一个R,G,B分别占8位，剩余8位留用 这种模式限制了RGB的取值为0-255，所以需要将深度值转换到这一个范围内。 将深度值除以4095（13位的深度值，[2^13 -1] / 2），然后乘以255，这样就可以将深度数据转换到0至255之间了. 数据的处理 每一次当KinectSensor触发frame-ready事件时，代码顺序存储彩色影像。转换完成后，backgroud线程使用WPF中的Dispatcher来更新UI线程中Image对象的数据源。 这种异步的操作在基于Kinect开发的应用中很常见，因为获取深度数据是一个很频繁的操作。如果将获取数据以及对数据进行处理放在主UI线程中就会使得程序变得很慢。 景深数据处理 Kinect深度值最大为4096mm，0值通常表示深度值不能确定，一般应该将0值过滤掉。微软建议在开发中使用[1220mm（4’）~3810（12.5’)范围内的值。在进行其他深度图像处理之前，应该使用阈值方法过滤深度数据至1220mm-3810mm这一范围内。 可以绘制直方图 Opencv 处理景深数据处理 基于Kinect的应用程序不会对深度数据进行很多处理。如果要处理数据，也应该使用一些类库诸如OpenCV库来处理这些数据。 应用程序处理深度数据目的是用来确定人体在Kinect 视场中的位置。 对物体进行测量 c# 例子代码参考 每一个摄像机都有视场，焦距的长度和相机传感器的大小决定了视场角。Kinect中相机的水平和垂直视场角分别为57°和43°。 知道了底边的长度，我们就可以将像素的宽度转换为现实中的宽度。 1234（1）计算出等腰三角形底边的宽度为1500mm；（2）游戏者所占有的总象元的宽度为100；（3）深度影像数据的总象元宽度为320；实际宽度：（1500 / 320）*100 = 468.75mm 实现方式 1）先创建一个新的项目然后编写发现和初始化KinectSensor的代码，将DepthStream和SkeletonStream均初始化，然后注册KinectSnsor的DepthFrameReady事件。 2）CalculatePlayerSize方法遍历深度图像中的象元，然后提取游戏者索引位及其对应的深度值。 3）对于游戏者的每一个象元，方法调用PlayerDepthData对象的UpdateData方法。处理完所有象元之后，将游戏者数组复制给名为PlayerDepthData的ItemControl对象的数据源。 本文首先介绍了关于景深数据的简单图像数据，包括景深数据的直方图显示以及一些图像处理相关的算法，然后介绍了景深数据中的游戏者索引位，借助索引位，我们实现了人物宽度和高度的计算，最后借助景深数据结合彩色影像数据，将景深影像和视频图像进行了叠加。]]></content>
      <categories>
        <category>Kinect SDK</category>
        <category>Kinect</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect Sensor]]></title>
    <url>%2F2019%2F02%2F27%2FKinectSensor%2F</url>
    <content type="text"><![CDATA[Kinect Sensor 网上的知识点 Kinect 设备的硬件介绍 Kinect设备 基座和感应器之间有一个电动的马达，通过程序能够调整俯仰角度; 在上面的感应器中有一个红外投影仪，两个摄像头，四个麦克风和一个风扇。、 最左边是红外光源，其次是LED指示灯 中间的是彩色摄像头，用来收集RGB数据 最右边是红外摄像头用才采集景深数据 成像大小 彩色摄像头最大支持1280*960分辨率成像 红外摄像头最大支持640*480成像 麦克风阵列 一个在左边的红外发射器下面， 3个在右边景深摄像头下面 Kinect in windows 环境的搭建方式。 kinect in windows]]></content>
      <categories>
        <category>Kinect</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Application For Ubuntu]]></title>
    <url>%2F2019%2F02%2F26%2FApplicationForUbuntu%2F</url>
    <content type="text"><![CDATA[Application For Ubuntuupdate1234$ sudo apt update // 搜索可以更新$ apt list --upgradable // 可以看看有哪些可更新的软件$ sudo apt upgrade // 行更新操作$ sudo apt autoremove //更新完成之后会有一些不需要的旧组件需要清除 VS code安装1234sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-makesudo apt-get updatesudo apt-get install ubuntu-makesudo umake ide visual-studio-code 配置C/C++编译环境 C/C++ VS 更新123$ sudo wget https://vscode-update.azurewebsites.net/latest/linux-deb-x64/stable -O /tmp/code_latest_amd64.deb$ sudo dpkg -i /tmp/code_latest_amd64.deb$ 关闭vs code，然后再次打开会看到release note的页面，说明已经完成更新。 vs code 代码能编译通过，但是头文件全是红色 删除文件夹下的 .vscode 相当于重新建立索引，应该就能解决。 PDF阅读器Okular1$ sudo apt-get install okular Typora1234sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAEsudo add-apt-repository 'deb http://typora.io linux/'sudo apt-get updatesudo apt-get install typora Sougou link 12Download : http://pinyin.sogou.com/linux/ sudo dpkg -i sogoupinyin_2.1.0.0082_amd64.deb Arduino link Extensions 安装 搜索 arduino vs code –&gt; 首选项 –&gt; 设置 –&gt; 搜索arduino –&gt; 设置 arduino.path 123456查看软件安装目录： $ aptitude show sublime-text-installer //列出软件信息 $ dpkg -l //列车所有安装的软件 $ dpkg -l firefox //列出firefox 软件安装信息 $ dpkg -L 软件名 //没有在PATH路径下保存，通过下面命令寻找安装目录 Screenshot ubuntu 自带的截图工具 用用软件进行下载更新 Port Question查看设备的 Serial Devide123cd /devls ttyUSB* //esp32的端口Serial查询ls ttyACM* //arduino 端口的serial Port Permission denied 问题：下载程序到arduino时，端口权限报错。 12Auto-detected: /dev/ttyACM0*** [upload] could not open port /dev/ttyACM0: [Errno 13] Permission denied: '/dev/ttyACM0' ('/dev/ttyUSB0') 重启后权限消失 12给端口权限sudo chmod 666 /dev/ttyACM0 ('/dev/ttyUSB0') 永久权限 123sudo gedit /etc/udev/rules.d/70-ttyacm.rules('/dev/ttyusb') // 添加权限文件KERNEL=="ttyACM[0-9]*",MODE="0666" ('/dev/ttyUSB0') // 添加权限文件reboot Vi 编辑时上下左右键出现字母 ubuntu默认安装装的是vim tiny版本，而需要的是vim full版本。 12$sudo apt-get remove vim-common$sudo apt-get install vim 环境变量的设置 配置/etc/enviroment 1234sudo su // 用户权限vi /etc/enviromentPATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/quronghui/HustFiles/Esp32/crossTools/xtensa-esp32-elf/binsource /etc/enviroment //使之生效 配置 /etc/profile （这个不用配置） 1234sudo su // 用户权限vi /etc/profileexport PATH=/home/yan/share/usr/local/arm/3.4.1/bin:$PATHsource /etc/profile //使之生效 Linux 下的串口 minicom 123456789sudo apt-get install minicomsudo minicom // 需要在root权限下开启minicomctrl-a o //进入端口配置,先按下 Ctrl + a;放开Ctrl + a，按下 oselect ：A //修改端口 和 波特率change : /dev/ttyUSB0select : Save setup as dflctrl-a x // 退出minicon 查看已安装文件的目录 dpkg 12dpkg -l "*sougou*" //来查看软件的状态。dpkg -P //来卸载软件,或者 dpkg --purge完全删除,包括配置文件 查看目录 12ps -e //查看软件对应的名字sudo find / -name "platform" //查询得到软件的目录 设置PlatformIo 串口的波特率单次修改串口波特率12stty -F /dev/ttyUSB0 //查看Usb的属性 stty -F /dev/ttyUSB0 115200 //修改usb的波特率 修改默认值 进入platformIO的python目录 1/home/quronghui/.platformio/penv/lib/python2.7/site-packages/serial/tools 给权限并且修改内容 12345678chmod 777 sudo miniterm.py/*********find***************/parser.add_argument( "baudrate", // 修改波特率这一栏就可以了 nargs='?', type=int, help="set baud rate, default: %(default)s", default=115200) # default这里改成你想要默认的波特率，115200 然后删除本目录下的miniterm.pyc文件，再次开启串口监视器时会重新编译生成此文件。 声卡无声音 Ubuntu 18没有声音 解决方式参考 git clone 速度慢 git clone https:// 克隆的是工程所有的提交历史quronghui 克隆最近一次的commit，然后更新得到所有的提交历史 123$ git clone http://github.com/large-repository --depth 1$ cd large-repository$ git fetch --unshallow 配置shadowsocket git ubuntu18 误删除 /etc/shadow/etc/shadow 是Ubuntu系统的登录和权限认证的文件 保存了密码 如何进行恢复 参考博客 进去recovery 编辑模式 这里不是 Enter选中，而是直按下e 按e进入如下界面，找到图中红色框的recovery nomodeset并将其删掉，再在这一行的后面输入quiet splash rw init=/bin/bash 我的系统后面没有 find_pressed …. 我是加上后才成功的 接着按F10后出现如下界面 1passwd username // 一定要加用户名，不然修改后不能成功 reboot 重启一直报错 1reboot -f 流程图工具 Reference 安装Eagle 安装方式 Autodesk student eagle for Linux 报错 1./eagle: symbol lookup error: /usr/lib/x86_64-linux-gnu/libGLX_mesa.so.0: undefined symbol: xcb_dri3_get_supported_modifiers 安装WPS 下载wps for linux WPS官网下载deb包：http://linux.wps.cn/ wps_symbol_fonts.zip: https://pan.baidu.com/s/1eS6xIzo 安装 1234$ sudo dpkg -i xxx$ cd wps_symbol_fontsls$ sudo cp mtextra.ttf symbol.ttf WEBDINGS.TTF wingding.ttf WINGDNG2.ttf WINGDNG3.ttf /usr/share/fonts$ sudo apt-get remove libreoffice-common 安装Google123$ sudo wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb // download$ sudo dpkg -i google-chrome*$ sudo apt-get -f install Ubuntu 查看目录12345$ sudo snap install tree // 安装tree应用$ tree -a // 像树一样显示目录结构$ tree -d #仅显示目录$ tree -L n #n代表数字..表示要显示几层...$ tree -f #显示完整路径.. 生成 GitHub README.md 目录 gh-md-toc 项目在 Ubuntu 和 macOS 上测试过。如果要在 Windows 上使用，使用基于 golang 的实现：github-markdown-toc.go。而且很重要的一点是，它不需要安装额外的依赖。 12$ wget https://raw.githubusercontent.com/ekalinin/github-markdown-toc/master/gh-md-toc$ chmod a+x gh-md-toc 使用方式: 通过本地输出后复制到README.md 12345678$ /gh-md-toc ~/projects/Dockerfile.vim/README.md Table of Contents================= * [Embedded-written-reference](#embedded-written-reference) * [Contents](#contents) * [7.30诺瓦科技](#730诺瓦科技) * [8.1大疆嵌入式参考](#81大疆嵌入式参考) * [8.3网易笔试](#83网易笔试)]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect SDK for ColorImageStream]]></title>
    <url>%2F2019%2F02%2F26%2FKinect%20SDK%20for%20ColorImageStream%2F</url>
    <content type="text"><![CDATA[Kinect SDK for ColorImageStream 网上的知识点 通过安装的SDK包，看相应的代码 下面介绍如何发现以及初始化Kinect传感器，从Kinect的影像摄像头获取图片。 Kinect Sensor 基于Kinect开发的应用程序最开始需要用到的对象就是KinectSensor对象，该对象直接表示Kinect硬件设备。 KinectSensor对象是我们想要获取数据。包括ColorImageStream，DepthlmageStream和SkeletonStream。 从KinectSensor获取数据：通过监听该对象的一系列事件。 每一个数据流以帧(frame)为单位。 每一种数据流都有对应的事件，当改类型数据流可用时，就会触发改时间。 ColorImageStream：触发ColorFrameReady事件 KinectSensor数据流形式 每一种数据流(Color,Depth,Skeleton)都是以数据点的方式，在不同的坐标系中显示的 inectSensor对象有一些列的方法能够进行数据流到数据点阵的转换 123MapDepthToColorImagePoint；MapDepthToSkeletonPoint；MapSkeletonPointToDepth Kinect 设备的发现和引用 通过SDK探测有无Kinect连接 123（1）KinectSeneor对象有一个静态的属性KinectSensors（2）该属性是一个KinectSensorCollection集合，该集合继承自ReadOnlyCollection（3）ReadOnlyCollection集合很简单，他只有一个索引器和一个称之为StatusChanged的事件 Kinect 的初始化 12When : Connect --- 才进行赋值操作 not connect --- KinectSensor对象抛出InvalidOperationException异常 Load and Unload 事件 1234（1）窗口的Loaded事件中程序通过DiscoverKinectSensor方法试图调用一个连接了的传感器（2）窗体的Loaded和Unloaded事件中注册这两个事件用来初始化和释放Kinect对象note : DiscoverKinectSensor方法只有两行代码，第一行代码注册StatusChanged事件，第二行代码通过lambda表达式查询集合中第一个处在Connected状态的传感器对象，并将该对象复制给Kinect属性。Kinect属性的set方法确保能都赋值一个合法的Kinect对象。 StatusChanged事件: 当状态为KinectSensor.Connected的时候，if 语句限制了应用程序只能有一个kinect传感器，他忽略了电脑中可能连接的其他Kinect传感器。 以上代码展示了用于发现和引用Kinect设备的最精简的代码。 Kinect Sensor 的打开和关闭 Connect 初始化传感器 Enable 数据流 ：Color,Depth,Skeleton 数据流使用：使用Kinect对象的一些列事件 1234ColorImageStream ---- ColorFrameReady 事件DepthImageStream ---- DepthFrameReady事件SkeletonStream ---- SkeletonFrameReady事件 AllFramesReady 事件在任何一个数据流状态enabled时就能使用 应用程序调用KinectSensor对象的Start方法 frame-ready事件就会触发从而产生数据 Stop Kinect 先检测Kinect sensor 是否为空；然后监听frameready事件 1Using KinectSensor对象的 : Stop ways 应用程序在不需要使用KinectSensor对象时，释放这些资源 12Stop ways 注销frameready事件 Notes (1)不要去调用KinectSensor对象的Dispose方法。这将会阻止应用程序再次获取传感器。 (2)应用程序必须从启或者将Kinect从新拔出然后插入才能再次获得并使用对象 ColorImageStream 的获取 初始化和释放KinectSensor和ColorImageStream对象 12345if (value!=null&amp;&amp;value.Status==KinectStatus.Connected)&#123; this.kinect=value; InitializeKinectSensor(this.kinect);&#125; InitializeKinectSensor对象 ：调用ColorImageStream的Enable方法，注册ColorFrameReady事件并调用start方法。 一旦打开了传感器，当新数据帧大道是就会触发frameready事件，该事件触发频率是每秒30次。 123456if (kinectSensor != null) &#123; kinectSensor.ColorStream.Enable(); kinectSensor.ColorFrameReady += new EventHandler&lt;ColorImageFrameReadyEventArgs&gt; (kinectSensor_ColorFrameReady); kinectSensor.Start(); &#125; 数据显示 ）ColorFrameReady方法中：打开或者获取一个frame来提取获Frame数据。 ）ColorImageFrameReadyEventArgs对象中的OpenColorImageFrame属性：返回一个当前的ColorImageFrame对象。 ）ColorImageFrame对象：提取像素数据之前需要使用一个Byte数组保存获取到的数据。 ）FrameObject对象的PixelDataLength对象返回数据和序列的具体大小。 ）调用CopyPixelDataTo方法可以填充像素数据，然后将数据展示到image控件上。 图像数据获取方式的改进 知识参考 WriteableBitmap对象 它位于System.Windows.Media.Imaging命名空间下面，该对象被用来处理需要频繁更新的像素数据。（之前是更新30幅图像 / 每秒） 创建WriteableBitmap时，应用程序需要指定它的高度，宽度以及格式，以使得能够一次性为WriteableBitmap创建好内存，以后只需根据需要更新像素即可。 图像的处理 每一帧ColorImageFrame都是以字节序列的方式返回原始的像素数据：对这些原始数据进行一定的处理，然后再展示出来。 for循环遍历每个像素，由于数据的格式是Bgr32，即RGB32位(一个像素共占4个字节，每个字节8位)，所以第一个字节是蓝色通道，第二个是绿色，第三个是红色。 循环体类，将第一个和第二个通道设置为0.所以输出的代码中只用红色通道的信息。这是最基本的图像处理。 截图 可能需要从彩色摄像头中截取一幅图像，例如可能要从摄像头中获取图像来设置人物头像。为了实现这一功能，首先需要在界面上设置一个按钮。 图片数据格式介绍 ImageStream是ColorImageStream的基类。因此ColorImageStream集成了4个描述每一帧每一个像素数据的属性。在之前的代码中，我们使用这些属性创建了一个WriteableBitmap对象。这些属性与ColorImageFormat的设置有关。 ImageStream中除了这些属性外还有一个IsEnabled属性和Disable方法。IsEnabled属性是一个只读的。当Stream打开时返回true，当调用了Disabled方法后就返回false了。Disable方法关闭Stream流，之后数据帧的产生就会停止，ColorFrameReady事件的触发也会停止。 当ColorImageStream设置为可用状态后，就能产生ColorImageFrame对象。ColorImageFrame对象很简单。他有一个Format方法，他是父类的ColorImageFormat值。他只有一个CopyPixelDataTo方法，能够将图像的像素数据拷贝到指定的byte数组中，只读的PixelDataLength属性定义了数组的大小PixelDataLength属性通过对象的宽度，高度以及每像素多少位属性来获得的。这些属性都继承自ImageFrame抽象类。 数据流的格式决定了像素的格式，如果数据流是以ColorImageFormat.RgbResolution640480Fps30格式初始化的，那么像素的格式就是Bgr32，它表示每一个像素占32位(4个字节)，第一个字节表示蓝色通道值，第二个表示绿色，第三个表示红色。第四个待用。当像素的格式是Bgra32时，第四个字节表示像素的alpha或者透明度值。如果一个图像的大小是640480，那么对于的字节数组有122880个字节(widthheightBytesPerPixel=6404804).在处理影像时有时候也会用到Stride这一术语，他表示影像中一行的像素所占的字节数，可以通过图像的宽度乘以每一个像素所占字节数得到。 ImageStream 数据获取的方式事件模式 目前为止我们都是使用KinectSensor对象的事件来获取数据的。事件在WPF（为不同用户界面提供统一的显示系统（ Windows Presentation Foundation））中应用很广泛，在数据或者状态发生变化时，事件机制能够通知应用程序。 “拉”模式 采用拉模式获取数据的性能应该好于事件模式。 唯一不能使用事件模型获取数据的情况是在编写非WPF平台的应用程序的时候。比如，当编写XNA或者其他的采用拉模式架构的应用程序。建议在编写基于WPF平台的Kinect应用程序时采用事件模式来获取数据。只有在极端注重性能的情况下才考虑使用“拉”的方式。]]></content>
      <categories>
        <category>Kinect SDK</category>
        <category>Kinect</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect in Windows]]></title>
    <url>%2F2019%2F02%2F20%2FKinect%20in%20Win%2F</url>
    <content type="text"><![CDATA[[TOC] Kinect in Windows Kinect in Windows 开发指南 kinect + opencv + vs 环境配置 安装 Kinect SDK Bug 首次安装KinectSDK-v1.8-Setup 连上kinect后，打开一次后，第二次打开提示 “ No kinet to connect ” 重新卸载后，安装KinectSDK-v1.7-Setup，成功 在官方网站下载Kinect for Windows SDK和Developer Toolkit： 参考教程 KinectSDK-v1.7-Setup.exe KinectDeveloperToolkit-v1.7.0-Setup.exe 安装成功后，连上kinect, 设备管理器出现 “ Kinect for windows ” 通过kinect tools 测试 XBox的好坏 安装 Visual StudioVS2017 安装教程 Download Visual Studio Community免费版 选择工作负载这里仅勾选”使用C++的桌面开发”，单个组件和语音包使用默认 按照需要选择要安装的模块（但是我下载后没有已安装的选项） VS2017的文件目录 C:\Users\quronghui\source\repos 安装注意 直接安装VS2017，并且卸载完之前安装的VS2015版本（如果可以的话直接升级） 我的是因为之前安装的VS2015 ios镜像不成功，卸载不完全，导致的系统重装. Mircosoft 的软件安装的时候，不要中途暂停，不然容易造成卸载不了的问题 解决方案 重装系统后，直接安装VS2017，这样就不会报错了 因该是以前装VS其他版本没有卸载干净，导致的后果 Kiinect SDK 关于 VS 的配置 Kiinect SDK 关于 VS 的配置 使用VS进行开发的话，需要配置include和lib路径 进入VS，右键-项目属性，Debug + x64，选择VC++Directories: 1234Debug and Release 都要添加 Include files : add C:\Program Files\Microsoft SDKs\Kinect\v1.7\inc； Library files : add C:\Program Files\Microsoft SDKs\Kinect\v1.7\lib\x64； 链接器 : add Kinect10.lib C:\Program Files\MicrosoftSDKs\Kinect\v1.6\inc 目录下有： 1234- NuiApi.h ---包含所有的NUI(自然用户界面) API头文件和定义基本的初始化和函数访问入口。这是我们C++工程的主要头文件，它已经包含了NuiImageCamera.h 和 NuiSkeleton.h。- NuiImageCamera.h ---定义了图像和摄像头服务的API，包括调整摄像头的角度和仰角，打开数据流和读取数据流等。- NuiSkeleton.h ---骨架有关的API，包括使能骨架跟踪，获取骨架数据，骨架数据转换和平滑渲染等。- NuiSensor.h ---音频API，包括ISoundSourceLocalizer接口，用于返回声源的方向（波束形成）和音频的位置。 安装 OpenCV 本次安装的opencv，是为了迁移上一个工程师的代码，所以opencv的版本需要一致才能编译成功。 opencv 2.4.6.0，vc10 提取码：f3pz Opencv 的安装和配置教程 Opencv 的安装 我是直接复制工程师的 opencv 解压包，只是进行依赖链接的配置。 环境变量 Opencv Start Dll 文件的复制 dll 文件都在安装的opencv的 bin 目录下 12copy : opencv_ffmpeg .dll to C:\Windows\System32copy : opencv_other .dll to C:\Windows\SysWOW64 Opencv With VS2017 VS 属性中（ Include Direction）: 12345Include Direction： C:\Software\opencv\opencv\includeC:\Software\opencv\opencv\build\include\opencvC:\Software\opencv\opencv\build\include\opencv2C:\Software\opencv\freetype\include // 为了在opencv里面检测的图片上加上字 VS 属性里面的 库目录 12Library Direction: C:\Software\opencv\opencv\build\x64\vc10\lib VS 属性 – 链接器 – 输入项 – 附加依赖项 1234567" **在 Debug x64 下面进行配置**"Link : opencv_core246d.lib // lib 库下面 opencv_xxx "d" : 代表的是Debug版本使用的库 opencv_highgui246d.lib opencv_video246d.lib opencv_imgproc246d.lib opencv_photo246d.lib 1234567" **切换 Release x64 下面进行配置**"Link : opencv_core246.lib // lib 库下面 opencv_xxx : 代表的是Release版本使用的库 opencv_highgui246.lib opencv_video246.lib opencv_imgproc246.lib opencv_photo246.lib 安装QTQT 的安装 安装方式 1234Notes: QT组件的选取： MSVC 2017 64-bit : VS2017 的QT编译器 MinGW 5.3.0 32 bit : gcc 的编译器吧 QT with VS2017 配置方式 Notes 123456VS 属性 -- 链接器 -- 输入项 -- 附加依赖项 ：加入QT. lib如果报错再加入： qtmain.lib Qt5Core.lib Qt5Gui.lib Qt5Widgets.lib 代码迁移后需要改动VS 的项目 – 配置属性 VC ++ 目录 ： 下面的包含目录和库目录。 注意修改迁移项目的目录链接。 （之前背的工程师的SDK or opencv 放在其他的目录下） Qt Meta-Object Complier: Include Path C/C++ 目录 常规 – 附加包含目录： 所有选项 – 附加包含目录 计算机中丢失 MSVCP100D.dll 代码迁移后，会报计算机中丢失 MSVCP100D.dll 解决方案：去对应工程师的电脑下，拷贝MSVCP100D.dll download提取码：fkvr 12copy xxx.dll files to C:\Windows\SysWOW64 copy xxx.dll files to C:\Windows\System32 VS2017 项目打包部署（.exe files） 参考链接 Vs的部署方式 部署连接，Mircosoft官网 Vs + Qt 的应用程序发布部署 通过编译Release 得到可执行文件exe，生成相关可执行文件 将需要发布的exe（Release ）文件编译后（如QtGuiApplication1.exe），放到单独的目录。 在“开始菜单”启动Qt 5.9.1 32-bit for Desktop (MSVC 2015); Win + R 进去 cmd编辑； cd C:\Software\kinect\QtGuiApplication1\x64\Release 进入 exe 文件的目录 执行命令 1windeployqt.exe QtGuiApplication1.exe --qmldir C:\Qt\Qt5.12.1\5.12.1\msvc2017_64\qml 生成运行时需要的文件。（源程序发生改变，需要重新生成一次） Vs 2017的依赖库 123456789进入路径C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\Remote Debugger\x64拷贝文件api-ms-win-core-* concrt140.dllmsvcp140.dllucrtbase.dllvcruntime140.dll粘贴到 *步骤一的目录下* 这样迁移到相同屏幕尺寸的电脑下，就可以运行了。 如果出现Qt提示的文字超出界面，修改字体的大小就能自适应平板了。 增加语音功能 增加语音功能，实现特定语句的播放]]></content>
      <categories>
        <category>Kinect</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect in Ubuntu]]></title>
    <url>%2F2019%2F02%2F20%2FKinect%20in%20Ubuntu%2F</url>
    <content type="text"><![CDATA[OpenKinect Application for UbuntuOpenKinect on linux 环境搭建 OpenKinect/libfreenect libusb的安装 Download libusb &gt;= 1.0.18 安装过程 ./configure执行报错时 1./configure --build=x86_64-linux --disable-udev sudo make install Use 提示安装好了lib，目录所在。 1make[1]: 离开目录“/home/quronghui/Kinect/libusb-1.0.22” 所以我们基于libusb编程的时候，需要包含这个库 */ 编译时加上 –lusb-1.0 就是这个原因，库放在这个目录下，需要链接上。 CMake安装方法 Download : Source Distribution 或者 Binary Distribution，前者是源代码版，你需要自己编译成可执行软件。后者是已经编译好的可执行版，直接可以拿来用的。 安装教程 Python3 安装方法 参考教程 下载Python3 时候特别的慢，一直在等。 Libfreenect 安装 编译 1234567git clone https://github.com/OpenKinect/libfreenectcd libfreenectmkdir buildcd build // 在这之后的操作需要插入设备 // 尽量带sudo ,不然会少安装一些东西sudo cmake -L .. # -L lists all the project optionssudo make 更新依赖库 12sudo apt-get install git cmake build-essential libusb-1.0-0-devsudo apt-get install freeglut3-dev libxmu-dev libxi-dev 测试设备 12cd build/binsudo ./freenect-glview QTGUI for linuxKinect for WindowsKinect SDK 安装 Bug 首次安装KinectSDK-v1.8-Setup]]></content>
      <categories>
        <category>Kinect</category>
      </categories>
      <tags>
        <tag>kinect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言入门]]></title>
    <url>%2F2019%2F02%2F19%2FLinuxC%2F</url>
    <content type="text"><![CDATA[Linux C编程一站式学习 LinuxC 课后习题答案 LinuxC.pdf 文档中的代码 C语言入门 程序的五个步骤 math函数的gcc编译 12$ gcc math.cpp -o math -lm // math的编译要加上 "-lm"$ gcc hello.c -o hello -Wall // gcc编译带上 -Wall,显示所有警告的信息 [UNIX编程艺术] The Art of UNIX Programming. Eric Raymond. 全局/局部变量 虽然方便，但是要慎用，能用函数传递参数的就不要使用全局变量 局部变量可以用任意类型相符的表达式来初始化,而全局变量只能用常量表达式初始化。 Debug 如果全局变量在定义时不初始化,则初始值是0。但是局部变量不初始化时，初值就不确定，局部变量先赋值 if/else else 总是和最近的一个if配对 如果需要隔开的话，加 “ { } ” 隔开 Debug Ways 增量式开发：通过printf的方式，一步步打印结果查看 printf (“ “) // 通过打印进行调试 递归函数：要加上 Base Case 12345int factorial(int n)&#123; if (n == 0) //也就是0项 return 1;&#125; 递归和循环是等价的; 用循环能做的事用递归都能做 循环函数 循环函数:相当于将函数表达式展开，然后通过while()，进行循环的迭代 do / while 的格式 123do 语句；while(); // while 后面有个分号 Break and Continue break : 跳出当前循环体，执行后面的语句； Continue : 终止本次循环(循环里面的内容，在continue之后的语句都不执行)，然后回到循环体的开头准备再次执行循环体。 表达式的左值和右值 由 “ = ”进行连接 左边：表示的是存储位置；— 称为左值 右边：表示要存储的值；– 称为右值 C 中的输入输出 printf 语句打印 1printf(" %g ") // 打印一个浮点值 格式化的输入输出 12scanf("%d", &amp;i);printf("%d", i); 字符：非格式化 12getchar();putchar(); goto 跳转语句 goto : 实现无条件的跳转 我们知道break 只能跳出最内层的循环 如果在一个嵌套循环中遇到某个错误条件需要立即跳到循环之外的某个地方做出错处理,就可以用goto 语句。 语法 12345678for (...) for (...) &#123; ... if (出现错误条件) goto error; &#125;error: 出错处理; error 叫做标号lable，给标号起名字也遵循标识符的命名规则。 goto的限制 goto 语句过于强大了,从程序中的任何地方都可以无条件跳转到任何其它地方,只要给那个地方取个标号。 唯一的限制是goto 只能跳到同一个函数的某个标号处,而不能跳到别的函数里面。 不推荐使用goto 数据1.]]></content>
      <categories>
        <category>LinuxC</category>
        <category>Emededded</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO Github]]></title>
    <url>%2F2019%2F02%2F18%2FHEXOGithub%2F</url>
    <content type="text"><![CDATA[Linux 下HEXO + Github 搭建博客HEXO 环境搭建流程 HEXO 环境搭建流程 安装Nodejs 和 npm 正式安装Hexo 初始化文件夹 hexo init Github 的部署 github 上建立repository ； 命名为 username.github.io; 修改hexo 目录下的_config.yml 12345修改hexo 目录下的_config.yml deploy: type: git repository: https://github.com/quronghui/quronghui.github.io.git branch: master 配置github 12$ git config --global user.name "yourName"$ git config --global user.eamil "email@example.com" HEXO 主题的修改 使用 NEXT主题 更改主题配置文件(NEXT)中的，站点配置文件_config.yml 动态效果还未实现 官方NEXT的配置文档 avatar 下添加头像 Hexo的Next主题详细配置 HEXO 博客分支备份 参考教程 在 hexo 博客文件夹下，创建两个分支（Github 的部署, 修改_config.yml时，只是添加git的源在里面，没有进行add 或者clone，因此没有master主分支） 12$ git branch dev(master) // 创建分支,dev只是分支名字$ git checkout dev(master) // 分支切换（也就是设置默认分支） clone 博客文件到本地，git clone https://github.com/quronghui/quronghui.github.io.git 将之前的hexo文件夹中的文件 ，复制至username.github.io文件夹，为了进行一次分支提交； 123456_config.ymlthemes/source/scaffolds/package.json.gitignore 将themes/next/ 下的.git/删除，否则无法将主题文件夹push； 123delete : themes/next/ 下的.git/删除 两个地方都删除 在username.github.io 下创建分支dev , 并且切换分支dev 这样以后就在username.github.io 下工作 123456分支： git branch dev git checkout devinstall sudo npm install sudo npm install hexo-deployer-git --save 提交文件到分支dev上。 123git add -A ;git commit -m "" ;git push origin dev ; 部署至Github上 12hexo ghexo d HEXO 博客迁移 主要是需要重装一遍环境 安装git； 安装Nodejs和npmwin； 使用`git clone -b hexo https://github.com/quronghui/quronghui.github.io.git 将仓库拷贝至本地； 在文件夹内执行以下命令 123ubuntunpm install hexo-cli -gnpm installnpm install hexo-deployer-git HEXO 博客分支问题 在quronghui.github.io 文件夹下进行提交的时候，产生了很多冲突。因此，我直接删除hexo文件夹。 使用clone将仓库拷贝至本地； 1git clone -b hexo https://github.com/quronghui/quronghui.github.io.git 在文件夹内执行以下命令 12sudo npm installsudo npm install hexo-deployer-git 这样相当于在本地重建环境 HEXO关于Tags 点击无反应 参考链接 添加标签 ： hexo new page tags 确定配置文件中，大小写一致 确认站点配置文件里有tag_dir: tags 确认主题配置文件里有tags: /tags 编辑站点的source/tags/index.md，添加 1234title: tagsdate: 2015-10-20 06:49:50type: "tags"comments: false HEXO 添加搜索 npm install hexo-generator-searchdb –save 修改站点配置文件 12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件 123hemes/next下的_config.yml文件local_search: enable: true## HEXO 添加搜索 HEXO 修改默认生成的文档界面 站点配置文件_config.yml查看 1default_layout ：post 修改 123456/scaffolds/post : 修改默认页面 layout: post title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125; categories: tags: 新建页面 使用 hexo new post &lt; name &gt; HEXO 文章引用pdf – 可查看 安装pdf插件 1npm install --save hexo-pdf 本地存在的pdf 121. 将pdf文件放在 /source/_post/name 下2. 文档中使用 &#123;% pdf ./pdf名字.pdf %&#125; 网上链接 1&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125; HEXO 添加本地文件下载 调整程序配置文件_config.yml 里的post_asset_folder:这个选项设置为True 在source下创建/document文件夹 12mkdir document把文件复制到这个文件夹 在 .md 中引入 [ name ]（/ document /name.ppt） HEXO markdown文档添加多个分类 添加子分类 123categories: - Java - Servlet 添加多个分类 123categories: -[Java] -[Servlet] Hexo 的侧边栏，显示错误 问题描述：Search 显示成了Suche]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>linux hexo github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18 And Win10]]></title>
    <url>%2F2019%2F02%2F18%2FLinuxAndWin10%2F</url>
    <content type="text"><![CDATA[Win10 + Ubuntu 双系统Win10 + Ubuntu环境的搭建 参考链接 有些工作需要切换windows,因此才搭建了双系统。 主机环境是SSD+HDD 压缩卷的时候，不用压缩SSD，找一个大一点的机械硬盘，直接将其状态删除为未分配的状态。 准备工作 下载UltralSO，这是用来制作启动盘的软件 下载Linux系统的镜像ubuntu16.04，可以在官网上下载 （可选）下载启动项编辑工具[EasyBCD] windows系统下进行分盘 我的电脑–计算机管理–压缩的磁盘–右键–压缩卷 选择未分配区域，右键选择“新建卷“ – 右键“删除卷”可以将这变成可用空间 制作ubunut启动盘 打开UltraSO软件，选择“文件”-“打开”打开之前下好的iso映像文件 选择“启动”-“写入硬盘映像”。此处注意选择正确硬盘驱动器。 依次点击“格式化”和“写入”，完成后它会在消息处提示“刻录成功！” 设置window 下的BIOS 关闭快速启动。选择控制面板-电源选项-选择电源按钮的功能，选择“更改当前不可用的设置”，取消选中“启用快速启动” 安装ubuntu 在下一步之前，一定要先联网，会进行下载 选择 安装音频相关软件…… Ubuntu 工具的安装 参考链接 用到的时候直接搜索]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArduinoMQ135]]></title>
    <url>%2F2019%2F02%2F17%2FArduinoMQ135%2F</url>
    <content type="text"><![CDATA[口气检测仪项目报告 基于Arduino和MQ135硫化物传感器，实现口气检测 [TOC] 1. 总体实现描述 人呼出的气体中含有多种痕量挥发性硫化物 , VSCs中硫化氢、甲硫醇和二甲基硫醚的量与口臭的强弱直接相关。这些化合物通常与人体健康及代谢过程相关, 一般分为口腔性和非口腔性, 其中90%来源于口腔，目前监测这种变化的方法目前有: (1) 感官分析法, 即鼻测法; (2) 仪器分析法:气相色谱法、气相色谱质谱联用法、硫化物分析仪 (Halimeter) 法、便携式气相色谱口臭测量仪。本产品主要是根据人体呼出气体中硫化物的浓度进行评判的。 本产品基于Arduino作为主控，通过其模拟通道，结合MQ135传感器，对人体呼出的气体中硫化物的浓度进行采集，（人体口气中的成分如如图）对浓度值进行AD转换，对得到的浓度值进行等级的划分，最后得到用户口气检测的等级，用户通过等级查看小程序的相关建议，从而得到口腔保护的建议。 ​ 产品设计总的流程框架图如下所示: ​ 2. 硬件平台搭建2.1 主控Arduino 主控选择开源硬件Arduino, 使用AD转换的模拟通道进行MQ135的检测，数字通道检测按键的状态，IIC通信方式显示检测过程中的浓度大小。 ​ 2.2 传感器 MQ135 传感器检测口气中可挥发性硫化物，使用的是电导率较低的二样化锡SnO2，电导率随空气中污染气体浓度的增加而增大，输出一个模拟电压，主控arduino的AD采样值进行采样，并将电压值映射10-1000ppm之间的浓度。 ​ 2.3 显示OLED 采用IIC的OLED显示屏，对检测过程中的浓度进行动态显示，并且能显示以前检测的浓度值。 ​ 2.4 按键设计 按键设计了两部分： （1）按键一：按下时开始进行口气检测，并在OLED上动态实现；当按键弹起的时候，OLED上固定显示本次检测的最大浓度值和评价等级； （2）按键二：按下的时候，显示第几次检测，检测的口气浓度值大小和等级。 2.5 供电 锂电池供电，提供充电模块。 3. 软件平台搭建 完整源码：https://github.com/quronghui/Arduino 3.1 MQ135浓度采样 通过map()函数，对采样的电压值进行映射，得到浓度值。将MQ135输出的电压值（0.1-0.3V – 4V）映射成浓度（10-1000 ppm）。 1long mapping(long x, long in_min, long in_max, long out_min, long out_max); // 函数的映射 3.2 存储采样数据 通过数据对MQ135每次采样数据的存储，通过排序得到本次检测的最大浓度值，实现按键一（中断0）的功能。 12void MemoryData(); // 采样数据的存储，存储到数据；void max(); // 排序得到最大值 3.3 EEPROM 存储本次检测的等级和浓度值 为了用户能查阅以前检测的等级，设计EEPROM函数，对每次检测的等级和浓度值进行保存，当按键二（中断1）按下时后，显示第几次检测，检测的口气浓度值大小和等级，实现按键二的功能。 12345// EEPROM 存储的函数声明void EepromWriteMaxArray(int EEP_data); // 写入每次检测到的最大浓度值EEPROM存储器,void EepromWriteGrade(int grade_data); // 写入每次检测的等级值void EepromRead(); // 从EEPROM存储器读出数据void EepromClear(); // 清除EEPROM里面的数据 3.4 OLED显示 采用IIC通信方式，动态显示每次检测的浓度值，以及显示EEPROM 存储的检测值，满足按键一和按键二的需求。 12345678// 对每一次数组的采样值进行OLED显示u8g.firstPage(); //一下是显示实现部分do &#123; u8g.setFont(u8g_font_fub30); //设置字体和自号，目前测试字号有fub14,17,20,30 u8g.setPrintPos(0, 50); //显示的位置 u8g.print(array[i]); //显示变量i的值&#125; while( u8g.nextPage() );delay(500); 3.5 浓度等级评定 浓度等级的评定，主要是根据MQ135的检测结果，和人体承受硫化物浓度的范围进行设定的，根据需求将测量的浓度等级分为5大块，具体设定参考下图。 1234567int MQgrade(int temp); // 进行等级的评定int score[] = &#123; &lt;30, // grade = 0 未检测 40,45,50, // grade = 1-3 轻微 55,65,70, // grade = 4-6 中度 75,85,90, // grade = 7-9 重度 &gt; 100 // grade =100 检测其他物体/或者传感器没有正常连接 &#125;; ​ 4. 实现效果图 实现效果图主要分为以下三部分：（1）动态检测的浓度值；（2）本次检测的最大浓度值和浓度等级；（3）显示EEPROM 存储的检测值，显示第几次检测，检测的口气浓度值大小和等级。 (1) 按键一按下后，显示口气检测仪的动态浓度采样值 (2) 按键一弹起后，固定显示本次口气检测的最大浓度值和等级 (3) 按键二：按一次，显示第几次检测（T），检测浓度大小（ppm），评价等级（G） 5. 总结注意 MQ135传感器的特性，要求预热足够的时间，40小时以上，检测的浓度值才会稳定。 口气检测仪开始检测时，要进行通电预热，待稳定的时候在进行检测。 由于MQ135的材料特性，每个传感器预热后的初值都不太相同，因此为了检测的灵敏度要求，需要手动调整一下代码。 6. 价格 物料 / 个 价格 / 元 链接 Arduino Pro Mini 10.9 智能创客科技 MQ135 9.23 risym旗舰店 OLED 22.99 telesky旗舰店 PCB制板 5 嘉利创 锂电池 13 海兄弟锂电池 其他电容电阻和接插件]]></content>
      <categories>
        <category>口气检测</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Learning Direction]]></title>
    <url>%2F2018%2F12%2F25%2FElectronicDirection%2F</url>
    <content type="text"><![CDATA[Computer Learning Direction 为何要为开源做贡献 怎么查找开源项目 Contents[TOC] 计算机相关工具 相关工具类型 名称/作用 myself Github 上的Awesome awesome : 强大的收集网站，能找到对应的模块 awesome-electronics : 嵌入式的一些相关网站 electronics AutoDesk student 免费使用的软件； Eagle : PCB软件，里面含有各大公司的封装库 Adobe Creative Cloud Adobe Creative Cloud desk，从而安装 Illustrator (AI的矢量图) clion: 一款调试方便的C/C++代码编写工具通过学校邮箱注册免费使用;(相对于vs code) vsCode 增加一个代码显示扩展工具，Monokai Pro(需要进行破解) 计算机相关书籍 搜索下载：基本上是高清的 [极客侠栈] 网页上直接搜索： xxx. epub xxx.pdf 网上的资源很多，我们需要一把钥匙，能够将这些资源灵活的用起来 书籍类型 书籍名称/介绍 是否阅读 计算机技术 计算机科学速成课 : 从嵌入式的元件，到计算机的整体架构；推荐 OK 嵌入式 面试相关 LinuxC LinuxC 编程一站式学习 : C 和 linux 的入门书籍 OK C和指针.pdf :和剑指offer一起刷的，指针讲的很好 2019.6.25 C专家编程.pdf) C Primer Plus第6版 : 用于在手边查阅 Shell 编程范例 C 语言编程透视 数据结构算法 数据结构与算法教程，数据结构C语言版教程 ：这个网址有基础知识和相应的代码； 2019.6.28 大话数据结构) 基础数据结构 算法图解 基础算法 [剑指offer] ( 结合C和指针一起看，可以编写测试代码) 2019.7.28 [编程之美] 这本书的作者，绝大部分都是微软的工程师，所以质量很有保证。算法题目稍微有点难，也不是很系统，这也是为什么我把它归到面试这一部分的原因。 编程珠玑 2 这本书最大的特色是讲了很多针对海量数据的处理技巧 [数据结构与算法分析：C语言描述原书第2版高清版.pdf] 2019.5.27 算法导论原书第3版 充斥着各种算法的正确性、复杂度的证明、推导，数学公式比较多 算法 更容易看懂，更适合初学者入门。 计算机程序设计艺术 殿堂级的 凸优化，算法优化 操作系统 操作系统导论 2019.7.28 现代操作系统 原书第4版: 提取码：j5p9 编程中的线程一直是很难理解的概念，通过理解操作系统的原理，线程的概念就很容易理解了 快乐的Linux命令行 2019.8.18 linux就该这么学 鸟哥的Linux私房菜-基础学习篇(第四版)高清完整书签PDF版.pdf 最经典的Linux系统管理和使用教程 Linux内核完全剖析 非常细致全面的一本书 linux 程序设计 深入理解Linux 内核) Orange’S:一个操作系统的实现 大神带你实现一个操作系统 UNIX操作系统设计 深入浅出 嵌入式学习 FreeRTOS / uCOS) : 嵌入式实时操作系统； 2019.8.20 《ARM体系结构与编程》ARM社区参考资料 嵌入式系统LINUX / VXWORKS 对计算机系统结构（CISC/RISC）了解到 了解bootload、kernel等启动流程 Linux 驱动 Linux设备驱动开发详解：基于最新的Linux 4.0内核 Linux设备驱动开发详解 LINUX设备驱动程序第3版完整版 IOT 先学习《MQTT 协议快速入门》 后学习《从 0 开始搭建 IoT 平台》 IOT的安全保卫战 : 区块链与物联网融合，新安防攻略 计算机网络 [图解TCP/IP 第5版 tcpip协议应用分析指导指南 TCP/IP圣经级教材 268张图解轻松入门 2019.7.28 [一本书读懂TCP/IP] TCP/IP详解 卷1 学习TCP/IP协议的圣经 TCP/IP详解 卷2：实现 下载第一卷讲理论，第二卷讲实践 TCP/IP详解 卷3：TCP事务协议、HTTP、NNTP和UNIX域协议 下载 计算机网络 系统方法 计算机网络 自顶向下的方法 UNIX网络编程 学习套接字编程最好的书籍 python 《疯狂Python讲义》它的课程体系和Python图谱技能体系不谋而合《21天通关Python》 数据库 设计模式 《大话设计模式》 本书适合编程初学者或希望在面向对象编程上有所提高的开发人员阅读。 [STL 源码剖析] 代码大全（第2版） 下载 程序员必读经典 PCB 高质量PCB设计入门 ：PCB SCH 绘制规则参考ESP32 OK 其他 程序员的自我修养 下载 硅谷之火_——个人计算机的故事.pdf [硅谷之火——PC从梦想到现实.pdf] [黑客与画家] [浪潮之巅.pdf] 嵌入式学习方向 CPU 方向： 计算机 / SOC 架构； 脚本语言，Python 优先； 物联网方案 悉 TCP 与 UDP 的特点与使用，了解 Wi-Fi / 蓝牙协议优先； FreeRTOS / uCOS 等嵌入式系统优先； 熟悉脚本语言，掌握 Python 优先； 熟悉计算机网络协议熟悉 802.11 协议或蓝牙协议优先； 熟悉 GCC 和 GDB； 熟悉系统外围驱动（I2C、SPI、UART、485）和应用的编程 Tools[github] GitHub Trend 页面总结了每天/每周/每月周期的热门 Repositories 和 Developers，你可以看到在某个周期处于热门状态的开发项目和开发者。 GitHub Topic 展示了最新和最流行的讨论主题，在这里你不仅能够看到开发项目，还能看到更多非开发技术的讨论主题， 优秀的项目 free-programming-books：整理了所有和编程相关的免费书籍，同时也有 中文版项目。 github-cheat-sheet：集合了使用 GitHub 的各种技巧。 android-open-project：涵盖 Android 开发的优秀开源项目。 chinese-independent-developer：聚合所有中国独立开发者的项目。 Autodesk 选择地区是中国的，为了后面的学校验证 { % aeest_img autodesk.png % } 用学校邮箱创建账户，进行验证 进入免费软件一栏，可以看到免费软件 { % aeest_img autodesk_free.png % } Eagle PCB绘制工具，相对于AD来说更加轻量级，而且有大量的封装库。 申请免费的Eagle { % aeest_img eagle.png % } 学习【高质量PCB设计入门–Eagle使用】 Adobe Creative Cloud Adobe Creative Cloud 通过安装Adobe Creative Cloud desk，从而安装 Illustrator (AI的矢量图) Illustrator 能够绘制矢量图，从而导入到 Eagle. Eagle : 不能写中文，而且图形不是矢量的。 Open Link IT Community stackoverflow ：IT与程序相关的IT技术问答网站 element : IT的互助社群 Lmos社区 China IT Community CSDN ：国内IT的博客分享平台 开源中国 ：中国最大的开源IT社区 IT article INfoQ UI Design UI dribbble UI Behance Vector ICONS FlatIcon : 有版权限制的矢量图标 iconfont : 矢量图标 Security Community 看雪论坛 : 致力于PC、移动、智能设备安全研究及逆向工程的开发者社区 吾爱破解：论坛致力于软件安全与病毒分析的前沿,丰富的技术版块交相辉映,由无数热衷于软件加密解密及反病毒爱好者共同维护 [ i 春秋 ]注网络安全、信息安全、白帽子技术的在线学习,教育、培训的平台 Emebadded Community hackaday ： Hardware open source items hackster ：Hardware open source store Cadlab.io ： 可以使用github push 的可视化图形软件 Arm Community: : ARM体系结构的中文社区 Crowdfunding Community kickstarter ：众筹项目 indiegogo : 众筹项目 modian : 中国的众筹项目 Hacker New ：世界的重要新闻 RSS (Really Simple Syndication) inoreader : RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合）。 feedly : Feedly是一款第三方RSS阅读器，在经过了几次更新后，已经有比较多的忠实的使用者。 第一次访问Feedly的用户，Feedly会自动提示接入 Google Reader的访问权限，无需注册新会员. 能够增加我们之前的Open Source PDF Transform Doc https://pdf2doc.com/ Algorithm visualization* https://visualgo.net/zh : 算法可视化的工具，用于展示算法的好工具 UART HMI 通过串口发送，就之间显示出对应的图形和数据 在显示屏上显示二维码就可以用。 与非网：一些嵌入式的前沿 可能你已修炼成资深行业观察家，如何小庆老师那样真知灼见； 可能你善于分析行业趋势，如飞翔的鸭子侃侃而谈； 可能你精通某一项技术，如加菲那样精讲技术而不失幽默； 可能你善于发现身边的工程师故事，如骆驼般娓娓道来。 github 优秀的用户 github 上搜索 awesome-xxxx Cheng Zheng 芋道源码 阮一峰每周分享的教程, 电子书, 网站等. EbookFoundation/**free-programming-books typing lesson 打字练习]]></content>
      <categories>
        <category>Computer Direction</category>
      </categories>
      <tags>
        <tag>Direction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows and GitHub Pages and Jeklly Building owns Bolg]]></title>
    <url>%2F2018%2F11%2F14%2F2018-11-14-win-git-jekyll%2F</url>
    <content type="text"><![CDATA[Windows By GitHub Pages and Jekyll building BlogInstall Tools 整个流程参考链接如下，包括博客的模板 Visit Link github Building yourself github account number. Build a New respository. Name : “github_name”.github.io (ep: quronghui.github.io) git clone 选好的模板 上传到你的GitHub Github Page GitHub Page 相当于一个服务器 Jekyll 运行在 GitHub Page 上 Jekyll 环境的搭建Jekyll Knowledge Jekyll 是一个简单的博客形态的静态站点生产机器 Jeklly 的一个最好的特点是“关注 blog 本身”，一个文件夹_posts下进行管理，减少繁琐 Jekyll 搭建 GitHub Pages + jekyll 的方式 直接参考这个Link Jekyll环境的搭建 Jekyll 搭建中安装包的说明 安装Ruby Ruby 是一种开源的面向对象程序设计的服务器端脚本语言 没找到在Blog中担当的角色 安装RubyGems 用于对 Ruby 组件进行打包的 Ruby 打包系统 也就是 Ruby 的管理系统 用Rubygem 安装Jekyll,所有的依赖包都会被安装 用RubyGems安装Jekyll cd到博客文件夹，开启服务器 访问 http://localhost:4000/ 提交代码到远程GitHub上 jekyll 中文说明文档 Jekyll 变量语法 jekyll serve =&gt; 一个开发服务器将会运行在 http://localhost:4000/ 始终需要重新更新 jekyll serve –watch 本地调试的时候，会自动更新 categories 和 tags categories 属性归类 tags 类似于搜索标签 date 变量 这个日期会覆盖文件命名的日期，并作为发布的时间。 Jekyll 文件夹 _posts Blog文件夹 年-月-日-标题.MARKUP MARKUP : 是一种标记，是用什么格式写。 example .md 和 .textile _assets 图片和文档目录 图片和文档的引用，前提是图片和文档放在assets 目录下 PDF文档 _drafts 草稿文件夹 保存一些占时没有写好的文档，不会进行发表。 jekyll serve –drafts : 查看未发表的草稿博客 github.io 文件夹目录 index.html – 创建主页面 任何网站的配置一样，需要按约定在站点的要目录下找到index.html 这个文件就将是你的 Jekyll 生成站点的主页。 为其他文件创建页面 命名 HTML 文件 没有真正理解这个每个页面的展示，没有成功实现 _config.yml – 文件 修改文件，好像本地博客不会发生改变代码亮亮 代码亮亮 给代码加入行号]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>jeklly Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Language]]></title>
    <url>%2F2018%2F02%2F19%2FComputerLanguage%2F</url>
    <content type="text"><![CDATA[第二章 指令–计算机的语言Schedule Dateline start time end time Learning 2018/12/6 8：50 9：50 第二章计算机指令 2018/12/7 8：20 9：30 MIPS寄存器和存储器 2018/12/8 8：40 9:11 效率低 2018/12/10 19：00 19：44 效率低 2018/12/11 8：36 9：22 多寄存器的冲突问题 Proper Noun Full name 中文 acronym instruction set 指令集 一个给定的计算机体系结构所包含的指令集合。 American Standrad Code for Information Interchange ASCII 计算机的文字处理 Acorn Risc Machine ARM 处理器 P99页 ARM 有更多的寻址模式 MIPS 有更多的寄存器 Question 1、为什么 Java 和 C 会是一样的呢？？ 解释和编译的平衡随着时间的推移逐步形成。 2、加速大概率事件？是什么意思. 3、编译C语言和解释Java语言？在配套的网站上。 Conception 指令集：计算机体系结构所包含的指令集合； MISP: 可方便硬件和编译器的设计，性能最佳且功耗最低。 存储程序的概念：多种类型的指令和数据均以数字形式存储于存储器中的概念。 数据传送指令：在存储器和寄存器之间移动数据的指令； 地址：用于在存储器空间中表示元素位置的值 存储程序：存储器存放程序和编译后的机器码（0/1），文本；甚至是用于生成机器码的编译器。 MIPS 的指令集 MIPS指令集，是一种寄存器到寄存器的语言。 MIPS操作数： | 类别 | 表示 | 数据访问 | 特点 || —————- | ——– | —————————- | ————————————– || 32个寄存器(32位) | $zero | 寄存器用于数据的快速存取 | 只能对存放在寄存器的数据进行算术操作。 || 2^30个存储器字 | Memory[] | 只能通过数据访问传输指令访问 | 字节编程；相邻Memory[4] 字地址相差4 | MIPS 算术运算 一条指令，由三个操作数构成 其余的汇编指令 P42页 ​ MIPS 32位各字段的表示和命名 操作码：指令中用来表示操作和格式的字段 计算机硬件的操作数 寄存器 $s0…… 用于表示C和Java程序中变量所对应的寄存器； $t0……用于表示将程序编译为MIPS，用到的临时寄存器； MIPS 算数运算指令的操作数，必须来自寄存器，由于寄存器位数有限，所以需要从存储器中取数据； 存储器 数据传送指令和地址； 存放像数组或结构那样的复杂数据结构； 存储器 –&gt; 寄存器 ：取数操作 load word 寄存器 –&gt; 存储器 ：存数操作 store word 软硬件接口 将变量和寄存器对应； 编译器在存储器中为数组和结构数据分配相应的位置； 编译器将存储器中数据对应的起始地址存放在：数据传送指令中。 软硬件接口 由于load和store指令中的地址是二进制的，作为主存的DRAM容量使用二进制而非十进制。 符号位和非符号位表示方式 负数的表示方式：采用补码的形式表示 补码：最高位设置为1，源码取反（最高位不变），最低位加1。 软硬件接口 寄存器的数量和定长指令的需求和设置–矛盾； 寄存器任何数量的增长，都需要在指令格式中各个寄存器字段至少增加一位； 寄存器越小越快，所以目用的寄存器大多是16/32。 逻辑操作 逻辑左移sll 和右移srl ：$$左移i位 = 原数 * 2^i$$ 软硬件接口 编译器的最初阶段：将程序分解为若干基本块； 基本快：没有分支，并且没有分支目标和标签的指令序列. 计算机硬件对过程的支持 为了解决更多寄存器使用的冲突问题。 栈的使用 栈的增长是一种先进先出的结构； 地址从高到低进行的,压栈时，栈的指针值减小；（从上到下） 过程嵌套，出现寄存器的冲突问题 通多对寄存器进行压栈处理，解决冲突； 软硬件接口–全局指针 全局指针：$gp，指向静态数据区的保留寄存器 为了简化静态数据的访问时间。 栈中使用的指针 帧指针（frame pointer)：$fp—-指向过程帧的第一个字； 栈指针：$sp 指向栈顶 人机交互 计算机是为了数字计算 计算机表示文字的处理，实现了人机交互。遵循ASCII 为了表示web的全球特性,当今的大部分web页面采Unicode,而非ASCII。 Java中的字符和字符串 字符串是一个标准的Java类，它对连接，比较，转换的方法提供了专门的方法 P75 数组和指针 1、指针中变量的地址用 &amp; 表示，指针所指向的对象用 * 表示。 2、寄存器的操作都是通过地址进行操作的。 3、编译器技术的理解，是理解性能的关键。 ARM7(32)位指令集 区别 ARM(32位) MIPS 多寻址模式 多寄存器 保存0 没有专门的寄存器 zero寄存器保存 第三章 计算机的算数运算Proper Noun Full name 中文 acronym Arithmetic logic unit 算数逻辑单元 ALU Exception Program Counter 异常程序计数器 EPC Question ？ 1、无符号数通常表示内存地址，溢出可以忽略？ 2、每个编译器都将以2为底的指数乘法替换为移位来进行优化。 3、使用32位数据表示通常要处理的无限数字。 4、乘法和除法：尽可能用 0/1 加法和减法 运算规则 加法运算：从右到左，二进制代码相加进位； 减法运算：将负数取反后，按照加法进行 计算是否会溢出 加法:源操作数异号时，不会溢出。 减法:源操作数同号时，不会溢出。 异常程序计数器EPC 保存导致异常的指令地址 乘法 乘法运算 被乘数和乘数的表示？ 被乘数每次左移一位，和乘数的一位相乘，结果相加 积的位数 = 被乘数的位数 + 乘数的位数 被乘数，乘数，积 每次进行的移位操作 积：每次的求和结果 更快速乘法 给每一个乘法数分配一个32位的加法器； 形成一个加法树； 除法 除法没有怎么看懂？ 计算的方式 除数：在右边补0，使其和被除数一样的位数 计算的时候：商左移，除数右移 除法：做减法；乘法：做加法 第四章 处理器]]></content>
      <categories>
        <category>Hardware Interface</category>
        <category>Computer-Composition-Principle</category>
      </categories>
      <tags>
        <tag>Hardware Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-matric]]></title>
    <url>%2F2018%2F02%2F18%2FMath-matric%2F</url>
    <content type="text"><![CDATA[邮箱： hustmath2018@163.com – math2018 typora使用操作 矩阵论 考试内容 Schedule Dateline start time end time Learning 2018/12/4 20:00 20:40 2018/12/10 20:00 10:00 2018/12/12 15:10 2018/12/13 14：35-17: 10 19:20- 2018/12/15 15：00 线性空间 条件：V是一非空集，F是数域，V中元满足向量的一些性质（数乘，交换和结合）； 结论：V为F上的线性空间(或向量空间),记为V(F); 空间V中的元称为向量； 若 性质：零元是唯一的 线性相关：集合中某一元素可由其他元素组线性表示。 线性无关定义： 当 m &gt;2 时；线性无关的条件是，向量组a_i中没有一个元素，可以由其他元素线性表示 单个非零向量组是线性无关； 在空间V中若能找到 n 个线性无关的向量组成dimV = n; 基（基底）的概念 基：最大线性无关向量的集合。 如何求多项式P(t)，在基B={a_i}下，的坐标x={x_i} 坐标：其实就是 A x = b中，向量x的解 求解：（1）构造增广矩阵，进行初等行变换化简；（2）行元素对应相等进行求解 基变换矩阵 空间 V 中的两个基B1 和 B2，存在一个变换矩阵P(ij)，使得B2中的每一个元素，可以通过B1和矩阵P(ij)的某一列相乘得到： 求解技巧： 通过逆矩阵：求解的坐标是n*m维，选用增广矩阵构造 单位矩阵 E，进行初等行变换； 坐标变换矩阵 由基变换引出的概念：求同一个坐标下，不同基对应的元素求解； 根据对应关系求解就行：向量 X = 基 B * 坐标 P； 这样，在根据基变换矩阵便可以求出关系式 当基为标准基：单位矩阵时；任何其他基，相同坐标下的向量都为零矩阵 子空间 线性空间V本身及由V的零元构成的零空间(记为{0}，都是V的子空间，称它们为平凡子空间。 张成子空间：span 子空间W的交；子空间W的和 —-维度 对于维度：先求W的和，再用公式求W交 子空间满足维 dim 的性质，维度就是不能线性表示的，元素的个数。 子空间的交，和满足的维度dim 子空间W的交；子空间W的和 —-基 对于基：先求W交的基，在求W和的基； 对于：W的交求基 存在一组不全为0的K，使得 V * K =0；最大线性无关向量的集合。 对于：W的和求基 直和：强调的是和空间的元素：唯一分解为两个子空间（各出一个元素）的和 直和：会考证明题——根据性质进行判断 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 2. 直和的性质： 1. W的交为零空间； 2. dim( W1 + W2) = dim(W1) + dim(W2) 3. 直接证明组成的：W(1)+W(2)—线性无关 直和的性质： W的交为零空间； dim( W1 + W2) = dim(W1) + dim(W2) refs/remotes/origin/master]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>matric</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera]]></title>
    <url>%2F2018%2F02%2F18%2FCamera%2F</url>
    <content type="text"><![CDATA[摄影知识三大元素 拍摄参数 | 场景 | 模式 | 光圈 | 感光度IOS | 快门 || :——–: | :——————: | :———————–: | :———: | :————: || 拍人像 | A模式-光圈优先 | 大光圈f/1.4、f/1.8、f/2.8 | 低 ISO &lt; 50 | A模式自动生成 || 拍夜景 | M-手动 或者 A | 大光圈 | 高ISO &gt; 400 | 大 = 1 / value || 晴朗的户外 | M-柔散迷人的景深效果 | 大光圈（F2.8） | 低 ISO &lt; 50 | 小 = 1/4000秒 || 快速的运动 | S-快门优先 | | | || 最常用的 | A-光圈优先 | 中等最好 | | 快门补偿曝光 | 光圈 摄影最重要的一个概念：光圈优先。光圈优先就是手动定义光圈的大小，相机会根据这个光圈值确定能正确曝光的快门速度。 光圈就是镜头里调节进光孔大小的装置。 光圈值： F1， F1.4， F2， F2.8， F4， F5.6， F8， F11， F16， F22， F32， F44， F64； 光圈大小：依次减小；进光量依次减小，相邻进光量相差一倍； 构图确定情况下（焦距确定），我们能控制景深的武器就只剩下光圈了。 大光圈（f/1.4、f/1.8、f/2.8等） 适用于光线不足时，增加曝光时间（快门速度变慢）； 背景模糊=景深浅：适用于拍人像（光圈数值越大，清晰的区域越小）； 小光圈（f/11、f/16、f/22等） 适用于光线充足时，捕捉时间； 背景清楚=景深深：适合拍风景（光圈数值越大，清晰的区域越大）； 中等光圈 镜头在中等光圈的时候成像最好（图片最清晰），成像最好的那档光圈就是最佳光圈； 景深：能够清晰成像的距离 景深浅，前景清晰，背景模糊；景深深，前景清晰，背景同样清晰； 拍摄时光圈越大景深就越浅； 拍摄时采用镜头焦距越长景深就越浅； 拍摄时相机与被摄对象距离越近景深就越浅。 调节位置：副拨码盘 感光度 IOS 高画质、低噪点与慢速快门 ISO &lt; 50 为低感光度 可以获得极为平滑、细腻的照片； 只要能够把照片拍清楚，就尽量使用低感光度。（宁可开大一级光圈，也不要把感光度提高一挡）; ISO400以上是高感光度 高的感光度能获得更快的快门速度; 但是高感光度的画质则是噪点比较大； 夜景的部份，则主要是利用在需要凝结瞬间的情境; 建议值：晴朗的室外使用ISO100；阴郁的天气使用ISO200；室内使用ISO400或更高。 调节位置 快门时间 快门时间 = 1 / value 快门速度 value 很大时：高速运动的瞬间被凝结了； value 很慢时：运动的过程被凝结下来 安全快门速度 快门值不慢于1/镜头焦距； 你使用的是50mm，快门值1/50便可以拍到一张不手震的照片了； 快门值设置 拍行走或快速移动时，设在1/250秒左右； 更快的自由落体或飞驰的物体，提高到1/400秒左右； 快速飞行时，设在1/800秒以上。 测光和自动曝光测光 测光范围：调节的方式 曝光和测光是一对双胞胎，如果不能准确测定光照强度，正确曝光就无从谈起。 点测光 ：只测取景框内一个小点的光线强度； 中央重点测光是简化的区域（平均）测光； 区域（平均）测光：加权平均得到光照强度； 曝光值：正值使拍摄对象更亮，负值则使其更暗]]></content>
      <categories>
        <category>Camera</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Outline and Technology]]></title>
    <url>%2F2018%2F02%2F18%2FComputerComposition-principle%2F</url>
    <content type="text"><![CDATA[第一章 计算机概要与技术 Proper Noun Full name 中文 acronym personal mobile device 个人移动设备 PMD Warehouse scale computer 巨型数据中心 WSC Liquid Crystal Display 液晶显示 LCD active matrix display 动态矩阵显示 Integrated circuit 集成电路 Central peocessor unit 中央处理单元 CPU dynamic random access memory 动态随机存储器 DRAM static random access memory 静态随机存储器 SRAM – 价格高于DRAM very large-scale integrated circuit 超大规模集成电路 VLSI clock cycle per instruction 执行每条指令所需时钟周期数的平均值 CPI System performance evaluation cooperative 计算机组织，为现代计算机系统建立基准测试集 SPEC Conception 计算机革命推动人类的进步 个人计算机和服务器 服务于个人，和服务于多人的一种可视化操作系统 嵌入式计算机：嵌入到其他设备中的计算机，一般运行预定义的一个或者一组应用程序。 云计算：集群服务器 软件即服务 现代微处理器： 理解现代微处理器硬件如何使性能提高200倍。 摩尔定律： 计算机设计者面临问题： 单芯片上的集成度没18-24个月翻一番，意味着驱动的快速变化。 使用抽象简化设计 抽象：表示不同的设计层次，从高层此种只能看到一个简化模型。 通过冗余提高可靠性 使用冗余部件提高系统的可靠性，并可以帮助检测错误。 学到啥 如何正确剖析软硬件，如何评价性能与功耗 程序入门概念 应用软件–&gt;系统软件–&gt;硬件执行 系统软件 提供常用的服务软件：操作系统，编译程序，加载程序和汇编程序。 操作系统 编译程序：将高级语言翻译为计算机识别的机器语言的程序 指令 0/1数字：即表述指令（计算机硬件理解并服从的命令），又表示数据（二进制位） 汇编语言 语言是一种指令（表示），程序是转换的过程。 汇编程序：将指令由助记符形式翻译成二进制形式的程序 汇编语言：以助记符形式表示的机器指令； 机器语言：以二进制形式表示的机器指令 硬件入门 正确剖析软硬件 基础硬件的基本功能 输入数据–输出数据–处理数据（数据通路和控制器）–存储数据 显示器 图像由像素矩阵组成，可以表示成二进制位的矩阵，称为位图（bit map） 处理器 逻辑上分为两部分：数据通路和控制器 数据通路：负责完成算数运算 控制器：负责指导数据通路 内存 内存：程序运行时的存储空间， 由多片DRAM组成 缓存 cache memory — SRAM 处理其内部的另外一种存储器 小而快的存储效应，作为DRAM的缓冲 抽象之一 - P15 该抽象被命名为计算机指令集体系结构 – 体系结构 硬件的实现方法必须依照体系结构的抽样 抽象系统中的一个关键接口是指令集体系结构–硬件和底层软件的接口 计算机网络 计算机不可缺少的功能 晶体管-硅制作的工艺–芯片chip 成品率的计算 性能 性能的评价因素 响应时间和吞吐量 增加性能和降低执行时间是一个倒数关系 CPU（Central Processing Unit） 性能及其影响因素 时钟周期数、时钟周期时间（时钟频率的倒数） CPU（t） = CPU ( 时钟周期数 ) / CPU ( 时钟频率 ) CPU 时钟周期数 = 程序的指令数 * CPI(每条指令的平均时钟周期数） 经典公式 ：CPU(t) = 指令数 * CPI / 时钟频率 功耗：使用能耗更合理 功耗：由于CMOS管0-1-0的跳变 能耗的来源是 CMOS 管开关动作中的消耗 一个晶体管能耗 = 1/2 负载电容 电压（平方） 一个晶体管功耗 = 1/2 负载电容 电压（平方）* 开关频率 单处理器–&gt;多处理器 原因： 增加多个微处理器，得到更大的吞吐量。不再继续追求单个程序运行在单个处理器上的响应时间 单处理器–processor or cores; 多核处理器(微处理器)– microprocessor 并行性 并行性对计算机性能十分重要，但它往往是隐蔽的 挑战：调度、负载平衡、同步、通信 硬件/软件接口：显示并行编程 并行性对计算机一直十分重要 程序员未来：显式并行编程，不单是串行 Iner Core i7 基准 SPEC CPU 基准测试程序 工作负载：运行在计算机上的一组程序。 基准测试程序：用于比较计算机性能的一组程序。 SPEC 采用单个的数字来进行归纳 SPECpower 功耗是有规定 称为：overall ssi_ops per watt 计算公式 谬论和陷阱 谬论：面向性能的设计和面向能量效率（功耗）的设计具有不相关的指标。 陷阱：用性能公示的一个子集去度量性能。 硬件和软件的设计者都采用分层的方法构建计算机系统，每个下层都对其上层隐藏本层的细节。 抽象：理解硬件和底层软件之间的接口，指令集的体系结构。 执行时间：唯一有效且不可推翻的性能评价指标。]]></content>
      <categories>
        <category>Hardware Interface</category>
        <category>Computer-Composition-Principle</category>
      </categories>
      <tags>
        <tag>Hardware Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HC-05-Bluetooth]]></title>
    <url>%2F2018%2F02%2F18%2FHC05-Bluetooth%2F</url>
    <content type="text"><![CDATA[HC-05-Bluetooth-ATResourse 这个软件只能设置HC-03 和HC-05,其他的还需要另外的软件 百度网盘 AT指令调试 先安装setep控件； 打开“蓝牙测试软件”，这样才会获取模块的信息； HC-05的模块进入绝对AT状态 按住按键在上电（或者EN脚接高电平）； 波特率 38400； 按照AT指令输入相应的设置；]]></content>
      <categories>
        <category>Bluetooth</category>
      </categories>
      <tags>
        <tag>Bluetooth</tag>
        <tag>AT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP8266]]></title>
    <url>%2F2018%2F02%2F18%2FESP8266%2F</url>
    <content type="text"><![CDATA[ESP8266 串口测试 串口WiFi，将串口数据发送到服务器上 工作： 连接wifi 开启服务器监听，连接到服务器 所需工具软件 下载串口调试工具sscom 这个调试工具在输入 AT command后,需要加同一个回车 硬件 ESP8266 USB转TTL下载器 接线方式 esp8266供电方式VCC = 3.3v EN 使能方式,上拉到VCC=3.3v AT指令测试 ATcommand 波特率的设置9600 或者115200 ESP8266有三种模式 第一种是客户端模式：Station 第二种是接入点模式：AP 第三种是两种模式共存:Station+AP 发送指令：AT+CWMODE=3 发送指令：AT+CWJAP=”SSID的信号名”,”密码” 建议：在之后的实验中，可以先用手机热点或者电脑热点来测试设备。 重启自动连接 EN：使能脚需要一直拉高 ESP8266 tcp测试理论知识 什么是TCP 什么是UDP？ 任何网络服务器：理解为监听在指定端口的程序，负责接收数据并且做出反应。 需要在同一个网络下进行测试。ep：ESP8266和主机处于同一个路由器下。 手机作为服务器，进行TCP测试 测试原因：台式机没有无线发射器；实验室路由器没有充钱 后续： 在手机上测试，明白其原理，后续还是需要无线发射器。 软件 电脑：下载串口调试工具sscom 手机：手机TCP调试助手USR-TCP-Test 硬件 ESP8266 USB转TTL下载器 测试过程 手机开启热点，等待被连接； 电脑打开 sscom ,进行AT指令调试； AT+RST // 重启模块 AT+CWMODE=3 // 设置模式Station+AP 第三种是两种模式共存 AT+CWJAP=”SSID的信号名”,”密码” // 连接手机热点 AT+CIFSR // 查看ESP8266连上热点后的IP 注意 AT指令输入后，都会输出OK, 才表明配置成功 此时手机WLAN扫描可以看到ESP8266的wifi 如果不知道名字，可以先配置连上手机热点，看连接设备的名字。 手机打开调试助手–USR-TCP-Test 手机作为服务器，进行端口监视； 选择 tcp serve 配置端口号（IP 地址是手机网络的IP，不能更改（电脑也一样）） 点击激活，记下此时出现的 IP 和 端口port 切换到电脑 sscom, 进行AT调试 AT+CIPSTART=”TCP/UDP”,”IP”,port // 输入serve的IP和port,TCP/UDP用大写 手机端显示tcp连接成功的设备 此时，ESP8266和serve建立起了tcp连接；后面进行数据发送。 电脑 sscom，AT调试 AT+CIPSEND=4 // 设置数据包的字节数 输入 ABCD ESP8266作为服务器，进行TCP测试测试条件 在上面软硬件的基础上； ESP8266 连上手机wifi热点 测试过程 电脑端sscom AT+CIFSR // 查看ESP8266连上热点后的IP，使用START下的IP AT+CIPMUX=1 // AT+ CIPMUX=1 时才能开启服务器 AT+CIPSERVER=1,333 // 开启 server 后自动建立 server 监听 此时ESP8266开启了服务器监听 手机USR-TCP-Test，选择TCP Client 输入ESP8266模块的START_IP,和port; 连接服务器 输入数据进行发送 服务器接收到的数据 将手机换成笔记本 只需要换一个TCP调试工具 NetAssist。 完成了ESP8266的数据收发问题 接下来结合arduino,进行数据测试 参考链接]]></content>
      <categories>
        <category>WIFI</category>
      </categories>
      <tags>
        <tag>ESP8266</tag>
      </tags>
  </entry>
</search>
